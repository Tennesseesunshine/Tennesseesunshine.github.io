<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>移动端适配解决方案</title>
    <link href="/2022/08/27/px-to-vw/"/>
    <url>/2022/08/27/px-to-vw/</url>
    
    <content type="html"><![CDATA[<p>移动端适配有很多方案，其中 <code>rem</code> 是被大家一直利用的一种方案。</p><p>目前我司在用的另一种布局方案，<code>viewport</code>，<code>caniuse</code> 查询 <code>viewport</code> 的兼容性基本都没问题，整体支持率达到 <code>98.35%</code>。今天的主角是 <code>postcss-px-to-viewport</code>，移动端适配可以通过这个插件来解决。</p><p>要使用 <code>viewport</code> 适配方案，必须先要安装 <code>postcss-px-to-viewport</code> 这个包，<code>postcss-px-to-viewport</code> 是将 <code>px</code> 单位转换为 <code>vw、vh</code> 的一个 <code>npm</code> 插件。</p><p>在 <code>vue-cli</code> 创建的项目中来做一下演示</p><ul><li>首先我们创建一个项目并且来安装对应的插件</li></ul><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">vue <span class="hljs-keyword">create</span> postcss-px-<span class="hljs-keyword">to</span>-viewport-demo<br><br>cd postcss-px-<span class="hljs-keyword">to</span>-viewport-demo &amp;&amp; yarn <span class="hljs-keyword">add</span> postcss-px-<span class="hljs-keyword">to</span>-viewport -D<br></code></pre></td></tr></table></figure><ul><li>初始化好的 <code>vue</code> 项目根目录下创建 <code>.postcssrc.js</code> 文件</li><li>添加配置</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">plugins</span>: &#123;<br>    <span class="hljs-attr">autoprefixer</span>: &#123;&#125;, <span class="hljs-comment">// 浏览器自动添加相应前缀，如-webkit-，-moz-等等</span><br>    <span class="hljs-string">"postcss-px-to-viewport"</span>: &#123;<br>      <span class="hljs-attr">unitToConvert</span>: <span class="hljs-string">"px"</span>, <span class="hljs-comment">// 要转化的单位</span><br>      viewportWidth: <span class="hljs-number">750</span>, <span class="hljs-comment">// UI设计稿的宽度</span><br>      unitPrecision: <span class="hljs-number">5</span>, <span class="hljs-comment">// 转换后的精度，即小数点位数</span><br>      propList: [<span class="hljs-string">"*"</span>], <span class="hljs-comment">// 指定转换的css属性的单位，*代表全部css属性的单位都进行转换</span><br>      viewportUnit: <span class="hljs-string">"vw"</span>, <span class="hljs-comment">// 指定需要转换成的视窗单位，默认vw</span><br>      fontViewportUnit: <span class="hljs-string">"vw"</span>, <span class="hljs-comment">// 指定字体需要转换成的视窗单位，默认vw</span><br>      selectorBlackList: [], <span class="hljs-comment">// 指定不转换为视窗单位的类名，</span><br>      minPixelValue: <span class="hljs-number">1</span>, <span class="hljs-comment">// 默认值1，小于或等于1px则不进行转换</span><br>      mediaQuery: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否在媒体查询的css代码中也进行转换，默认false</span><br>      replace: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否转换后直接更换属性值</span><br>      exclude: [<span class="hljs-regexp">/node_modules/</span>], <span class="hljs-comment">// 设置忽略文件，用正则做目录名匹配</span><br>      landscape: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否处理横屏情况</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>因为我们设置的基准宽度是 <code>750</code>，最后在 <code>vue-cli</code> 生成的文件中找一个 <code>vue</code> 文件，设置一下图片 <code>Logo</code> 大小为 <code>width: 75px</code> ，在浏览器控制台会发现图片的 <code>width</code> 变为 <code>10vw</code> 。至此可以看出我们的插件生效了~</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell中如何为Node设置环境变量</title>
    <link href="/2022/04/30/shell-export-var-to-nodejs/"/>
    <url>/2022/04/30/shell-export-var-to-nodejs/</url>
    
    <content type="html"><![CDATA[<h4 id="利用-shell-在构建-run-npm-命令的时候传递不同参数解决频繁改动代码的问题。"><a href="#利用-shell-在构建-run-npm-命令的时候传递不同参数解决频繁改动代码的问题。" class="headerlink" title="利用 shell 在构建 run npm 命令的时候传递不同参数解决频繁改动代码的问题。"></a>利用 <code>shell</code> 在构建 <code>run npm</code> 命令的时候传递不同参数解决频繁改动代码的问题。</h4><p>举一个比较常见的场景，如果我们做移动端开发，有时候需要调试一些东西，例如我们会用 <code>vconsole</code>，我们可能会写这一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">"production"</span>) &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">"vconsole"</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">new</span> res.default();<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是有另一种情况，我们部署到测试环境了，我们依然需要打开调试，但是部署之后如果我们不设置环境变量，我们的环境会被误认为线上环境，也就是 <code>process.env.NODE_ENV</code> 是 <code>production</code>。</p><p>基于这个问题，我们可以在构建的时候去做一些处理，整体的思路就是：执行 <code>shell</code> 构建的时候我们为对应的构建命令传递参数，<code>shell</code> 拿到这个参数之后，就可以把参数加到环境变量中，<code>node</code> 便可以读取出来，从而在我们打包的时候，<code>node</code> 从 <code>process.env</code> 中读取这个值进行不同的逻辑处理。</p><p>如果我们的构建是通过 <code>shell</code> 来编写的话，那会更加容易和好理解。<br>假设我们的项目是 <code>vue</code>，并且根目录下构建脚本是这样子的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">+script <br>  - dev.build.sh<br>  - pro.build.sh;<br></code></pre></td></tr></table></figure><p>我们的 <code>package.json</code> 里面会有 <code>dev</code> 和 <code>pro</code> 的 <code>build</code> 命令。<br><code>package.json</code> 里的命令假设如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">"script": &#123;<br>  "dev:build": "env MODE=build vue-cli-server build",<br>  "build": "env MODE=build vue-cli-server build",<br>&#125;<br></code></pre></td></tr></table></figure><p>我们最终还需要有 <code>web</code> 来触发 <code>sh</code>，并且可以承载手动构建的时候传递不同的参数。</p><p>从上边的命令来看，本地打包和生产打包其实没有什么区别，分别是开发环境下的 <code>build</code> 和生产环境下的 <code>build</code>，那我们部署测试环境的时候一般都使用的是 <code>npm run build</code>，而我们上线时候的打包命令也是这个。那我们怎么才能区分出来是什么环境呢？</p><p>假设我们的 <code>shell</code> 是这样写的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash<br></span><br>VCONSOLE_ENABLE=<span class="hljs-variable">$1</span><br><br><span class="hljs-keyword">if</span> [[VCONSOLE_ENABLE === <span class="hljs-string">'1'</span>]] ;<span class="hljs-keyword">then</span><br>  <span class="hljs-built_in">export</span> VCONSOLE_ENABLE=<span class="hljs-literal">true</span><br><span class="hljs-keyword">fi</span><br><br>npm run dev:build<br></code></pre></td></tr></table></figure><p>如果我们手动构建可以在 <code>web</code> 端通过 <code>ci</code> 把参数值分别传递不同的命令中，这样我们就可以在 <code>web</code> 手动构建的时候为不同的环境构建传递不同的参数值，当我们执行 <code>sh script/dev.build.sh ${VCONSOLE_ENABLE}</code>，我们便会在 <code>sh</code> 里获取到对应的变量<code>$1</code>，从而通过 <code>shell</code> 条件导出环境变量，<code>1</code> 开启，其他值关闭，并且默认应该关闭。</p><p>这个时候我们的 <code>node process</code> 是可以读取到这个变量的，通过 <code>process.env.VCONSOLE_ENABLE === &#39;true&#39;</code> 便可以判断是否需要开启调试，从而在构建的时候执行要不要引入 <code>vconsole</code>。</p><p>最终我们 <code>main.js</code> 的代码会变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.env.VCONSOLE_ENABLE === <span class="hljs-string">"true"</span>) &#123;<br>  <span class="hljs-keyword">import</span>(<span class="hljs-string">"vconsole"</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">new</span> res.default();<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>从而在构建的时候解决需不需要开启调试的功能而非每次修改代码~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>Node</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端批量导出接口数据方案</title>
    <link href="/2021/06/25/web-browser-export-file/"/>
    <url>/2021/06/25/web-browser-export-file/</url>
    
    <content type="html"><![CDATA[<p>中后台导出数据的需求场景目前已经是非常常见的，所以在个人遇到这个问题的时候，尝试前端解决并且使用的一些方案。</p><p>目前总结了下，大致两个方案：要么导出 <code>excel</code>，要么导出 <code>csv</code>，具体在哪 <code>node</code> 层还是浏览器可以看需求以及性能来调整。</p><h2 id="方案一：node-层将-json-数据转换为流，前端直接下载"><a href="#方案一：node-层将-json-数据转换为流，前端直接下载" class="headerlink" title="方案一：node 层将 json 数据转换为流，前端直接下载"></a>方案一：<code>node</code> 层将 <code>json</code> 数据转换为流，前端直接下载</h2><p>这个前提是有 <code>node</code> 作为中间层，可以把一些数据在这一层适配，所以一些数据的映射、代码的复用也都可以在这一层，在这一层将 <code>json</code> 转为流 <code>excel</code>。</p><p>思路就是前端发起一个请求，将请求参数给 <code>node</code> ，<code>node</code> 利用 <code>axios</code> 发起多个请求，请求的就是导出数据的接口，但是接口返回的是 <code>json</code> 数据，所以在用 <code>Promise.all</code> 请求完成数据之后，在服务端利用 <code>xlsx</code> 的包将 <code>json</code> 数据转为流，前端利用 <code>blob</code> 来处理下载。</p><p>这里需要注意下：</p><ul><li><code>xlsx</code> 转为表格的时候数据的格式应该是 <code>[[&#39;标题&#39;, &#39;生日&#39;, &#39;年龄&#39;],[&#39;title&#39;, &#39;birthday&#39;, &#39;age&#39;],[&#39;title&#39;, &#39;birthday&#39;, &#39;age&#39;]...]</code>，这个数组的第一项就是 <code>excel</code> 的表格表头，剩下的项目是请求回来 <code>json</code> 数据的每一个需要导出的项。</li></ul><p>我们伪代码来演示一下：</p><h3 id="node-层"><a href="#node-层" class="headerlink" title="node 层"></a><code>node</code> 层</h3><ul><li>主逻辑，因为我们用的是 <code>thinkjs</code>，所以按照 <code>think</code> 的方式处理参数。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> XLSX = <span class="hljs-built_in">require</span>(<span class="hljs-string">"xlsx"</span>);<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">downloadExcelAction</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> EXCEL_TITLE = [<span class="hljs-string">"标题"</span>, <span class="hljs-string">"生日"</span>, <span class="hljs-string">"年龄"</span>];<br><br>  <span class="hljs-comment">// 实际我们在使用的时候就应该是这样获取数据</span><br>  <span class="hljs-comment">// const params = this.post() // 获取body参数</span><br>  <span class="hljs-comment">// const serviceUrl = this.get('serviceUrl') // 获取get请求参数的实际服务端地址</span><br>  <span class="hljs-comment">// const data = await Promise.all(mapRequestList(serviceUrl, params))</span><br><br>  <span class="hljs-comment">// 这里可能需要额外做一个处理，data返回的数据格式或许是[[],[],[]]</span><br>  <span class="hljs-comment">// 我们需要处理每一项，promise.all接受的数据应该被打平</span><br>  <span class="hljs-comment">// 即data.flat(2) 或者 flatten(data)</span><br><br><br>  <span class="hljs-comment">// 这是一个我们先准备的假数据</span><br>  <span class="hljs-keyword">const</span> data = [<br>    &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">"第一个"</span>,<br>      <span class="hljs-attr">birthday</span>: <span class="hljs-string">"1999/01/03"</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-string">"23"</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">"第二个"</span>,<br>      <span class="hljs-attr">birthday</span>: <span class="hljs-string">"2000/12/03"</span>,<br>      <span class="hljs-attr">age</span>: <span class="hljs-string">"20"</span>,<br>    &#125;,<br>  ];<br><br>  <span class="hljs-keyword">let</span> xlsxData = [];<br>  data.forEach(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> d = [element.title, element.birthday, element.age];<br><br>    <span class="hljs-comment">// 这里不使用push是为了避免数据顺序问题</span><br>    xlsxData[index] = d;<br>  &#125;);<br>  xlsxData = [EXCEL_TITLE, ...xlsxData];<br><br>  <span class="hljs-comment">// 最后我们要生成的表格肯定是这样的一个数据结构 xlsxData 再调用xlsx的api</span><br>  <span class="hljs-keyword">const</span> sheet = XLSX.utils.aoa_to_sheet(xlsxData);<br><br>  <span class="hljs-comment">// 获取上下文</span><br>  <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>.ctx;<br><br>  <span class="hljs-comment">// excel 转 node 文件流</span><br>  <span class="hljs-keyword">const</span> result = sheetToBuffer(sheet);<br><br>  <span class="hljs-comment">// 设置 excel 下载的响应 Content-Type</span><br>  <span class="hljs-keyword">const</span> mimeType =<br>    <span class="hljs-string">"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"</span>;<br>  ctx.set(<span class="hljs-string">"Content-Type"</span>, mimeType);<br>  ctx.body = result;<br>  ctx.status = <span class="hljs-number">200</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，这里我们模拟的数据使用的是一个已经定义好的数组 <code>data</code>，但是现实情况肯定是需要向服务端发请求获取数据，所以这里可以利用 <code>Promise.all</code> 处理。假设列表页中需要导出数据 <code>10000</code> 条，每次请求 <code>500</code> 条，需要请求 <code>20</code> 次，每次分页偏移量增加 <code>1</code>，所以具体的实现伪代码：</p><ul><li><code>baseAxiosRequest</code> 最基本的单元接口请求数据的方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<br><br><span class="hljs-comment">// 这里接受两个参数一个请求地址一个请求参数，请求就是一些分页、偏移量以及别的参数等。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseAxiosRequest</span>(<span class="hljs-params">serviceUrl, params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> axios<br>      .get(serviceUrl, &#123;<br>        params,<br>      &#125;)<br>      .then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 这里根据自己服务端响应格式，将获取的list[]数据从当前函数返回出去</span><br>        <span class="hljs-keyword">const</span> &#123; desc, errorno, data &#125; = result;<br>        <span class="hljs-keyword">if</span> (errorno === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 这里 return 或者 resolve 的区别可以看上一篇整理</span><br>          <span class="hljs-comment">// [Promise 中的 resolve 和 return 的疑惑](https://tennesseesunshine.github.io/2021/06/13/promiseResolveReturn/)</span><br>          <span class="hljs-keyword">return</span> resolve(data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> reject(desc);<br>        &#125;<br>      &#125;)<br>      .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> reject(err);<br>      &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>sheetToBuffer</code> 将数据转为 <code>buffer</code> 流数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sheetToBuffer</span>(<span class="hljs-params">sheetData, sheetName</span>) </span>&#123;<br>  sheetName = sheetName || <span class="hljs-string">"sheet1"</span>;<br>  <span class="hljs-keyword">let</span> workbook = &#123;<br>    <span class="hljs-attr">SheetNames</span>: [sheetName],<br>    <span class="hljs-attr">Sheets</span>: &#123;&#125;,<br>  &#125;;<br>  workbook.Sheets[sheetName] = sheetData;<br><br>  <span class="hljs-comment">// excel的配置项</span><br>  <span class="hljs-keyword">let</span> wopts = &#123;<br>    <span class="hljs-attr">bookType</span>: <span class="hljs-string">"xlsx"</span>,<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">"buffer"</span>,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> XLSX.write(workbook, wopts);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>flatten</code> 打平数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> [...pre, ...(<span class="hljs-built_in">Array</span>.isArray(cur) ? <span class="hljs-keyword">this</span>.flatten(cur) : [cur])], [])<br>&#125;<br></code></pre></td></tr></table></figure><p>因为要使用 <code>Promise.all</code> 所以需要一个 <code>map</code> 方法将所有的请求都转为其可以接受的参数形式，如下 <code>mapRequestList</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapRequestList</span>(<span class="hljs-params">serviceUrl, params</span>) </span>&#123;<br>  <span class="hljs-comment">// 每页请求数量</span><br>  <span class="hljs-keyword">const</span> pageSize = <span class="hljs-number">500</span>;<br>  <span class="hljs-comment">// 总分页量，也就是一共发起的请求数</span><br>  <span class="hljs-keyword">const</span> pageNumber = <span class="hljs-number">20</span>;<br>  <span class="hljs-comment">// 用于存储promise的数组</span><br>  <span class="hljs-keyword">let</span> requestArr = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; pageNumber; i++) &#123;<br>    requestArr[i] = i + <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> att = requestArr.map(<span class="hljs-function">(<span class="hljs-params">pageNumber</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> opts = &#123; ...params, pageSize, pageNumber &#125;;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"发起第"</span> + pageNumber + <span class="hljs-string">"个请求"</span>);<br>    <span class="hljs-keyword">return</span> baseAxiosRequest(serviceUrl, opts);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> att;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端的功能基本上算是完成了，我们来看一下客户端怎么用。</p><h3 id="web-请求"><a href="#web-请求" class="headerlink" title="web 请求"></a><code>web</code> 请求</h3><p>这里因为我们用的 <code>umi-request，axios</code> 稍微有一点不一样，下文会有说明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">"umi-request"</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">"axios"</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleExcelExport</span>(<span class="hljs-params">data, fileName</span>) </span>&#123;<br>  <span class="hljs-comment">// 这里的url拼接，需要请求到node的controller</span><br>  <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/api/app/toolName/downloadExcel/downloadExcel?serviceUrl=http://yourExportListHost.com/list`</span>;<br><br>  request(url, &#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,<br>    data,<br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">300000</span>, <span class="hljs-comment">// 设置超时虽然5分钟但是后来还是超时</span><br>    responseType: <span class="hljs-string">"blob"</span>,<br>  &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([response]);<br>      <span class="hljs-keyword">const</span> elink = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"a"</span>);<br>      elink.download = <span class="hljs-string">`<span class="hljs-subst">$&#123;fileName&#125;</span>.xlsx`</span>;<br>      elink.style.display = <span class="hljs-string">"none"</span>;<br><br>      <span class="hljs-comment">// 创建blob url下载</span><br>      elink.href = URL.createObjectURL(blob);<br>      <span class="hljs-built_in">document</span>.body.appendChild(elink);<br>      elink.click();<br>      <span class="hljs-comment">// 必须释放 URL 对象</span><br>      URL.revokeObjectURL(elink.href);<br>      <span class="hljs-built_in">document</span>.body.removeChild(elink);<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"err"</span>, err);<br>    &#125;);<br><br>  <span class="hljs-comment">// axios这里的话有一点细微的区别，是在接口返回响应之后，获取数据转为blob的时候</span><br>  axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">"post"</span>,<br>    url,<br>    data,<br>    <span class="hljs-attr">responseType</span>: <span class="hljs-string">"blob"</span>,<br>  &#125;).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 区别在这里</span><br>    <span class="hljs-keyword">const</span> &#123; data &#125; = response;<br>    <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([data]);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我导出的时候发现几个问题：</p><ul><li>第一：接口响应时间<code>比较慢</code>。单次查询可能会到 <code>4-7s</code>，这是因为接口本身问题，数据体量太大，查询耗时长。</li><li>第二：数据在 <code>node</code> 层将 <code>json</code> 转为流的时候可能会比较耗算力和内存，我们现在所有的前端都用同一个 <code>node</code> 服务，一旦这里单线程耗时比较久的话，可能会因为一系列问题影响到后续的其他工具的接口转发，影响到其他工具的稳定。</li><li>第三：超时严重，基本无法在超时之前成功导出 <code>10000</code> 条数据。</li></ul><p>后来在权衡利弊之后，因为数据只是用来看，不会计算以及别的操作，采用在客户端也就是浏览器中导出 <code>csv</code> 格式的数据，利用 <code>excel</code> 打开是可以满足的，所以就产生了第二中方案。</p><h2 id="方案二：纯前端方案，浏览器分片请求接口，将数据组装为-csv-导出"><a href="#方案二：纯前端方案，浏览器分片请求接口，将数据组装为-csv-导出" class="headerlink" title="方案二：纯前端方案，浏览器分片请求接口，将数据组装为 csv 导出"></a>方案二：纯前端方案，浏览器分片请求接口，将数据组装为 <code>csv</code> 导出</h2><p>这里我们还是采用方案一中的假数据作为演示</p><ul><li><code>exportJsonToCSV</code> 文件，主体导出方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在接口响应完成之后，将第i个索引存进去，计算导出进度</span><br><span class="hljs-keyword">let</span> percentArr = [];<br><span class="hljs-keyword">const</span> pageSize = <span class="hljs-number">250</span>;<br><span class="hljs-keyword">const</span> maxReqCount = <span class="hljs-number">40</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> exportCsv = <span class="hljs-function">(<span class="hljs-params">total, queryParams, filename, callback</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!total) <span class="hljs-keyword">throw</span> <span class="hljs-string">"无数据"</span>;<br><br>    <span class="hljs-keyword">const</span> maxLen = <span class="hljs-built_in">Math</span>.ceil(total / pageSize);<br><br>    <span class="hljs-comment">// 做最大分片处理</span><br>    <span class="hljs-comment">// 正常情况下的 分片请求都是可预知的，如果 你的promise.all 接受的数组</span><br>    <span class="hljs-comment">// 是你无法预料的长度，一定是需要limit最大并发量的，不然可能会造成调用栈溢出</span><br>    <span class="hljs-comment">// 限制最大并发请求数 可以利用p-limit等三方库</span><br>    <span class="hljs-keyword">const</span> pageNumber = maxLen &gt;= maxReqCount ? maxReqCount : maxLen;<br><br>    <span class="hljs-comment">// 存储 CSV 数据</span><br>    <span class="hljs-comment">// 注意 csv的存储是以英文,分割的，所以集合类的数据不要用英文逗号分割</span><br>    <span class="hljs-comment">// 每一个,之前的数据在excel里打开就是一个单元格</span><br>    <span class="hljs-comment">// 所以一旦识别出来英文逗号，就会在excel里打开多一个表格，所以最好转为、</span><br>    <span class="hljs-keyword">let</span> cvsArray = [];<br><br>    <span class="hljs-keyword">const</span> task = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (resolve, reject) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建指定个数的接口数据</span><br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all(<br>          requestMapList(queryParams, pageNumber, callback)<br>        );<br><br>        <span class="hljs-comment">// data是一个[[],[],[]]格式的数据，拍平一下处理</span><br>        <span class="hljs-comment">// 格式化为 CSV 字符串</span><br>        <span class="hljs-comment">// csv接受的格式是 [0:'a,b,c', 1: 'a1,b1,c1', 2: 'a2,b2,c2']</span><br>        data?.flat(<span class="hljs-number">2</span>)?.forEach(<span class="hljs-function">(<span class="hljs-params">row, index</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> newRow = [element.title, element.birthday, element.age];<br><br>          <span class="hljs-comment">// 将上一步数据存起来</span><br>          cvsArray[index] = newRow.join() + <span class="hljs-string">"\n"</span>;<br>        &#125;);<br><br>        <span class="hljs-comment">// 创建表头 这里选择在最后再加表头是为了避免 percentArr 存数据的时候干扰</span><br>        cvsArray.unshift(EXCEL_TITLE.join() + <span class="hljs-string">"\n"</span>);<br><br>        <span class="hljs-comment">// 适当暂停，避免页面无法执行渲染</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_resolve</span>) =&gt;</span> &#123;<br>          setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> _resolve(<span class="hljs-literal">true</span>), <span class="hljs-number">50</span>);<br>        &#125;);<br><br>        resolve(<span class="hljs-literal">true</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        reject(<span class="hljs-literal">false</span>);<br>      &#125;<br>    &#125;);<br><br>    task<br>      .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (res) &#123;<br>          <span class="hljs-comment">// 创建blob</span><br>          <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> Blob([<span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xfeff</span>), ...cvsArray], &#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">"text/plain;charset=utf-8"</span>,<br>          &#125;);<br><br>          createATagTodownload(blob, filename);<br>          <span class="hljs-comment">// 完成后将进度数据初始化</span><br>          percentArr = [];<br>          resolve(<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          reject(<span class="hljs-literal">false</span>);<br>        &#125;<br>      &#125;)<br>      .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        reject(<span class="hljs-literal">false</span>);<br>      &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>baseRequestData</code> 基础单元请求接口的方法：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseRequestData</span>(<span class="hljs-params">params, index, pageNumber, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> request(SERVICEURL, &#123; params &#125;)<br>      .then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 根据接口响应格式来处理</span><br>        <span class="hljs-keyword">const</span> &#123; desc, errorno, data &#125; = result;<br>        <span class="hljs-keyword">if</span> (errorno === <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-comment">// 请求完成一次存储一个</span><br>          percentArr[index] = index;<br>          <span class="hljs-keyword">const</span> percentLen = percentArr.length - <span class="hljs-number">1</span>;<br><br>          <span class="hljs-comment">// 计算导出进度</span><br>          <span class="hljs-keyword">const</span> percent = <span class="hljs-built_in">Math</span>.ceil((percentLen / pageNumber) * <span class="hljs-number">100</span>);<br>          <span class="hljs-comment">// console.log('进度', percent, percentArr);</span><br><br>          <span class="hljs-comment">// 将计算的数据返回到页面</span><br>          callback &amp;&amp; callback(percent);<br>          <span class="hljs-keyword">return</span> resolve(data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> reject(desc);<br>        &#125;<br>      &#125;)<br>      .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> reject(err);<br>      &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>requestMapList</code> 组装请求为 <code>Promise</code> 数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestMapList</span>(<span class="hljs-params">params, pageNumber, callback</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> requestMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(pageNumber)<br>    .fill(<span class="hljs-string">""</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">item, idx</span>) =&gt;</span> idx + <span class="hljs-number">1</span>)<br>    .map(<span class="hljs-function">(<span class="hljs-params">pn, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> opts = &#123; ...params, pageSize, <span class="hljs-attr">pageNumber</span>: pn &#125;;<br>      <span class="hljs-comment">// console.log('发起第' + pn + '个请求');</span><br>      <span class="hljs-keyword">return</span> baseRequestData(opts, index + <span class="hljs-number">1</span>, pageNumber, callback);<br>    &#125;);<br>  <span class="hljs-keyword">return</span> requestMap;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>createATagTodownload</code> 创建 <code>a</code> 标签利用 <code>blob</code> 来导出</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createATagTodownload</span>(<span class="hljs-params">blob, filename</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> elink = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"a"</span>);<br>    elink.download = <span class="hljs-string">`<span class="hljs-subst">$&#123;filename || <span class="hljs-string">"文件导出"</span>&#125;</span>.csv`</span>;<br>    elink.style.display = <span class="hljs-string">"none"</span>;<br>    elink.href = URL.createObjectURL(blob);<br>    <span class="hljs-built_in">document</span>.body.appendChild(elink);<br>    elink.click();<br>    URL.revokeObjectURL(elink.href); <span class="hljs-comment">// 必须释放 URL 对象</span><br>    <span class="hljs-built_in">document</span>.body.removeChild(elink);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>页面使用，展示实时进度</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> [loadingPercent, setLoadingPercent] = useState(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> [loadingMask, setLoadingMask] = useState(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">const</span> handleExportFile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 导出按钮使用</span><br>  setLoadingMask(<span class="hljs-literal">true</span>);<br>  exportCsv(pagination?.total, queryParams, filename, (percent) =&gt; &#123;<br>    setLoadingPercent(percent);<br>  &#125;)<br>    .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (res) &#123;<br>        setLoadingMask(<span class="hljs-literal">false</span>);<br>        setLoadingPercent(<span class="hljs-number">0</span>);<br>      &#125;<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"err"</span>, err);<br>    &#125;);<br>&#125;;<br><br>&lt;Modal<br>  title="数据导出(默认1w条)进度"<br>  visible=&#123;loadingMask&#125;<br>  width=&#123;500&#125;<br>  maskClosable=&#123;false&#125;<br>  keyboard=&#123;false&#125;<br>  destroyOnClose=&#123;true&#125;<br>  footer=&#123;null&#125;<br>  closable=&#123;false&#125;<br>&gt;<br>  &lt;div style=&#123;&#123; display: "flex", justifyContent: "center" &#125;&#125;&gt;<br>    &lt;Progress type="circle" percent=&#123;loadingPercent&#125; /&gt;<br>  &lt;/div&gt;<br>&lt;/Modal&gt;;<br></code></pre></td></tr></table></figure><p>导出 <code>csv</code> 的格式不会出现超时的问题，<code>10000</code> 条数基本会在 <code>40s</code> 左右，这其中有一大部分原因是因为接口响应慢，再就是因为同一域名，在浏览器发起请求的时候 <code>chrome</code> 会限制 <code>6</code> 条，所以方案中采用的导出采用请求 <code>40</code> 次，后续的请求肯定是会被挂起等待新的可用连接，比较耗时，具体的就是浏览器 <code>network</code> 中的 <code>Timing</code> 的 <code>Connection Start</code> 的 <code>Stalled</code> 时间越往后越长。</p><p>所以方案二的话目前是比较可行的一种解决问题的套路。</p><p>对于 <code>Stalled</code>时间问题，请求静态资源，可以通过域名分片来拆做到多请求，但是对于接口方面的这种情况目前还不知道怎么解决。</p><p>一些关于 <code>stalled</code> 时间过长的文章</p><ul><li><a href="https://blog.csdn.net/tianhouquan/article/details/78803601" target="_blank" rel="noopener">关于请求被挂起页面加载缓慢问题的追查（stalled 时间过长）</a></li><li><a href="https://blog.csdn.net/WGH100817/article/details/101723517?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.baidujs" target="_blank" rel="noopener">关于心跳 ajax 请求 pending 状态（被挂起），stalled 时间过长的问题</a></li><li><a href="https://kb.cnblogs.com/page/513237/" target="_blank" rel="noopener">关于请求被挂起页面加载缓慢问题的追查</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>文件导出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise 中的 resolve 和 return 的疑惑</title>
    <link href="/2021/06/13/promise-resolve-return/"/>
    <url>/2021/06/13/promise-resolve-return/</url>
    
    <content type="html"><![CDATA[<p>最近遇到一个问题，具体的场景是，接口 <code>A</code> 返回一段可以让前端渲染的 <code>html</code> 字符串，这个字符串里包含里一个可播放的 <code>video</code> 的地址，但是地址是不可播放的，需要替换为另外一个可播放的域名。</p><p>解决方式：先请求接口 <code>A</code> 获取 <code>html</code> 字符串，从中截取 <code>video</code> 的 <code>src</code> 属性，再调接口 <code>B</code> 将接口转换为可播放的 <code>url</code>，最后拿到新的 <code>url</code> 之后再通过正则的 <code>replace</code> 方法将对应的 <code>url</code> 替换成新的 <code>url</code>，然后再处理剩下的逻辑。</p><p>其实捋下来之后发现无非就是 <code>A</code> 的回调结果里调 <code>B</code> 接口，但是即便是嵌套一层，也不够优雅，于是在想利用 <code>Promise</code> 的串行处理，将回调打平，<code>Promise</code> 的处理无非也就是先去调用 <code>A</code> 接口，获取数据之后将结果传递出去再通过<code>.then</code> 拿到返回值数据，在<code>.then</code> 里再调新接口 <code>B</code> 从而解决问题。虽然后来确实通过 <code>Promise</code> 的链式调用解决了问题，但是这个过程中也有一些疑惑，就是如题。</p><p>根据 <code>es6</code> 的 <code>resolve</code> 的理解，其函数的作用是，将 <code>Promise</code> 对象的状态从“未完成”变为“成功”（即从 <code>pending</code> 变为 <code>resolved</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去，如果我们不 <code>resolve</code>，则数据一直被保存在上一个 <code>Promise</code> 的函数中。经过整理重新学习后发现，如果需要将 <code>Promise</code> 的返回的结果在当前函数的<code>.then</code> 里一直按照次序往下传递，其是必须要在上一步的 <code>then</code> 里将结果 <code>return</code> 才能在下一个 <code>then</code> 里接住，一旦在某一个 <code>then</code> 里 <code>resolve</code> 了，则在 <code>resolve</code> 的那个 <code>then</code> 后面的 <code>then</code> 中虽然后面的逻辑会执行，但是获取不到上一次计算的结果，反而是直接在 <code>resolve</code> 的 <code>then</code> 里将结果从当前函数传递出去了。</p><p>具体用一个 🌰 来看：<br>假设现在我们有一个 <code>sleep</code> 的 <code>Promise</code> 的模拟异步方法，传递不同的 <code>ms</code> 数代表分别代表 <code>A、B</code> 俩接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> sleep = <span class="hljs-function">(<span class="hljs-params">ms</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(resolve, ms));<br><br><span class="hljs-comment">// 这是获取新url的接口B</span><br><span class="hljs-keyword">var</span> urlConvert = <span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`我们现在获取到了旧的url:<span class="hljs-subst">$&#123;url&#125;</span> 要去请求新的`</span>);<br>    sleep(<span class="hljs-number">500</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        resolve(<span class="hljs-string">"http//newVideoUrl.com"</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        reject(<span class="hljs-string">"发生错误"</span>);<br>      &#125;<br>    &#125;);<br>  &#125;);<br><br><span class="hljs-keyword">var</span> handleData = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 接口A</span><br>    <span class="hljs-keyword">var</span> initUrl = sleep(<span class="hljs-number">1000</span>).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-string">"http://oldVideoUrl.com"</span>);<br><br>    initUrl.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> urlConvert(res)).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> resolve(res));<br>  &#125;);<br><br>handleData().then(<span class="hljs-function">(<span class="hljs-params">url</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"url"</span>, url);<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里我们能发现在 <code>handleData</code> 内部，我是需要先处理完数据，在最后才将处理完的数据 <code>resolve</code>，所以可以看到是前边通过箭头函数一步一步将上一次处理的结果 <code>return</code> 了，所以在下一个 <code>then</code> 里才获取到处理完成的数据，并且我们在最后一步通过 <code>resolve</code> 将结果返回，当我们在外部调用 <code>handleData</code> 之后，链式调用的结果是可以获取到 <code>url</code> 的值。</p><p>但是如果我们将最后一步结果依旧改成 <code>return</code> 的形式，我们再来看一下效果。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- initUrl.then((res) =&gt; urlConvert(res)).then((res) =&gt; resolve(res));</span><br><span class="hljs-addition">+ initUrl.then((res) =&gt; urlConvert(res)).then((res) =&gt; res);</span><br><br>handleData().then((url) =&gt; &#123;<br>  console.log("url", url);<br>&#125;);<br></code></pre></td></tr></table></figure><p>再次运行后，发现没有打印也就是没走到这里，说明如果直接 <code>return</code> 的话是无法从原来的函数里将 <code>Promise</code> 的结果传递出去的，所以到这里基本上是更清楚了，如果不需要将结果传递出去，在 <code>then</code> 处理完成之后 <code>return value</code> 就好了，如果需要传递出去就将数据 <code>resolve(value)</code> 出去，至于 <code>resolve</code> 的时候要不要 加 <code>return</code> 就看还要不要处理 <code>resolve</code> 后面的逻辑，一般来说立即 <code>resolved</code> 的 <code>Promise</code> 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。所以如果上述例子改为</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- initUrl.then((res) =&gt; urlConvert(res)).then((res) =&gt; resolve(res));</span><br><span class="hljs-addition">+ initUrl.then((res) =&gt; urlConvert(res)).then((res) =&gt; &#123;</span><br><span class="hljs-addition">+  resolve(res)</span><br><span class="hljs-addition">+  console.log('resolve后，打印url前')</span><br><span class="hljs-addition">+&#125;);</span><br></code></pre></td></tr></table></figure><p>便会在 <code>resolve</code> 的那次事件循环后，并且会在新的一轮 <code>handleData()</code> 前执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 Promise.all 和 Promise.race 的实现</title>
    <link href="/2021/05/26/my-promiseAll-and-promiseRace/"/>
    <url>/2021/05/26/my-promiseAll-and-promiseRace/</url>
    
    <content type="html"><![CDATA[<h2 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a><code>Promise.all</code></h2><p>首先我们从一个正常的例子来看拆解一下 <code>Promise.all</code></p><h3 id="拆解Promise-all"><a href="#拆解Promise-all" class="headerlink" title="拆解Promise.all"></a>拆解<code>Promise.all</code></h3><ul><li>我们能知道 <code>all</code> 方法接受一个数组作为参数，具体来说应该是具有 <code>Iterator</code> 接口的数据。</li><li>根据 <code>Promise.all</code> 的特性还能知道，<code>Promise.all()</code> 方法用于将多个 <code>Promise</code> 实例，<code>包装</code>成一个新的 <code>Promise</code> 实例。言外之意，如果不是 Promise 就会先调用 <code>Promise.resolve</code> 方法，将参数转为 <code>Promise</code> 实例，再进一步处理。</li><li>如果参数实例的状态<code>全部</code>变成 <code>fulfilled</code>，结果的状态才会变成 <code>fulfilled</code>，此时各个参数的返回值组成一个数组，传递给结果的 <code>then</code> 的回调函数。</li><li>参数实例中有一个被 <code>rejected</code>，结果的状态就变成 <code>rejected</code>，此时第一个被 <code>reject</code> 的实例的返回值，结果会传递给 <code>catch</code> 的回调函数。</li></ul><p>我们根据上述的拆解，来进行一下代码的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseAll</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  <span class="hljs-comment">// 首先我们做个边界处理，这里暂时只 判断参数是不是数组</span><br>  <span class="hljs-comment">// 规范的promise参数应该是具有Iterator接口的，所以我们这里只处理是数组和不是数组的情况</span><br>  <span class="hljs-comment">// 是数组我们执行方法，不是数组则通过Promise.resolve()将原来的数据直接resolve出去</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) &#123;<br>    <span class="hljs-comment">// 我们都知道，all方法会在所有的实例都变成fulfilled的时候，才回去fulfilled，所以可想应该是有一个计数器</span><br>    <span class="hljs-comment">// 在所有的实例执行完之后，判断完成的量等不等于传入的数组的长度，才将结果抛出，并且这个结果我们应该需要有一个数组去存储</span><br>    <span class="hljs-comment">// 首先我们要知道，结果集和错误都是需要用resolve和reject从函数里抛出的，所以我们必须要用promise包一下</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">let</span> len = arg.length;<br>      <span class="hljs-keyword">let</span> result = [];<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">// 在循环里执行每一个promise实例，但是虽然我们传入的arg是数组，但是数组的项不一定是一个promise的实例</span><br>        <span class="hljs-comment">// 所以这里我们应该用Promise.resolve来将arg[i]包装一下</span><br><br>        <span class="hljs-built_in">Promise</span>.resolve(arg[i])<br>          .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 我们应该在成功的回调函数里去处理一些事务，例如计数器增加、成功的返回值堆入结果集</span><br>            <span class="hljs-comment">// 并且这里我们应该处理，当计数器等于实例参数的length的时候，将结果resolve出去</span><br>            <span class="hljs-comment">// 也就是说执行完了所有的传入的实例</span><br><br>            count++;<br>            <span class="hljs-comment">// 为了保证每一个次序没有问题，需要按照索引将每个实例的结果存在结果集中</span><br><br>            result[i] = res;<br><br>            <span class="hljs-comment">// 所有实例完成将结果集抛出</span><br>            <span class="hljs-keyword">if</span> (count === len) &#123;<br>              <span class="hljs-keyword">return</span> resolve(result);<br>            &#125;<br>          &#125;)<br>          .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> reject(err);<br>          &#125;);<br>      &#125;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 这里处理当传入的参数不是数组类型的时候用promise包装一下返回，不throw err</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(arg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用测试用例验证一下这个方法能不能用，首先模拟一个延迟函数，<code>delay</code>，然后再定义两个方法 <code>delay1，delay2</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    setTimeout(resolve, ms);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> delay1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(<span class="hljs-number">2000</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">"delay1"</span>);<br><span class="hljs-keyword">const</span> delay2 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(<span class="hljs-number">1000</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">"delay2"</span>);<br></code></pre></td></tr></table></figure><p>调用，按照预期的话应该是打印出来两个数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">promiseAll([delay1(), delay2()]).then(<span class="hljs-function">(<span class="hljs-params">[dd1, dd2]</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"dd1 dd2"</span>, dd1, dd2); <span class="hljs-comment">// delay1 delay2</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>最后我们能发现确实已经可以返回两个延迟函数中的数据。</p><h2 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a><code>Promise.race</code></h2><p>还是根据其特性来实现，首先 <code>race</code> 的方法和 <code>all</code> 的基础性都是一样的，接受的参数以及类别等，其用法是多个实例中有一个实例率先改变状态，总结果的状态就跟着改变。那个率先改变的 <code>Promise</code> 实例的返回值，就传递给结果集的回调函数。</p><h3 id="拆解Promise-race"><a href="#拆解Promise-race" class="headerlink" title="拆解Promise.race"></a>拆解<code>Promise.race</code></h3><ul><li>首先基本和 <code>all</code> 的类似，然后由其特性可知，其实内部实现应该是谁先完成就谁返回，也就是循环体内部只要有一个成功执行完毕就可以 <code>resolve</code>。</li></ul><p>我们来看一下具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">promiseRace</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>  <span class="hljs-comment">// 依旧是边界判断</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(arg)) &#123;<br>    <span class="hljs-keyword">let</span> len = arg.length;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-built_in">Promise</span>.resolve(arg[i])<br>          .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 执行成功有结果直接返回</span><br><br>            <span class="hljs-keyword">return</span> resolve(res);<br>          &#125;)<br>          .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> reject(err);<br>          &#125;);<br>      &#125;<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(arg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>race</code> 最常见的一个场景就是，如果页面里有需要请求的接口，但是接口耗时如果比较长，这个时候可以利用 <code>race</code> 配合 <code>delay</code> 函数做一个兜底，发请求的同时开一个多少 <code>ms</code> 的定时器，如果定时器结束之前接口还没有响应的话则中断请求立即返回，而不至于接口一直处于 <code>pedding</code> 挂起状态。那我们可以根据这个例子验证一下 <code>race</code> 是否可以用。</p><p>我们这次修改一下两个延迟函数，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> delay1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(<span class="hljs-number">5000</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">"我请求需要5s时间太久了"</span>);<br><span class="hljs-keyword">const</span> delay2 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(<span class="hljs-number">2000</span>).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-string">"如果接口响应大于2s我就不等了哈"</span>);<br></code></pre></td></tr></table></figure><p>按照预期的话，<code>data</code> 的打印应该是延迟比较小的那个，因为先执行完成先返回了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">promiseRace([delay1(), delay2()]).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"data"</span>, res); <span class="hljs-comment">// data 如果接口响应大于2s我就不等了哈</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>由此可见我们的 <code>race</code> 通过用例验证也是可行的。</p><p>至此两个比较常用的 <code>promise</code> 的方法我们就实现了，其实很多东西从使用的角度上来看，内部实现原理大概都是能比较清楚的，所以我们就应该注意更多的细节，例如边界条件、类型包装、代码执行的位置等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读正则迷你书总结 📓</title>
    <link href="/2021/05/15/mini-regExp/"/>
    <url>/2021/05/15/mini-regExp/</url>
    
    <content type="html"><![CDATA[<p>前端很多场景其实都会涉及到正则表达式的使用，奈何之前个人正则的知识都是零散的，读完正则表达式迷你书之后受益良多，一来总结一下知识点，二来回顾的时候可以更方便。</p><p>根据目录精简整理</p><h1 id="匹配攻略"><a href="#匹配攻略" class="headerlink" title="匹配攻略"></a>匹配攻略</h1><h2 id="字符组"><a href="#字符组" class="headerlink" title="字符组"></a>字符组</h2><p>匹配只是其中的一个字符，范围表示利用 <code>-</code> 省略和简写。</p><h3 id="排除字符组"><a href="#排除字符组" class="headerlink" title="排除字符组"></a>排除字符组</h3><p>利用 <code>^</code>，字符组<code>第一个放置 ^ 表示求反</code>。</p><h3 id="常见的简写"><a href="#常见的简写" class="headerlink" title="常见的简写"></a>常见的简写</h3><table><thead><tr><th>字符组</th><th>含义</th></tr></thead><tbody><tr><td><code>\d</code></td><td>数字 <code>[0-9]</code>，表示一位数字。</td></tr><tr><td><code>\D</code></td><td>表示 <code>[^0-9]</code>，表示除了数字之外的任意字符。</td></tr><tr><td><code>\w</code></td><td>表示 <code>[0-9a-zA-Z]</code>。</td></tr><tr><td><code>\W</code></td><td><code>[^0-9a-zA-Z]</code>，非单词字符。</td></tr><tr><td><code>\s</code></td><td><code>[\t\v\n\r\f]</code>，表示空白字符，包括空格、水平、垂直制表符、换行、回车、换页符。</td></tr><tr><td><code>\S</code></td><td><code>[^\t\v\n\r\f]</code>，非空白符。</td></tr><tr><td><code>.</code></td><td><code>[^\n\r\u2028\u2029]</code>，通配符。表示几乎任意字符。</td></tr></tbody></table><p>匹配<code>任意字符</code>，<code>[\d\D]、[\w\W]、[\s\S]、[^]</code></p><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><table><thead><tr><th>量词</th><th>含义</th></tr></thead><tbody><tr><td><code>{m,}</code></td><td>至少出现 <code>m</code> 次。</td></tr><tr><td><code>{m}</code></td><td>出现 <code>m</code> 次。</td></tr><tr><td><code>?</code></td><td>等价于 <code>{0,1}</code>，出现或者不出现。</td></tr><tr><td><code>+</code></td><td>等价 <code>{1,}</code>，出现<code>至少一次</code>。</td></tr><tr><td><code>*</code></td><td>等价 <code>{0,}</code>，出现<code>任意次</code>，有可能不出现。</td></tr></tbody></table><h3 id="贪婪与惰性"><a href="#贪婪与惰性" class="headerlink" title="贪婪与惰性"></a>贪婪与惰性</h3><ul><li><p><code>贪婪</code>会尽可能<code>多的匹配</code>。</p></li><li><p><code>惰性</code>会尽可能<code>少的匹配</code>。<br>具体惰性实现：量词后边<code>加问号</code>就能实现惰性匹配。</p><table><thead><tr><th>惰性量词</th><th>贪婪量词</th></tr></thead><tbody><tr><td><code>{m,n}?</code></td><td><code>{m,n}</code></td></tr><tr><td><code>{m,}?</code></td><td><code>{m,}</code></td></tr><tr><td><code>??</code></td><td><code>?</code></td></tr><tr><td><code>+?</code></td><td><code>+</code></td></tr><tr><td><code>*?</code></td><td><code>*</code></td></tr></tbody></table></li></ul><h3 id="多选分支"><a href="#多选分支" class="headerlink" title="多选分支"></a>多选分支</h3><p>管道符号代表分割 <code>|</code>，默认惰性匹配，前边的匹配成功后面不会尝试匹配。例如匹配 <code>good</code> 和 <code>nice</code>，使用 <code>/good|nice/g</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> reg = <span class="hljs-regexp">/good|nice/g</span><br><span class="hljs-keyword">const</span> string = <span class="hljs-string">'good idea, nice day!'</span><br><span class="hljs-built_in">console</span>.log(string.match(reg)) <span class="hljs-comment">// ['good', 'nice']</span><br></code></pre></td></tr></table></figure><h1 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配<code>位置</code></h1><ul><li><code>^</code>，匹配<code>开头</code>，在多行匹配中匹配行开头。</li><li><code>$</code>，匹配<code>结尾</code>，在多行匹配中匹配行结尾。</li><li><code>\b</code>，<code>单词边界</code>，具体是 <code>\w</code> 和 <code>\W</code> 之间的位置，也包括 <code>\w</code> 和<code>^</code> 之间的位置和 <code>\w</code> 和 <code>$</code> 之间的位置，看个例子：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">'[JS] Lesson_01.mp4'</span>.replace(<span class="hljs-regexp">/\b/g</span>, <span class="hljs-string">'#'</span>)<br><span class="hljs-comment">// '[#JS#] #Lesson_01#.#mp4#'</span><br></code></pre></td></tr></table></figure><ul><li><code>\B</code>，这个比较好理解，就是 <code>\b 的取反</code>，知道了 <code>\b</code> ，所以</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">'[JS] Lesson_01.mp4'</span>.replace(<span class="hljs-regexp">/\B/g</span>, <span class="hljs-string">'#'</span>)<br><span class="hljs-comment">// "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"</span><br></code></pre></td></tr></table></figure><ul><li><code>(?=p)</code>，其中 <code>p</code> 是一个子模式，即 <code>p 前面的位置</code>，是位置，也就是在 <code>p</code> 前面做手脚，不是前面的字符，其中 <code>p</code> 可以是想匹配的任意字符。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">'hello'</span>.replace(<span class="hljs-regexp">/(?=l)/g</span>, <span class="hljs-string">'#'</span>)<br><span class="hljs-comment">// "he#l#lo"</span><br></code></pre></td></tr></table></figure><ul><li><code>(?!p)</code>，是 <code>(?=p)</code> 的反模式。记一个特殊的，不是开头，<code>/(?!^)/</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">'hello'</span>.replace(<span class="hljs-regexp">/(?!l)/g</span>, <span class="hljs-string">'#'</span>)<br><span class="hljs-comment">// "#h#ell#o#"</span><br></code></pre></td></tr></table></figure><ul><li>必须包含<code>数字</code>，<code>/(?=.*[0-9])/</code>。</li><li>必须包含<code>数字和小写字母</code>，<code>/(?=.*[0-9])(?=.*[a-z])/</code>，这样是不会挑位置的，数字和字母的顺序随意都可以匹配。</li><li>必须包含<code>小写字母和大写字母</code>，<code>/(?=.*[a-z])(?=.*[A-Z])/</code>，同理。</li><li>必须包含<code>数字、大、小写字母</code>，<code>/(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])/</code>，同理。</li></ul><h1 id="括号的作用"><a href="#括号的作用" class="headerlink" title="括号的作用"></a>括号的作用</h1><p>括号的主要作用就是提供了<code>分组</code>，便于引用。引用分组会有在 <code>js</code> 里引用，在正则表达式里引用。括号里的正则强调其是一个整体。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><ul><li><p>分组：如果要匹配连续出现的单个字符用 <code>/x+/</code> 即可，但是如果需要匹配连续出现的 <code>&#39;abc&#39;</code>，则需要 <code>/(abc)+/</code>，将量词 <code>+</code> 作用于括号这个整体的表达式上。</p></li><li><p>分组引用：有了括号，可以对数据进行提取以及更强大的替换操作，因为分组可以捕获数据，利用构造函数的全局属性 <code>$1~$9</code> 提取。</p></li><li><p>如果想要忽略多个分组中的某一个，可以使用?:，假设 (\w+.(com|cn))，不需要第二个com|cn的分组的话，可以修改为(\w.(?:com|cn))</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 例如替换日期顺序</span><br><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="hljs-keyword">var</span> timeString = <span class="hljs-string">'2020-05-15'</span><br>timeString.replace(regExp, <span class="hljs-string">'$2/$3/$1'</span>)<br><span class="hljs-comment">// "05/15/2020"</span><br><br><span class="hljs-comment">// 替换h标题为p</span><br><span class="hljs-keyword">const</span> text = <span class="hljs-string">'&lt;h1&gt;hello~&lt;/h1&gt;'</span>;<br>text.replace(<span class="hljs-regexp">/&lt;(h[1-6])&gt;([\s\S]+)&lt;\/\1&gt;/ig</span>, <span class="hljs-string">'&lt;p&gt;$2&lt;/p&gt;'</span>)<br><span class="hljs-comment">// 这里第一个分组是(h[1-6])，也就是说对称的匹配和用分组和\1来搞定，对于闭合html标签来说的话。</span><br></code></pre></td></tr></table></figure><h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>假如要求匹配的<code>前后一致</code>，引用之前的第 <code>n</code> 个分组，看个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 匹配日期，只是匹配三种模式，并且年份和月份之间的连接符必须一致</span><br><span class="hljs-keyword">const</span> regExp = <span class="hljs-regexp">/\d&#123;4&#125;(-|\/|\.)\d&#123;2&#125;\1\d&#123;2&#125;/</span><br>regExp.test(<span class="hljs-string">'2020-05-15'</span>) <span class="hljs-comment">// true</span><br>regExp.test(<span class="hljs-string">'2020/05-15'</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>其中 <code>\1</code> 代表的就是引用前边的那个分组 <code>(-|\/|\.)</code>，<code>\2 \3</code> 也就是分别指代第二和第三个分组。反向引用就是引用前边的分组，当引用到了不存在的分组时，只是匹配反向引用的字符本身。</p><h2 id="非捕获括号"><a href="#非捕获括号" class="headerlink" title="非捕获括号"></a>非捕获括号</h2><p>如果不使用引用，则可以利用非捕获括号 <code>(?:p)</code> 和 <code>(?:p1|p2|p3)</code>，如果不用反向引用，对于匹配 <code>&#39;abc&#39;</code> 的连字符，可以修改为 <code>/(?:abc)+/g</code></p><p>一些例子</p><ul><li>将每个单词首字母转为大写</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> titleize = <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> str.toLowerCase().replace(<span class="hljs-regexp">/(?:^|\s)\w/g</span>, c =&gt; c.toUpperCase())<br>titleize(<span class="hljs-string">'ni hao a '</span>)<br><span class="hljs-comment">// "Ni Hao A "</span><br></code></pre></td></tr></table></figure><ul><li>_-空格 转驼峰</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> camelize = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.replace(<span class="hljs-regexp">/[-_\s]+(.)?/g</span>, (match, c) =&gt; c ? c.toUpperCase() : <span class="hljs-string">''</span>)<br>camelize(<span class="hljs-string">'_get_name'</span>)<br><span class="hljs-comment">// "GetName"</span><br></code></pre></td></tr></table></figure><ul><li>驼峰转中划线</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 先将大写字母匹配到的字符前边加上-，利用了分组的特性。再将任意多个 _-空格 转为-</span><br><span class="hljs-keyword">const</span> dasherize = <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.replace(<span class="hljs-regexp">/([A-Z])/g</span>, <span class="hljs-string">'-$1'</span>).replace(<span class="hljs-regexp">/[_-\s]+/g</span>, <span class="hljs-string">'-'</span>).toLowerCase()<br>dasherize(GetName)<br><span class="hljs-comment">// "-get-name"</span><br></code></pre></td></tr></table></figure><ul><li>匹配成对标签，<code>/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;title&gt;Reg Exp&lt;/title&gt;<br>&lt;p&gt;bye bye&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>这里匹配一个开标签，使用 <code>&lt;[^&gt;]+&gt;</code> ，也就是 <code>&lt;&gt;</code> 中非 <code>&gt;</code> 的任意字符。<br>匹配闭标签，<code>&lt;\/[^&gt;]+&gt;</code>，闭标签中只比开标签多了一个 <code>/</code> 所以需要利用 <code>\</code> 转义，这其中又因为需要匹配成对的标签，所以可以用前边的知识，反向引用，需要反向引用所以肯定需要分组了，最后我们能够写出来，<code>/&lt;([^&gt;]+)&gt;[\d\D]*&lt;\/\1&gt;/</code>，<code>[\d\D]</code> 匹配任意字符。</p><h1 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h1><table><thead><tr><th align="center">操作符描述</th><th align="center">操作符</th><th align="center">优先级</th></tr></thead><tbody><tr><td align="center">转义符</td><td align="center"><code>\</code></td><td align="center">1</td></tr><tr><td align="center">括号、方括号</td><td align="center"><code>(...)、(?:...)、(?=...)、(?!...)、[...]</code></td><td align="center">2</td></tr><tr><td align="center">量词</td><td align="center"><code>{m}、{m, n}、{m, }、?、+、*</code></td><td align="center">3</td></tr><tr><td align="center">位置、序号</td><td align="center"><code>^、$、\元字符、一般字符</code></td><td align="center">4</td></tr><tr><td align="center">管道符</td><td align="center"><code>|</code></td><td align="center">5</td></tr></tbody></table><h2 id="需要转义的字符"><a href="#需要转义的字符" class="headerlink" title="需要转义的字符"></a>需要转义的字符</h2><p>需要转义的字符是正则中有特殊含义的字符，<code>^、$、.、*、+、?、!、|、\、/、(、)、[、]、{、}、=、!、:、-</code></p><h1 id="优化效率"><a href="#优化效率" class="headerlink" title="优化效率"></a>优化效率</h1><ul><li>使用具体字符组来替代通配符消除回溯。</li><li>不需要分组和反向引用时，使用非捕获分组。</li><li>独立出确定字符，<code>/a+/ =&gt; /aa*/</code>。</li><li>提取分支的公共部分，<code>/this|that/ =&gt; /th(?:is|at)/</code>。</li><li>减少分支数量，缩小范围，<code>/red|read/ =&gt; /rea?d/</code>。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>JavaScript正则表达式迷你书（老姚）</p>]]></content>
    
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现电话簿或者昵称分类功能 ☎️</title>
    <link href="/2021/05/14/sort-by-ASCII/"/>
    <url>/2021/05/14/sort-by-ASCII/</url>
    
    <content type="html"><![CDATA[<p>最近有一个挺有意思的小需求，有一组词的分类需要按照拼音归类且排序，基本类似于电话薄按照英文字母排序的功能。</p><p>假如后端给出的数据是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"感动"</span>,<br>    <span class="hljs-attr">"pinyin"</span>: <span class="hljs-string">"gan dong"</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"爱国"</span>,<br>    <span class="hljs-attr">"pinyin"</span>: <span class="hljs-string">"ai guo"</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"感动中国"</span>,<br>    <span class="hljs-attr">"pinyin"</span>: <span class="hljs-string">"gan dong zhong guo"</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">"tag"</span>: <span class="hljs-string">"富强"</span>,<br>    <span class="hljs-attr">"pinyin"</span>: <span class="hljs-string">"fu qiang"</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>最终需要将数据转为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"a"</span>,<br>    <span class="hljs-attr">"data"</span>: [<span class="hljs-string">"爱国"</span>]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"f"</span>,<br>    <span class="hljs-attr">"data"</span>: [<span class="hljs-string">"富强"</span>]<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">"letter"</span>: <span class="hljs-string">"g"</span>,<br>    <span class="hljs-attr">"data"</span>: [<span class="hljs-string">"感动"</span>, <span class="hljs-string">"感动中国"</span>]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><p>实现思路，可以借助 <code>Map</code> 的属性，先查看当前的数据是否已经被推入 <code>data</code> 中，如果已经被推入则需要更新，否则直接 <code>push</code> 到 <code>data</code> 中，并且跟新 <code>Map</code> 的状态。</p><p>代码实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> tagsTypes = <span class="hljs-string">'tag'</span> | <span class="hljs-string">'pinyin'</span><br><br><span class="hljs-keyword">interface</span> IResult &#123;<br>  letter: <span class="hljs-built_in">string</span>;<br>  data: <span class="hljs-built_in">string</span>[];<br>&#125;<br><br><span class="hljs-keyword">const</span> pySegSort = <span class="hljs-function">(<span class="hljs-params">arr: Record&lt;tagsTypes, <span class="hljs-built_in">string</span>&gt;[]</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> wordsMap: Map&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">boolean</span>&gt; = <span class="hljs-keyword">new</span> Map();<br>  <span class="hljs-keyword">let</span> moreWords: IResult[] = [];<br>  arr.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 取首字母</span><br>    <span class="hljs-keyword">const</span> initials = item.pinyin.charAt(<span class="hljs-number">0</span>).toLowerCase();<br>    <span class="hljs-comment">// 若Map中不存在，直接push，并且更新状态</span><br>    <span class="hljs-keyword">if</span> (!wordsMap.has(initials)) &#123;<br>      moreWords.push(&#123;<br>        letter: initials,<br>        data: [item.tag],<br>      &#125;);<br>      wordsMap.set(initials, <span class="hljs-literal">true</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则就寻找去拼接</span><br>      moreWords.forEach(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (e.letter === initials) &#123;<br>          e.data = [...new Set([...e.data, item.tag])];<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-comment">// 最终取数据的首字母的ASCII码排序</span><br>  <span class="hljs-keyword">return</span> moreWords.sort(<br>    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.letter.charCodeAt(<span class="hljs-number">0</span>) - b.letter.charCodeAt(<span class="hljs-number">0</span>)<br>  );<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部分 web 性能优化清单 🧾</title>
    <link href="/2021/04/26/web-performance/"/>
    <url>/2021/04/26/web-performance/</url>
    
    <content type="html"><![CDATA[<p>作为一名研发，到了一定程度之后对性能的优化是不可避免的，现总结一下在日常研发中，思考以及有过实践的一些性能优化点。</p><h2 id="减少请求数"><a href="#减少请求数" class="headerlink" title="减少请求数"></a>减少请求数</h2><ul><li>减少 <code>DNS</code> 查询时间。</li><li>利用浏览器本地存储或者 <code>redux、dva</code> 将请求数据缓存在本次会话中，避免多次请求。</li><li>利用 <code>url-loader</code> 对小图片进行 <code>base64</code> 转码通过增加体积换请求 或者 利用 <code>webpack5 - assets modules</code>。</li><li>配合 <code>webpack chunkhash</code> 合理使用浏览器缓存。</li></ul><h2 id="较小请求资源体积"><a href="#较小请求资源体积" class="headerlink" title="较小请求资源体积"></a>较小请求资源体积</h2><ul><li><code>webpack</code> 自带 <code>new TerserPlugin</code> 插件开启多线程 <code>js</code> 压缩。</li><li>生产环境看情况要不要进行 <code>mini-css-extract-plugin</code> 抽离 <code>css</code> 样式，利用 <code>optimize-css-assets-webpack-plugin</code> 压缩 <code>css</code>。</li><li><code>externals</code> 拆分不常变更的三方库，利用 <code>cdn</code> 加载。</li><li>开启 <code>tree sharking</code> 减少无用代码的引入。</li><li><code>IgnorePlugin</code> 忽略不需要的文件。</li><li>利用 <code>iconfont</code> 替换图标、图片。</li></ul><h2 id="提升网络传输速率"><a href="#提升网络传输速率" class="headerlink" title="提升网络传输速率"></a>提升网络传输速率</h2><ul><li>合理使用 <code>图片大小</code> 以及进行图片 <code>压缩</code>。</li><li><code>gzip</code> 压缩。</li><li><code>nginx</code> 代理以及负载均衡。</li><li><code>http2</code> 头部压缩（减少每次请求附带开销）、多路复用（保持一个链接可以用，减少握手次数带来性能损耗）、服务端推送（主动提前推送浏览器需要请求的资源）、请求优先级（重要的数据先请求或者先推送）。</li></ul><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><ul><li><code>babel</code> 开启缓存，<code>babel-loader?cacheDirectory</code>。</li><li><code>loader</code> 指定 <code>include</code> 或者 <code>exclude</code>指定目录，缩小构建范围。</li><li><code>loader</code> 的耗时如果比较多的话，可以使用 <code>thread-loader</code> 开启多线程池，充分利用机器资源。</li><li><code>HardSourceWebpackPlugin</code> 为模块提供中间缓存，首次构建时间没有太大变化，但是第二次开始，构建时间极大减少。</li><li><code>pm2</code> 可以开启 <code>node cluster</code> 集群模式。</li><li><code>js</code> 设置 <code>chunkhash，css</code> 利用 <code>new extractTextPlugin(&#39;../css/bundle.[name].[contenthash].css&#39;)</code> 设置 <code>contenthash</code>（暂未尝试），目的：<code>js</code> 模块改变之后，因为引用了 <code>css</code>，如果依然使用 <code>chunkhash</code> 会导致 <code>css</code> 重复构建，所以利用插件设置只有 <code>css</code> 内容发生变化的才构建，提升效率。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http2.0 学习笔记</title>
    <link href="/2021/04/05/http2-notes/"/>
    <url>/2021/04/05/http2-notes/</url>
    
    <content type="html"><![CDATA[<p><code>web</code> 性能权威指南的读书笔记，加深一些理解和记忆。</p><h2 id="http2-的目的"><a href="#http2-的目的" class="headerlink" title="http2 的目的"></a><code>http2</code> 的目的</h2><ul><li><p>支持请求和响应的 <code>多路复用</code> 来减少网络延迟。</p></li><li><p>通过压缩 <code>http</code> 首部字段将协议开销降至最低。</p></li><li><p>支持请求 <code>优先级</code>。</p></li><li><p><code>服务端推送</code> 能力。</p></li></ul><h2 id="增强性能的原因"><a href="#增强性能的原因" class="headerlink" title="增强性能的原因"></a>增强性能的原因</h2><ul><li><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3></li></ul><p>协议定义了如何封装 <code>http</code> 的消息在客户端和服务端之间传输。<code>http1.x</code> 是以换行符作为纯为本的分隔符，而 <code>http2.0</code> 是将传输信息分割为更小的消息和帧，并且对它们进行二进制编码。所以只有客户端和服务端同时理解 <code>http2.0</code> 的两者才能进行通信。</p><p>  说一下 流、消息、帧之间的关系。</p><ul><li><code>流</code>：在已经建立的连接上的双向字节流。</li><li><code>消息</code>：完整的一系列的数据帧。</li><li><code>帧</code>： <code>http2.0</code> 中通信的最小单位，每个帧包含首部，至少会标识出当前的帧是属于哪个流。</li></ul><p>串起来的一个流程大概就是： <code>http2.0</code> 协议连接之后，开始通信，其根本是在一个 <code>tcp</code> 的连接上完成的数据传输，在这个连接上，承载着任意数量的<code>双向数据流</code>。其中每一个数据流都是以消息【消息指代 <code>http</code> 的一些动作，请求、响应等】的方式发送的，而消息却是由一个或多个帧构成，其中这些帧都是以<code>乱序发送</code>的，在接受完数据之后，会根据帧的首部标识符来<code>重新组装</code>。</p><p>分析一下二进制分帧中最常见的两种工作流：</p><ul><li><h4 id="发起新流"><a href="#发起新流" class="headerlink" title="发起新流"></a>发起新流</h4><p>建立完 <code>http2.0</code> 的连接之后，在发起数据之前，必须要创建一个新的流来承载消息，流中需要包含资源的优先级、 <code>http</code> 首部等信息。 <code>http2.0</code> 的规定，客户端和服务端都可以发起新流，只是两者的方式不同。</p><ul><li>客户端发送 <code>HEADERS</code> 帧来发起新流，其发起的流是具有<code>奇数</code>的 <code>ID</code> 。</li><li>服务端发送 <code>PUSH_PROMISE</code> 帧来发起推流，其发起的流是具有<code>偶数</code>的 <code>ID</code> 。</li></ul><p>这样客户端和服务端每次发送流时候都会递增 <code>ID</code> ，两端的流并不会冲突。</p></li><li><h4 id="交换应用数据"><a href="#交换应用数据" class="headerlink" title="交换应用数据"></a>交换应用数据</h4><p>创建完新流并且发送完 <code>http</code> 首部之后，接下来就是发送应用数据，数据不会被另行编码或者压缩，编码方式取决于应用或者服务器，在发送数据的时候，每帧的大小最多可以达到 <code>2^16 - 1</code> 字节，但是为了减少队首阻塞，<code>http2.0</code> 要求数据不能超过 <code>2^14 - 1</code> ，如果数据超出，就需要分为多帧传输。</p></li><li><h3 id="多向请求和响应"><a href="#多向请求和响应" class="headerlink" title="多向请求和响应"></a>多向请求和响应</h3></li></ul><p>在 <code>http1.x</code> 中，如果客户端想发起多个并行的请求，那必须打开多个 <code>tcp</code> 的连接，但是其中多个响应的导致的最直接的问题就是排队，并且会导致<code>队首阻塞</code>，结果就是导致 <code>tcp</code> 的连接效率底下。</p><p><code>http2.0</code> 中二进制分帧突破了这一些限制，其实现了多向请求和响应，客户端和服务端都可以将 <code>http</code> 消息分解为互不依赖的帧，然后乱序在连接上发送，最后重新组合。这一增强带来的是巨大的性能提升，因为多个请求并行且互不影响、互不干扰、只需要一个连接就可以并行发送多个请求和响应、消除了 <code>http1.x</code> 中不必要的延迟、队首阻塞以及多个 <code>tcp</code> 连接抵效的问题。在同等的情况下，<code>http2.0</code> 只需要一个 <code>tcp</code> 连接就可以实现并行等，看似减少了 <code>tcp</code> 的连接数，其实最直接的是减少了服务端的 <code>cpu</code> 和内存的消耗。</p><ul><li><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3></li></ul><p>每一个在连接上传输的流都带有一个 <code>31</code> 比特的优先值，其中 <code>0</code> 最大，<code>2^31 - 1</code> 最小，服务端可以根据客户端资源请求的优先级来<code>控制资源的分配</code>（<code>cpu</code>、内存、带宽），在数据准备好之后，将优先级最高的数据先发送给客户端。在客户端明确设置好各种资源的优先级之后，服务端应该按照优先级要求将资源依次返回，这样排队的问题基本上就会解决掉。</p><ul><li><h3 id="一个连接"><a href="#一个连接" class="headerlink" title="一个连接"></a>一个连接</h3></li></ul><p><code>http2.0</code> 的所有传输都是在一个 <code>tcp</code> 的连接上完成，大多数的 <code>http</code> 连接都是突发并且短暂，但是因为 <code>tcp</code> 的<code>慢启动</code>以及<code>流量拥塞窗口</code>导致在经过一段时间之后才会很好的利用带宽，效率变高。而 <code>http2.0</code> 从头到尾的一个连接可以最大化和更有效的使用 <code>tcp</code> 的连接、减少网络延迟、提高吞吐量等。</p><ul><li><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3></li></ul><p>在 <code>http2.0</code> 连接建立之后，客户端和服务端会<code>交换帧</code>，其目的是设置双向的流量<code>控制窗口的大小</code>，从而控制流占用的资源，接收方针对特定的流动态调整窗口大小来限制或者提高传输速度。</p><ul><li><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3></li></ul><p>顾名思义，服务端可以直接向客户端发送响应，在上边的流量控制中，交换帧之后，客户端会收到 <code>PUSH_PROMISE</code> 的帧，客户端可以视自己需求来处理，限定推送流的数量或者设置 <code>0</code> 禁止服务端推送。如果服务端已经预先知道了客户端即将需求请求什么资源，那么就可以直接推送给客户端资源提前加载，减少在需求的时候请求带来的延迟。并且服务端推送过来的数据是可以<code>直接进行缓存</code>的。但是服务端推送的缺点，其要遵守 <code>请求-响应</code> 的顺序，不能随意的发起推送，并且 <code>PUSH_PROMISE</code> 的帧必须在返回响应之前发送，避免出现竞态条件出现浪费资源的请求，也就是说要确保客户端的请求不正好是服务端推送的就行。</p><ul><li><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3></li></ul><p><code>http1.x</code> 每次请求都需要携带头部的元数据，再加上一个 <code>cookie</code> 信息，仅一次请求不携带别的数据，固定荷载就可能会接近上千字节，为了减少这个开销，<code>http2.0</code> 进行了首部元数据的压缩。具体的就是，每次的发送，对于相同的数据不再发送，<code>http2.0</code> 的首部在一个连接内持续存在，并且信息是由双端共同更新。如果有新的首部键值对，要么在尾部追加，要么就是替换之前的。所以下一次的请求发起之前，如果发现首部没变化，就不会再发送首部，这会极大减少请求携带数据的开销。举例： <code>http1.x</code> 的轮训，每次请求固定的头部开销可能回到 <code>800k</code> ，而 <code>http2.0</code> 之后，可能第一次发起请求的时候会发送头部数据，之后的所有请求都不会再发送，因为后边的首部都是自动使用之前请求发送的首部。</p>]]></content>
    
    
    
    <tags>
      
      <tag>http2.0</tag>
      
      <tag>web性能权威指南</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现 JavaScript 中的 new 和 instanceof</title>
    <link href="/2021/03/06/show-me-code/"/>
    <url>/2021/03/06/show-me-code/</url>
    
    <content type="html"><![CDATA[<p>记录一下自己理解的 <code>new</code> 和 <code>instanceof</code>，实现一遍加深理解和记忆。</p><h2 id="new-操作符"><a href="#new-操作符" class="headerlink" title="new 操作符"></a><code>new</code> 操作符</h2><p>先从一个例子中看 <code>new</code> 操作符做了什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name<br>&#125;<br><br><span class="hljs-comment">// 为构造函数原型上增加一个方法</span><br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>已经吃了晚饭🥣`</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> personName = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'张三'</span>)<br><br>personName.name <span class="hljs-comment">// 张三</span><br>personName.say() <span class="hljs-comment">// 张三已经吃了晚饭🥣</span><br><br>personName.__proto__ === Person.prototype <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(personName) === Person.prototype <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>分析：首先实例的 <code>.</code> 访问的特性可以知道 <code>new</code> 最终 <code>return</code> 的是一个对象的类型，因此需要做一个判断，如果原来构造函数有 <code>Object</code> 类型的返回值，我们是不可以动的，也就是需要直接返回，如果不是 <code>Object</code> 类型的类型的话就要返回我们所创建的对象，所以必须先创建一个空的对象，作为在原来构造函数没有 <code>Object</code> 类型的情况下的返回值。然后发现实例具有一些可以访问构造函数的 <code>prototype</code> 的能力，而且是具有参数的绑定，并且我们知道实例的 <code>__proto__</code> 等于构造函数的 <code>prototype</code>。</p><p>大概实现应该如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Fn, ...args</span>) </span>&#123;<br>  <span class="hljs-comment">// 创建以备返回的空对象</span><br>  <span class="hljs-keyword">const</span> obj = &#123;&#125;<br>  <span class="hljs-comment">// 进行原型关系以及参数的绑定</span><br>  obj.__proto__ = Fn.prototype<br>  <span class="hljs-comment">// 或者 Object.getPrototypeOf(obj) = Fn.prototype</span><br><br>  <span class="hljs-keyword">const</span> result = Fn.apply(obj, args)<br><br>  <span class="hljs-keyword">const</span> isObject = <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">'object'</span> &amp;&amp; result !== <span class="hljs-string">'null'</span><br><br>  <span class="hljs-keyword">return</span> isObject ? result : obj <br>&#125;<br></code></pre></td></tr></table></figure><p>验证一下正确性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.name = name<br>&#125;<br><br>Person.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-keyword">this</span>.name&#125;</span>已经吃了晚饭🥣`</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> personName = myNew(Person, <span class="hljs-string">'莉莉丝'</span>)<br>personName.name <span class="hljs-comment">// 莉莉丝</span><br>personName.say() <span class="hljs-comment">// 莉莉丝已经吃了晚饭🥣</span><br><br>personName.__proto__ === Person.prototype <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(personName) === Person.prototype <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a><code>instanceof</code> 操作符</h2><p>我们都知道 <code>instanceof</code> 操作符是可以判断一个数据的类型，但是只能判断非简单的数据类型，继续以一个例子来看。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span><br>&#125; <span class="hljs-comment">// new Object</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">'张三'</span>] <span class="hljs-comment">// new Array</span><br><span class="hljs-keyword">const</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// false</span><br>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br>time <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>分析：可以从上面的例子发现，操作符右边的就是构造函数，左边就是构造函数的实例，而构造函数和实例之间的关系即就是 <code>instance.__proto__ === Fn.prototype</code>，但是根据作用域链的就近原则不能保证就近能找到对应的关系链所以必须要一步一步往原型链上找，找到的话就可以返回 <code>true</code>，我们知道原型链的顶端为 <code>null</code>，当为 <code>null</code> 的时候即没找到应该返回 <code>false</code>。</p><p>具体实现：</p><ul><li>迭代版</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <br>  <span class="hljs-comment">// 根据 instanceof 的特性可以知道，基本数据类型应该直接返回false</span><br>  <span class="hljs-keyword">const</span> isObject = <span class="hljs-keyword">typeof</span> left === <span class="hljs-string">'object'</span> &amp;&amp; left !== <span class="hljs-string">'null'</span><br>  <span class="hljs-keyword">if</span>(!isObject) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125;<br><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(left)<br>  <span class="hljs-comment">// 或者 let proto = left.__proto__</span><br><br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-comment">// 一直查找到原型链的顶端</span><br>    <span class="hljs-keyword">if</span>(proto == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br><br>    <span class="hljs-comment">// 即 instance.__proto__ === Fn.prototype</span><br>    <span class="hljs-keyword">if</span>(proto == right.prototype) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br><br>    <span class="hljs-comment">// 每次循环都将值重新设置</span><br>    proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(proto)<br>    <span class="hljs-comment">// 或者 proto = proto.__proto__;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>递归版</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> left !== <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-built_in">Object</span>.getPrototypeOf(left) === right.prototype || myInstanceof(left, right))<br>&#125;<br></code></pre></td></tr></table></figure><p>验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span><br>&#125; <span class="hljs-comment">// new Object</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">'张三'</span>] <span class="hljs-comment">// new Array</span><br><span class="hljs-keyword">var</span> time1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><br><span class="hljs-built_in">console</span>.log(obj1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>, arr1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>, time1 <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// false true true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 缓存探究</title>
    <link href="/2021/03/01/http-cache/"/>
    <url>/2021/03/01/http-cache/</url>
    
    <content type="html"><![CDATA[<p>最近在回顾缓存的一些知识点，先列出浏览器读取缓存过程会涉及到到的一些东西。</p><h2 id="DNS-缓存查询过程"><a href="#DNS-缓存查询过程" class="headerlink" title="DNS 缓存查询过程"></a><code>DNS</code> 缓存查询过程</h2><p><code>DNS</code> 缓存的目的主要是降低域名解析的时间延迟，最终解析成功之后，将所映射的 <code>IP</code> 返回给浏览器，并且于本地系统进行缓存，过程是递归的。</p><ul><li><p>浏览器会检查浏览器缓存中有没有这个域名对应的解析过的 <code>IP</code> 地址。</p></li><li><p>如果用户浏览器缓存中没有数据，浏览器会查找操作系统缓存 <code>hosts</code> 文件中是否有这个域名对应的 <code>DNS</code> 解析的 <code>IP</code> 结果。</p></li><li><p>如果 <code>hosts</code> 也没命中，则向本地 <code>DNS</code> 服务器尝试发起解析请求。</p></li><li><p>如果本地 <code>DNS</code> 服务器没命中，则向根 <code>DNS</code> 服务器发起解析请求。</p></li></ul><h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a><code>CDN</code> 缓存</h2><p>当接入 <code>CDN</code> 之后，<code>CDN</code> 节点具有缓存机制。当客户端向 <code>CDN</code> 节点请求数据时，<code>CDN</code> 会判断缓存数据是否过期，若没有过期，则直接将缓存数据返回给客户端，否则就向源站点发出请求，从源站点拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p><h3 id="不接入-CDN"><a href="#不接入-CDN" class="headerlink" title="不接入 CDN"></a>不接入 <code>CDN</code></h3><ul><li>输入域名之后，浏览器向 <code>DNS</code> 服务器发起请求，走 <code>DNS</code> 解析的过程，拿到 <code>IP</code> 之后直接向对应的 <code>IP</code> 的服务器发起请求，从源站点拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</li></ul><h3 id="接入-CDN"><a href="#接入-CDN" class="headerlink" title="接入 CDN"></a>接入 <code>CDN</code></h3><ul><li><p><code>CDN</code> 缓存不过期</p><ul><li>当浏览器本地缓存的资源过期之后，其不是直接向源站点请求资源，而是向 <code>CDN</code> 边缘节点请求资源，请求落在 <code>CDN</code> 这里的时候，因为 <code>CDN</code> 边缘节点中存在缓存，所以会使用 <code>CDN</code> 中的缓存。</li></ul></li><li><p><code>CDN</code> 缓存过期</p><ul><li>若 <code>CDN</code> 中的缓存也过期，<code>CDN</code> 节点会向源服务器发出回源请求，从服务器拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</li></ul></li></ul><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>属于本地缓存，因为要么就是硬盘缓存要么就是内存缓存，其中优先级 <code>Cache-Control</code> 高于 <code>Expires</code>，并且一旦命中则不会向服务端发起任何请求。</p><ul><li><p><code>Expires</code></p><ul><li><code>HTTP1.0</code> 的产物，是一个绝对时间不准确。</li></ul></li><li><p><code>Cache-Control</code></p><ul><li><p><code>public</code> 认为都可以缓存</p></li><li><p><code>private</code> 认为都可以缓存</p></li><li><p><code>no-cache</code> 客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定，所以使用 <code>Etag</code> 或者 <code>Last-Modified</code> 字段来控制缓存</p></li><li><p><code>no-store</code> 不使用缓存</p></li><li><p><code>max-age</code> 所有的缓存会在设置的秒数之后失效</p></li></ul></li><li><p>命中情况</p><p>当做了有效缓存策略之后，网站第一次加载的时候获取的数据是先从服务器 <code>200</code> 请求，再因为设置缓存策略，关掉页面，再打开，数据再读取的缓存获取是从 <code>disk</code> 加载到内存中，所以重新打开的第一次是 <code>from disk cache</code>。</p><p>当重新第一次打开加载成功之后的缓存是 <code>from disk cache</code> 并且被加载到了内存里，刷新页面，因为内存读取的优先级高于硬盘，所以刷新之后的缓存读取来源是 <code>from memory cache</code>。</p><ul><li><p><code>from disk cache</code></p><ul><li>持久、相比内存慢、读取优先级低于内存</li></ul></li><li><p><code>from memory cache</code></p><ul><li>非持久、快、读取优先级高于硬盘</li></ul></li></ul></li></ul><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当强缓存未命中之后，或者当强缓存的 <code>Cache-Control</code> 的值设置为 <code>no-cache</code> 的时候，根据 <code>1.1</code> 中的 <code>ETag</code> 优先级高于 <code>Last-Modified</code> 从而发起协商缓存。</p><p>即便如此，发起协商缓存在有没有接入 <code>CDN</code> 的时候，又可以分为两种情况。</p><p>先说 <code>HTTP</code> 请求和相应头：</p><ul><li><p><code>HTTP1.0</code></p><ul><li><p><code>Last-Modified</code></p><ul><li>客户端第一次请求的时候，服务端会在响应头增加 <code>Last-Modified</code> 的 <code>header</code> 字段来告知浏览器对应的文件的最后修改时间。</li></ul></li><li><p><code>If-Modified-Since</code></p><ul><li>下一次请求这个资源，浏览器检测到有 <code>Last-Modified</code> 这个 <code>header</code>，于是在请求头添加 <code>If-Modified-Since</code> 这个 <code>header</code>，它的内容就是第一次 <code>Last-Modified</code> 返回的数据。</li><li>当服务器收到之后会用这个值和服务器上保存的最后一次文件的修改时间做对比，如果命中，则返回 <code>304</code>，告知浏览器使用本地缓存，否则返回 <code>200</code>，并且需要更新 <code>Last-Modified</code> 的值，并且一同返回资源。</li></ul></li></ul></li><li><p><code>HTTP1.1</code></p><ul><li><p><code>ETag</code></p><ul><li><code>Etag</code> 是服务器响应请求时，在响应头返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，<code>Etag</code> 就会重新生成，大体类似文件 <code>diff</code> 之后生成的一个 <code>hash</code> 值。</li></ul></li><li><p><code>If-None-Match</code></p><ul><li>下一次请求这个资源，浏览器会将上次 <code>ETag</code> 返会的内容，通过 <code>If-None-Match</code> 的请求头传递给服务器。</li><li>服务器收到之后会用这个和服务器上存的文件最后一次变动生成的 <code>ETag</code> 的值做对比，如果两个相同则返回 <code>304</code>，告知浏览器使用本地缓存，否则返回 <code>200</code>，并且需要更新 <code>ETag</code> 的值，并且一同返回资源。</li></ul></li></ul></li></ul><p>所以汇总一下浏览器读取缓存整体的一个流程，在接入了 <code>CDN</code> 之后和不接入 <code>CDN</code> 的情况我们可以描述一下：</p><ul><li><p>接入 <code>CDN</code> 之后，当用户在浏览器地址栏输入一个 <code>URL</code> 之后，浏览器会先去根据请求头来确定当前的强缓存的时效性，如果未失效，则会去读取本地缓存，至于读取 <code>disk</code> 还是 <code>momery</code>，需要看用户的行为。如果强缓存未命中，也就是说 <code>max-age</code> 的时间过期了，或者 <code>Cache-Control</code> 设置为 <code>no-cache</code>，则会进行协商缓存，协商缓存如果返回结果告诉浏览器，资源未更改，可以使用缓存，则浏览器依旧读取本地缓存。如果当协商缓存也失效之后，此时因为接入了 <code>CDN</code>，所以浏览器会向 <code>CDN</code> 的边缘节点发起请求，而不是进行一系列的域名解析去源服务器找缓存或者资源，但是这会面临 <code>CDN</code> 的缓存时效性，所以后面会执行上边的<code>【接入 CDN 的逻辑】</code>。</p></li><li><p>不接入 <code>CND</code> 之后，强缓存和协商缓存的命中逻辑都和接入 <code>CDN</code> 的一致，但是因为没有接入 <code>CDN</code>，所以需要进行域名解析等一系列步骤，执行的是上边<code>【不接入 CDN 】的逻辑</code>。</p></li></ul><h2 id="一些可能对缓存造成的影响"><a href="#一些可能对缓存造成的影响" class="headerlink" title="一些可能对缓存造成的影响"></a>一些可能对缓存造成的影响</h2><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><ul><li>第一次打开网页，获取内容存入 <code>disk</code>，再次打开如果 <code>disk</code> 有，则读取。没有则查看协商缓存</li><li>普通刷新，若第一次命中了 <code>disk</code> 的缓存，刷新的时候会直接读取 <code>memory</code> 并且优先级高于 <code>disk</code></li><li>强制清缓存刷新，不使用本地缓存</li></ul><h3 id="webpack-打包后的文件"><a href="#webpack-打包后的文件" class="headerlink" title="webpack 打包后的文件"></a><code>webpack</code> 打包后的文件</h3><ul><li><p>如果设置了强缓存，在 <code>webpack</code> 打包之后，因为文件内容改变最终打包的名称 <code>chunkhash</code> 会改变，所以浏览器的缓存失效，就会请求新的资源，并不会导致出现请求旧的资源的问题。</p><p>所以第一次请求新资源，以后可能会读取缓存。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用 Workbox 为博客增加PWA功能</title>
    <link href="/2021/01/31/website-realize-pwa/"/>
    <url>/2021/01/31/website-realize-pwa/</url>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>很早之前就了解过 <code>Service Worker</code> 再到后来的 <code>PWA</code>，并且一直想尝试为网站增加一些新的特性，尤其是 <code>PWA</code> 的可以将网站安装在桌面这一个功能非常吸引我，而正好 <code>github-pages</code> 是部署在 <code>https</code> 上，所以用 <code>workbox</code> 直接改造了基于 <code>github-pages</code> 的 <code>hexo</code> 个人博客。</p><p><code>PWA</code> 的好处自然不用多说，其能发送快捷方式到桌面上这一功能，将用户的操作链由之前的最长的 打开浏览器-&gt;输入网址[面临敲错的尴尬地步]-&gt;渲染目标网站 或者最短的 打开浏览器-&gt;选择书签加载目标网站，优化到了只有点击发送到桌面的快捷方式直接打开网站这一步，即一触即达，而且没有浏览器菜单栏、地址栏的影响，再配合 <code>Service Worker</code> 实现的加速和离线访问，这可谓说是大大提高了用户的粘性，非常利于网站留存。</p><p><code>PWA</code> 不是特指某一项技术，而是应用了多项技术的 <code>Web App</code>。其核心技术包括 App Manifest、<code>Service Worker</code>、<code>Web Push</code> 等。我们能够发现一些主流网站例如 <code>vue</code> 的官网、星巴克 <code>web</code> 版都是支持 <code>PWA</code> 的。</p><h2 id="workbox"><a href="#workbox" class="headerlink" title="workbox"></a><code>workbox</code></h2><p><code>workbox</code> 是 <code>GoogleChrome</code> 团队推出的一套 <code>Web App</code> 静态资源和请求结果的本地存储的解决方案，该解决方案包含一些 Js 库和构建工具，在 <code>Chrome Submit 2017</code> 上首次隆重面世。而在 <code>workbox</code> 背后则是 <code>Service Worker</code> 和 <code>Cache API</code> 等技术和标准在驱动。</p><h2 id="App-Manifest"><a href="#App-Manifest" class="headerlink" title="App Manifest"></a><code>App Manifest</code></h2><p>一个 <code>json</code> 的文件，通过一系列配置，就可以把一个 <code>PWA</code> 像 <code>APP</code> 一样，添加一个图标到手机屏幕上，点击图标即可打开站点。</p><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a><code>Service Worker</code></h2><p>也是 <code>PWA</code> 技术背后非常重要的角色，<code>Service worker</code> 实际上是一段 <code>js</code> 脚本，在后台运行，并不是在主线程中运行。它是作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与 <code>Web</code> 交互行为，无法操作 <code>dom</code> 等等，<code>Service Worker</code> 的出现是正是为了使得 <code>Web App</code> 也可以做到像 <code>Native App</code> 那样可以离线使用、消息推送的功能。<code>Service Worker</code> 是具有生命周期的，大概可以分为：安装、激活、卸载。</p><h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><ul><li><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cnpm install workbox-build gulp gulp-uglify readable-stream uglify-es --save-dev<br></code></pre></td></tr></table></figure><ul><li><h3 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h3><p>我们首先在博客的根目录下新建 <code>gulpfile.js</code> 文件</p></li></ul><p>大概解释一下 <code>gulpfile.js</code> 的文件内容：首先是 <code>gulp</code> 会执行一个任务叫<code>generate-service-worker</code>即生成 <code>service-worker</code>，当然这个任务名是自己随意起的，然后通过 <code>injectManifest</code> 注入，<code>globPatterns</code> 是匹配的所有资源的列表，博客首次加载时，自动将这些文件缓存，然后利用 <code>sw-template.js</code> 模板，最后在执行 <code>gulp build</code> 就会在 <code>hexo generate</code> 之后的 <code>public</code> 文件夹下生成一份线上可用的 <code>sw.js</code> 文件。第二个任务是压缩生成的 <code>sw</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">"gulp"</span>);<br><span class="hljs-keyword">const</span> workbox = <span class="hljs-built_in">require</span>(<span class="hljs-string">"workbox-build"</span>);<br><span class="hljs-keyword">const</span> uglifyes = <span class="hljs-built_in">require</span>(<span class="hljs-string">"uglify-es"</span>);<br><span class="hljs-keyword">const</span> composer = <span class="hljs-built_in">require</span>(<span class="hljs-string">"gulp-uglify/composer"</span>);<br><span class="hljs-keyword">const</span> uglify = composer(uglifyes, <span class="hljs-built_in">console</span>);<br><span class="hljs-keyword">const</span> pipeline = <span class="hljs-built_in">require</span>(<span class="hljs-string">"readable-stream"</span>).pipeline;<br><br>gulp.task(<span class="hljs-string">"generate-service-worker"</span>, () =&gt; &#123;<br>  <span class="hljs-keyword">return</span> workbox.injectManifest(&#123;<br>    <span class="hljs-attr">swSrc</span>: <span class="hljs-string">"./sw-template.js"</span>,<br>    <span class="hljs-attr">swDest</span>: <span class="hljs-string">"./public/sw.js"</span>,<br>    <span class="hljs-attr">globDirectory</span>: <span class="hljs-string">"./public"</span>,<br>    <span class="hljs-attr">globPatterns</span>: [<span class="hljs-string">"**/*.&#123;html,css,js,json,woff2&#125;"</span>],<br>    <span class="hljs-attr">modifyURLPrefix</span>: &#123;<br>      <span class="hljs-string">""</span>: <span class="hljs-string">"./"</span><br>    &#125;<br>  &#125;);<br>&#125;);<br><br>gulp.task(<span class="hljs-string">"uglify"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> pipeline(gulp.src(<span class="hljs-string">"./public/sw.js"</span>), uglify(), gulp.dest(<span class="hljs-string">"./public"</span>));<br>&#125;);<br><br>gulp.task(<span class="hljs-string">"build"</span>, gulp.series(<span class="hljs-string">"generate-service-worker"</span>, <span class="hljs-string">"uglify"</span>));<br></code></pre></td></tr></table></figure><p>然后也在根目录下创建 <code>sw-template.js</code> 文件，我用的是 <code>6.1.0</code> 的 <code>CDN</code> 版本。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用Google Cloud Storage上的Workbox CDN</span><br>importScripts(<br>  <span class="hljs-string">`https://storage.googleapis.com/workbox-cdn/releases/6.1.0/workbox-sw.js`</span><br>);<br><br><span class="hljs-comment">// 这个prefix非常重要，需要改成自己的github的name</span><br>workbox.core.setCacheNameDetails(&#123;<br>  <span class="hljs-attr">prefix</span>: <span class="hljs-string">"tennesseesunshine"</span><br>&#125;);<br><br>workbox.core.skipWaiting();<br><br>workbox.core.clientsClaim();<br><br>workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);<br><br>workbox.precaching.cleanupOutdatedCaches();<br><br><span class="hljs-comment">// workbox.routing.registerRoute 利用正则来匹配注册路由，类似于webpack的loader，匹配到之后用callback处理</span><br><br>workbox.routing.registerRoute(<br>  <span class="hljs-regexp">/\.(?:png|jpg|jpeg|gif|bmp|webp|svg|ico)$/</span>,<br>  <span class="hljs-comment">// 缓存图片，以及设置缓存时间</span><br>  <span class="hljs-keyword">new</span> workbox.strategies.CacheFirst(&#123;<br>    <span class="hljs-attr">cacheName</span>: <span class="hljs-string">"images"</span>,<br>    <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-keyword">new</span> workbox.expiration.ExpirationPlugin(&#123;<br>        <span class="hljs-attr">maxEntries</span>: <span class="hljs-number">1000</span>,<br>        <span class="hljs-attr">maxAgeSeconds</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span><br>      &#125;),<br>      <span class="hljs-keyword">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;<br>        <span class="hljs-attr">statuses</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">200</span>]<br>      &#125;)<br>    ]<br>  &#125;)<br>);<br><br><span class="hljs-comment">// Fonts</span><br>workbox.routing.registerRoute(<br>  <span class="hljs-regexp">/\.(?:eot|ttf|woff|woff2)$/</span>,<br>  <span class="hljs-keyword">new</span> workbox.strategies.CacheFirst(&#123;<br>    <span class="hljs-attr">cacheName</span>: <span class="hljs-string">"fonts"</span>,<br>    <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-keyword">new</span> workbox.expiration.ExpirationPlugin(&#123;<br>        <span class="hljs-attr">maxEntries</span>: <span class="hljs-number">1000</span>,<br>        <span class="hljs-attr">maxAgeSeconds</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span><br>      &#125;),<br>      <span class="hljs-keyword">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;<br>        <span class="hljs-attr">statuses</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">200</span>]<br>      &#125;)<br>    ]<br>  &#125;)<br>);<br><br><span class="hljs-comment">// Google Fonts</span><br>workbox.routing.registerRoute(<br>  <span class="hljs-regexp">/^https:\/\/fonts\.googleapis\.com/</span>,<br>  <span class="hljs-keyword">new</span> workbox.strategies.StaleWhileRevalidate(&#123;<br>    <span class="hljs-attr">cacheName</span>: <span class="hljs-string">"google-fonts-stylesheets"</span><br>  &#125;)<br>);<br>workbox.routing.registerRoute(<br>  <span class="hljs-regexp">/^https:\/\/fonts\.gstatic\.com/</span>,<br>  <span class="hljs-keyword">new</span> workbox.strategies.CacheFirst(&#123;<br>    <span class="hljs-attr">cacheName</span>: <span class="hljs-string">"google-fonts-webfonts"</span>,<br>    <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-keyword">new</span> workbox.expiration.ExpirationPlugin(&#123;<br>        <span class="hljs-attr">maxEntries</span>: <span class="hljs-number">1000</span>,<br>        <span class="hljs-attr">maxAgeSeconds</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span><br>      &#125;),<br>      <span class="hljs-keyword">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;<br>        <span class="hljs-attr">statuses</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">200</span>]<br>      &#125;)<br>    ]<br>  &#125;)<br>);<br><br><span class="hljs-comment">// Static Libraries</span><br>workbox.routing.registerRoute(<br>  <span class="hljs-regexp">/^https:\/\/cdn\.jsdelivr\.net/</span>,<br>  <span class="hljs-keyword">new</span> workbox.strategies.CacheFirst(&#123;<br>    <span class="hljs-attr">cacheName</span>: <span class="hljs-string">"static-libs"</span>,<br>    <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-keyword">new</span> workbox.expiration.ExpirationPlugin(&#123;<br>        <span class="hljs-attr">maxEntries</span>: <span class="hljs-number">1000</span>,<br>        <span class="hljs-attr">maxAgeSeconds</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span><br>      &#125;),<br>      <span class="hljs-keyword">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;<br>        <span class="hljs-attr">statuses</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">200</span>]<br>      &#125;)<br>    ]<br>  &#125;)<br>);<br><br><span class="hljs-comment">// External Images</span><br>workbox.routing.registerRoute(<br>  <span class="hljs-regexp">/^https:\/\/raw\.githubusercontent\.com\/reuixiy\/hugo-theme-meme\/master\/static\/icons\/.*/</span>,<br>  <span class="hljs-keyword">new</span> workbox.strategies.CacheFirst(&#123;<br>    <span class="hljs-attr">cacheName</span>: <span class="hljs-string">"external-images"</span>,<br>    <span class="hljs-attr">plugins</span>: [<br>      <span class="hljs-keyword">new</span> workbox.expiration.ExpirationPlugin(&#123;<br>        <span class="hljs-attr">maxEntries</span>: <span class="hljs-number">1000</span>,<br>        <span class="hljs-attr">maxAgeSeconds</span>: <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">30</span><br>      &#125;),<br>      <span class="hljs-keyword">new</span> workbox.cacheableResponse.CacheableResponsePlugin(&#123;<br>        <span class="hljs-attr">statuses</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">200</span>]<br>      &#125;)<br>    ]<br>  &#125;)<br>);<br><br>workbox.googleAnalytics.initialize();<br></code></pre></td></tr></table></figure><p>接着在博客主题的 <code>source</code> 源码下，创建 <code>manifest.json</code> 文件，用于发送到桌面快捷方式的一些配置。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"填写你需要的名字"</span>,<br>  <span class="hljs-attr">"short_name"</span>: <span class="hljs-string">"填写你需要的名字"</span>,<br>  <span class="hljs-attr">"icons"</span>: [<br>    &#123;<br>      <span class="hljs-attr">"src"</span>: <span class="hljs-string">"/img/icons.png"</span>,<br>      <span class="hljs-attr">"sizes"</span>: <span class="hljs-string">"256x256"</span>,<br>      <span class="hljs-attr">"type"</span>: <span class="hljs-string">"image/png"</span><br>    &#125;<br>  ],<br>  <span class="hljs-attr">"theme_color"</span>: <span class="hljs-string">"#fff"</span>,<br>  <span class="hljs-attr">"background_color"</span>: <span class="hljs-string">"#fff"</span>,<br>  <span class="hljs-attr">"display"</span>: <span class="hljs-string">"standalone"</span>,<br>  <span class="hljs-attr">"orientation"</span>: <span class="hljs-string">"portrait-primary"</span>,<br>  <span class="hljs-attr">"start_url"</span>: <span class="hljs-string">"."</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意的事项：<code>icons</code> 下的 <code>sizes</code> 必须是正方形，并且需要大于 <code>144px</code> 左右，用 <code>256</code> 就可以。</p><ul><li><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3>先 <code>hexo</code> 生成静态文件，再有 <code>gulp</code> 生成 <code>sw</code> 缓存列表。</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">hexo g <span class="hljs-meta">&amp;&amp; gulp build</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="编辑模版"><a href="#编辑模版" class="headerlink" title="编辑模版"></a>编辑模版</h3></li></ul><p>接下来我们还需要在 <code>HTML</code> 页面中加入相关代码以注册 <code>Service Worker</code>，并添加页面更新后的提醒功能。这个需要根据自己的目前使用的主题来修改，具体做法就是找到自己目前使用博客主题的目录，在其模版相关文件的<code>&lt;/body&gt;</code>下，插入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app-refresh"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app-refresh"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"app-refresh-wrap"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"location.reload()"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>已更新最新版本<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"cursor: pointer;"</span>&gt;</span>点击刷新<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>  <span class="hljs-keyword">if</span> (<span class="hljs-string">"serviceWorker"</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>    <span class="hljs-keyword">if</span> (navigator.serviceWorker.controller) &#123;<br>      navigator.serviceWorker.addEventListener(<span class="hljs-string">"controllerchange"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        showNotification();<br>      &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 因为在本地开发环境下不需要sw的缓存，在更新博客之后，刷新会刷不出来新的博客内容，所以这里判断如果是线上才注册sw否则就卸载掉</span><br><br>    <span class="hljs-comment">// 这里的判断条件就是自己的博客的域名</span><br>    <span class="hljs-keyword">if</span> (location.host === <span class="hljs-string">"tennesseesunshine.github.io"</span>) &#123;<br>      <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"load"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        navigator.serviceWorker.register(<span class="hljs-string">"/sw.js"</span>);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      navigator.serviceWorker.getRegistrations().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">registrations</span>) </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> registration <span class="hljs-keyword">of</span> registrations) &#123;<br>          registration.unregister();<br>        &#125;<br>      &#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showNotification</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">"meta[name=theme-color]"</span>).content = <span class="hljs-string">"#000"</span>;<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"app-refresh"</span>).className += <span class="hljs-string">" app-refresh-show"</span>;<br>  &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><h3 id="设置站点更新提示刷新的样式"><a href="#设置站点更新提示刷新的样式" class="headerlink" title="设置站点更新提示刷新的样式"></a>设置站点更新提示刷新的样式</h3></li></ul><p>依旧是找到自己的博客主题，找到 <code>css</code> 样式文件，在其下增加<code>_customs/custom.styl</code> 文件，写入一下内容：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs styl">.app-refresh<br>  background #000<br>  height 0<br>  line-height 3em<br>  overflow hidden<br>  position fixed<br>  top 0<br>  left 0<br>  right 0<br>  z-index 1031<br>  padding 0 1em<br>  transition all .3s ease<br>.app-refresh-wrap<br>  display flex<br>  color #fff<br><br>.app-refresh-wrap label<br>  flex 1<br><br>.app-refresh-show<br>  height 3em<br></code></pre></td></tr></table></figure><p>再于统一导出的 <code>styl</code> 的文件中，引入<br><code>@import &quot;\_customs/custom&quot;</code></p><p>至此所有的配置都已经完成。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://io-oi.me/tech/pwa-via-workbox/" target="_blank" rel="noopener">利用 Workbox 实现博客的 PWA</a></p><p><a href="https://guanqr.com/tech/website/realize-pwa/" target="_blank" rel="noopener">博客实现 PWA 功能</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwa</tag>
      
      <tag>Workbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>探究 webpack 异步加载原理以及热更新流程</title>
    <link href="/2021/01/30/webpack-dynamic-load/"/>
    <url>/2021/01/30/webpack-dynamic-load/</url>
    
    <content type="html"><![CDATA[<p>异步加载应该分为代码模块的异步加载和路由的异步加载，但其原理基本都是一样的，我们先来看一个模块的异步加载。</p><h2 id="模块异步加载"><a href="#模块异步加载" class="headerlink" title="模块异步加载"></a>模块异步加载</h2><h3 id="初始化文件结构"><a href="#初始化文件结构" class="headerlink" title="初始化文件结构"></a>初始化文件结构</h3><p>首先我们一步一步开始，新建一个目录 <code>checkWebpackBundled</code>，安装 <code>webpack、webpack-cli、html-webpack-plugin、clean-webpack-plugin</code> 最终生成的文件结构大概类似于：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">|-- checkWebpackBundled</span><br>    <span class="hljs-string">|-- index.html // 用于html-webpack-plugin用的模板</span><br>    <span class="hljs-string">|-- package.json</span><br>    <span class="hljs-string">|-- webpack.config.js</span><br>    <span class="hljs-string">|-- src</span><br>        <span class="hljs-string">|-- buttonHello.js</span><br>        <span class="hljs-string">|-- buttonHi.js</span><br>        <span class="hljs-string">|-- main.js // webpack打包入口文件</span><br></code></pre></td></tr></table></figure><h3 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h3><p>我们先来写一个 <code>main.js</code> 文件，其中直接引入两个文件一个是 <code>buttonHi.js</code> 另一个是 <code>buttonHello.js</code>，然后我们配置一下 <code>webpack</code>，编写一个 <code>index.html</code> 的模板。</p><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> buttonHi <span class="hljs-keyword">from</span> <span class="hljs-string">"./buttonHi"</span>;<br><span class="hljs-keyword">import</span> buttonHello <span class="hljs-keyword">from</span> <span class="hljs-string">"./buttonHello"</span>;<br><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".button-hi"</span>).addEventListener(<span class="hljs-string">"click"</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"buttonHi"</span>, buttonHi);<br>&#125;);<br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".button-hello"</span>).addEventListener(<span class="hljs-string">"click"</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"buttonHello"</span>, buttonHello);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>buttonHi.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-string">"button-hi!"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br></code></pre></td></tr></table></figure><p><code>buttonHello.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-string">"button-hello!!"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br></code></pre></td></tr></table></figure><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<br><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"clean-webpack-plugin"</span>);<br><span class="hljs-comment">/**<br> * @type &#123;webpack.Configuration&#125;<br> */</span><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">"./src/main.js"</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name].js"</span>,<br>    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">"dist"</span>)<br>  &#125;,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>, <span class="hljs-comment">// 我们选择了dev模式，到时候打包完成之后的代码就不是压缩之后的，而且还是支持evel的sourceMap</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">"./index.html"</span><br>    &#125;)<br>  ]<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = config;<br></code></pre></td></tr></table></figure><p><code>index.html</code> 模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>webpack异步加载原理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button-hi"</span>&gt;</span>点我是 hi！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button-hello"</span>&gt;</span>点我是 hello!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来我们开始在终端运行 <code>npx webpack</code>，生成了 <code>dist</code> 目录，里面有我们打包成功的 <code>js</code> 文件和 <code>HtmlWebpackPlugin</code> 插件为我们生成的 <code>index.html</code>，我们在浏览器中运行 <code>index.html</code>，依次点击页面的两个按钮发现，分别在浏览器控制台打印出了<code>buttonHi button-hi!</code>和<code>buttonHello button-hello!!</code>。而且我们发现，我们的两个依赖文件全部都被打包到了 <code>main.js</code> 文件中。我们来看一下这种模式打包的产物是什么：</p><p>首先我们打开 <code>main.js</code>，将代码折叠起来，我们发现最终打包成功的文件是一个自执行函数，我们来简单看一下有用的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// webpackBootstrap</span><br><span class="hljs-meta">  "use strict"</span>;<br>  <span class="hljs-comment">// 我们来看__webpack_modules__这个对象是一个map的映射，key是我们需要加载的模块的名称也就是依赖文件的路径，value是一个函数，这个函数的返回值其实就是将我们的源码的内容转为了webpack的一些方法</span><br>  <span class="hljs-keyword">var</span> __webpack_modules__ = &#123;<br>    <span class="hljs-comment">// 这里有三个模块，我们只看这一个，其他的同理</span><br>    <span class="hljs-string">"./src/buttonHello.js"</span>:<br>      <span class="hljs-comment">/*!****************************!*\<br>  !*** ./src/buttonHello.js ***!<br>  \****************************/</span><br>      <span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 这里是因为我们的webpack的mode设置的是develpoment模式，开启的eval的sourceMap，eval会将字符串变为可以执行的js</span><br>        <span class="hljs-built_in">eval</span>(<br>          <span class="hljs-string">"__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;\n/* harmony export */   \"default\": () =&gt; __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ &#125;);\nconst a = 'button-hello!!'\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (a);\n\n//# sourceURL=webpack://checkWebpackBundled/./src/buttonHello.js?"</span><br>        );<br><br>        <span class="hljs-comment">/***/</span><br>      &#125;,<br>    <span class="hljs-string">"./src/main.js"</span>: (<br>      __unused_webpack_module,<br>      __webpack_exports__,<br>      __webpack_require__<br>    ) =&gt; &#123;<br>      <span class="hljs-comment">// 战略性省略</span><br>    &#125;,<br>    <span class="hljs-string">"./src/buttonHi.js"</span>: (<br>      __unused_webpack_module,<br>      __webpack_exports__,<br>      __webpack_require__<br>    ) =&gt; &#123;<br>      <span class="hljs-comment">// 战略性省略</span><br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 定义一个缓存模块</span><br>  <span class="hljs-keyword">var</span> __webpack_module_cache__ = &#123;&#125;;<br>  <span class="hljs-comment">// webpack的加载函数，到最终CJS和ESM都是通过这个方法加载文件</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123;<br>    <span class="hljs-comment">// 跟nodejs的加载模块原理一致，之前读取过的话再次读取会从缓存中拿</span><br>    <span class="hljs-keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;<br>      <span class="hljs-keyword">return</span> __webpack_module_cache__[moduleId].exports;<br>    &#125;<br>    <span class="hljs-comment">// 没有命中的话，将新模块推入缓存中</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;<br>      <span class="hljs-comment">// no module.id needed</span><br>      <span class="hljs-comment">// no module.loaded needed</span><br>      exports: &#123;&#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 用__webpack_modules__的映射去执行对应的函数，也就是执行相应的moduleId对应的模块内容，将模块的加载挂在exports的对象上</span><br>    __webpack_modules__[moduleId](<span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);<br><br>    <span class="hljs-comment">// Return the exports of the module</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;<br>  &#125;<br><br>  <span class="hljs-comment">/* webpack/runtime/define property getters */</span><br>  (<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// define getter functions for harmony exports</span><br>    __webpack_require__.d = <span class="hljs-function">(<span class="hljs-params">exports, definition</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> definition) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          __webpack_require__.o(definition, key) &amp;&amp;<br>          !__webpack_require__.o(exports, key)<br>        ) &#123;<br>          <span class="hljs-built_in">Object</span>.defineProperty(exports, key, &#123;<br>            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">get</span>: definition[key]<br>          &#125;);<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;)();<br><br>  <span class="hljs-comment">/* webpack/runtime/hasOwnProperty shorthand */</span><br>  <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> &#123;<br>    __webpack_require__.o = <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span><br>      <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);<br>  &#125;)();<br><br>  <span class="hljs-comment">/* webpack/runtime/make namespace object */</span><br>  <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// define __esModule on exports</span><br>    __webpack_require__.r = <span class="hljs-function"><span class="hljs-params">exports</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag) &#123;<br>        <span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-built_in">Symbol</span>.toStringTag, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">"Module"</span> &#125;);<br>      &#125;<br>      <span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">"__esModule"</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;);<br>    &#125;;<br>  &#125;)();<br><br>  <span class="hljs-comment">// 这里就是初始化加载我们的入口文件</span><br>  __webpack_require__(<span class="hljs-string">"./src/main.js"</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>所以我们结合构建机制看一下，构建开始是： <code>webpack</code> 转换代码并生成单个文件依赖，从入口文件开始递归分析并生成依赖图谱，即 <code>webpack</code> 能够找到入口文件，剩下的模块都是按照流程执行的。所以最后的执行流程是，<code>webpack</code> 最终打包生成的是一个 <code>IIFE</code>，其中有很多自执行函数是为<code>webpack_require</code>扩展增加的方法，而且我们能够发现我们编写的代码模块已经被 <code>webpack</code> 的内部扩展的方法包装过了，在最后我们发现<code>webpack_require(&quot;./src/main.js&quot;)</code>，这是调用了入口文件开始执行，这样打包生成的最后的文件，就会按照生成的依赖分别加载对应的模块文件，从而在浏览器中加载以及加载对应的页面或者方法。</p><p>引申出来的问题：到这里我们应该能够体会到一个缺点，如果项目的依赖太多且有的依赖很大，我们现在这种引入方式是有问题的，所有的引用最终如果都被打包到一个文件中，在初始化请求到时候，就会造成很多浪费以及延长加载时间，所以我们需要将有些依赖拆分出去，只在初始化的时候请求必须的文件，别的文件在执行的时候（动态引入的方法），或者路由切换的时候（路由懒加载）才去加载或者配合 <code>webpack</code> 的 <code>splitchunk</code> 来做分包。</p><h3 id="动态加载的两种方法"><a href="#动态加载的两种方法" class="headerlink" title="动态加载的两种方法"></a>动态加载的两种方法</h3><ul><li><code>ESM</code> 的 <code>import</code></li><li><code>webpack</code> 的 <code>webpack.ensure</code></li></ul><p><code>webpack</code> 已经不推荐使用 <code>webpack.ensure</code> 了，我们直接用 <code>import</code> 来测试。所以我们来使用 <code>import</code> 来异步加载模块，我们修改 <code>main.js</code> 文件</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- import buttonHi from "./buttonHi";</span><br><span class="hljs-deletion">- import buttonHello from "./buttonHello";</span><br><br>document.querySelector(".button-hi").addEventListener("click", () =&gt; &#123;<br><span class="hljs-deletion">-  console.log("buttonHi", buttonHi);</span><br><span class="hljs-addition">+  import(/* webpackChunkName */`./buttonHi`).then(data =&gt; &#123;</span><br><span class="hljs-addition">+    console.log('data', data.default);</span><br><span class="hljs-addition">+  &#125;)</span><br>&#125;);<br>document.querySelector(".button-hello").addEventListener("click", () =&gt; &#123;<br><span class="hljs-deletion">-  console.log("buttonHello", buttonHello);</span><br><span class="hljs-addition">+  import(/* webpackChunkName */`./buttonHello`).then(data =&gt; &#123;</span><br><span class="hljs-addition">+    console.log('data', data.default);</span><br><span class="hljs-addition">+  &#125;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>再次运行 <code>npx webpack</code> 发现我们的 <code>dist</code> 下打包出来三个 <code>js</code> 文件</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">|-- dist</span><br>    <span class="hljs-string">|-- index.html</span><br>    <span class="hljs-string">|-- main.js</span><br>    <span class="hljs-string">|-- src_buttonHello_js.js</span><br>    <span class="hljs-string">|-- src_buttonHi_js.js</span><br></code></pre></td></tr></table></figure><p>我们能清楚的看到打包生成了三个文件，其中被我们 <code>import</code> 引入的文件分别被单独打包了。而且我们查看 <code>index.html</code> 发现只引用了一个入口文件 <code>main.js</code>，另外两个文件是没有被引入的。接下来我们在浏览器中继续刷新页面，发现 <code>network</code> 只请求了 <code>index.html</code> 和 <code>main.js</code> 文件。</p><p>我们开始点击第一个按钮，再观察 <code>network</code> 发现加载了 <code>src_buttonHi_js.js</code> 文件，并且浏览器控制台输出了我们要打印的文字，第二个按钮同理，也是在点击的时候采取主动请求。<br>然后我们看一下浏览器控制台面板的 <code>preview</code> 看看本次的请求的文件内容到底是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">(self[<span class="hljs-string">"webpackChunkcheckWebpackBundled"</span>] =<br>  self[<span class="hljs-string">"webpackChunkcheckWebpackBundled"</span>] || []).push([<br>  [<span class="hljs-string">"src_buttonHi_js"</span>],<br>  &#123;<br>    <span class="hljs-comment">/***/</span> <span class="hljs-string">"./src/buttonHi.js"</span>:<br>      <span class="hljs-comment">/*!*************************!*\<br>  !*** ./src/buttonHi.js ***!<br>  \*************************/</span><br>      <span class="hljs-comment">/***/</span> (<br>        __unused_webpack_module,<br>        __webpack_exports__,<br>        __webpack_require__<br>      ) =&gt; &#123;<br>        <span class="hljs-string">"use strict"</span>;<br>        <span class="hljs-built_in">eval</span>(<br>          <span class="hljs-string">"__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;\n/* harmony export */   \"default\": () =&gt; __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ &#125;);\nconst a = 'button-hi!'\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (a);\n\n//# sourceURL=webpack://checkWebpackBundled/./src/buttonHi.js?"</span><br>        );<br><br>        <span class="hljs-comment">/***/</span><br>      &#125;<br>  &#125;<br>]);<br></code></pre></td></tr></table></figure><p>我们去查看打包后的文件发现这个 <code>webpackChunkcheckWebpackBundled</code> 是定义在一个叫做 <code>webpackJsonpCallback</code> 的方法中，而这个方法就是动态加载的核心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js">__webpack_require__.l = <span class="hljs-function">(<span class="hljs-params">url, done, key, chunkId</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (inProgress[url]) &#123;<br>    inProgress[url].push(done);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">var</span> script, needAttach;<br>  <span class="hljs-comment">// ......</span><br>  <span class="hljs-comment">// 动态创建script标签的常规操作</span><br>  <span class="hljs-keyword">if</span> (!script) &#123;<br>    needAttach = <span class="hljs-literal">true</span>;<br>    script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);<br><br>    script.charset = <span class="hljs-string">"utf-8"</span>;<br>    script.timeout = <span class="hljs-number">120</span>;<br>    <span class="hljs-keyword">if</span> (__webpack_require__.nc) &#123;<br>      script.setAttribute(<span class="hljs-string">"nonce"</span>, __webpack_require__.nc);<br>    &#125;<br>    script.setAttribute(<span class="hljs-string">"data-webpack"</span>, dataWebpackPrefix + key);<br>    script.src = url;<br>  &#125;<br>  inProgress[url] = [done];<br><br>  <span class="hljs-comment">// 一些错误处理</span><br>  <span class="hljs-keyword">var</span> onScriptComplete = <span class="hljs-function">(<span class="hljs-params">prev, event</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// avoid mem leaks in IE.</span><br>    script.onerror = script.onload = <span class="hljs-literal">null</span>;<br>    clearTimeout(timeout);<br>    <span class="hljs-keyword">var</span> doneFns = inProgress[url];<br>    <span class="hljs-keyword">delete</span> inProgress[url];<br>    script.parentNode &amp;&amp; script.parentNode.removeChild(script);<br>    doneFns &amp;&amp; doneFns.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(event));<br>    <span class="hljs-keyword">if</span> (prev) <span class="hljs-keyword">return</span> prev(event);<br>  &#125;;<br>  <span class="hljs-keyword">var</span> timeout = setTimeout(<br>    onScriptComplete.bind(<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"timeout"</span>, <span class="hljs-attr">target</span>: script &#125;),<br>    <span class="hljs-number">120000</span><br>  );<br>  script.onerror = onScriptComplete.bind(<span class="hljs-literal">null</span>, script.onerror);<br>  script.onload = onScriptComplete.bind(<span class="hljs-literal">null</span>, script.onload);<br>  <span class="hljs-comment">// 将生成的标签插入到head中</span><br>  needAttach &amp;&amp; <span class="hljs-built_in">document</span>.head.appendChild(script);<br>&#125;;<br></code></pre></td></tr></table></figure><p>除了这个我们还能发现<code>__webpack_require__.l</code>中有动态创建 <code>script</code> 标签，插入到 <code>head</code> 的操作，但是本次我们只能看到动态请求，并没发现动态创建 <code>script</code> 插入到 <code>head</code> 中的操作，接下来我们来构建一个单页面应用来查看和验证一下是不是只有在路由懒加载的时候才会如此触发。</p><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>路由懒加载我们使用 <code>react-cli</code> 来创建一个项目来验证以及看一下，路由加载的原理。</p><p>我们<code>npx create-react-app lazy-load-components</code>来创建一个 <code>react</code> 的项目，然后初始化之后的 <code>src</code> 文件目录应该是如下这样:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">|-- src</span><br>  <span class="hljs-string">|-- App.css</span><br>  <span class="hljs-string">|-- App.js</span><br>  <span class="hljs-string">|-- App.test.js</span><br>  <span class="hljs-string">|-- index.css</span><br>  <span class="hljs-string">|-- index.js</span><br>  <span class="hljs-string">|-- logo.svg</span><br>  <span class="hljs-string">|-- reportWebVitals.js</span><br>  <span class="hljs-string">|-- setupTests.js</span><br></code></pre></td></tr></table></figure><p>因为我们需要路由懒加载，所以需要手动安装一下 <code>react</code> 的路由，终端执行 <code>yarn add react-router-dom</code>，安装成功之后我们开始编写文件，我们在 <code>src</code> 下新建两个文件夹分别是 <code>components</code> 和 <code>utils</code>，在 <code>components</code> 下创建 <code>User.jsx</code> 和 <code>About.jsx</code> 并且在 <code>utils</code> 下创建 <code>index.js</code> 文件。最后的目录应该是:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">|<span class="hljs-string">-- src<br>  </span>|<span class="hljs-string">-- App.css<br>  </span>|<span class="hljs-string">-- App.js<br>  </span>|<span class="hljs-string">-- App.test.js<br>  </span>|<span class="hljs-string">-- index.css<br>  </span>|<span class="hljs-string">-- index.js<br>  </span>|<span class="hljs-string">-- logo.svg<br>  </span>|<span class="hljs-string">-- reportWebVitals.js<br>  </span>|<span class="hljs-string">-- setupTests.js<br>  </span>|<span class="hljs-string">-- components // 新增<br>  </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- About.jsx<br>  </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- User.jsx<br>  </span>|<span class="hljs-string">-- utils // 新增<br>      </span>|<span class="hljs-string">-- index.js</span><br></code></pre></td></tr></table></figure><p>接下来编写：<br><code>About.jsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">const</span> About = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>About 今天天气不错！<span class="hljs-tag">&lt;/&gt;</span>;<br>&#125;;<br>export default About;</span><br></code></pre></td></tr></table></figure><p><code>User.jsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">const</span> User = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>User 在干嘛？吃了吗？吃的啥？<span class="hljs-tag">&lt;/&gt;</span>;<br>&#125;;<br>export default User;</span><br></code></pre></td></tr></table></figure><p><code>utils -&gt; index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">const</span> Loading = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>loading<span class="hljs-tag">&lt;/&gt;</span>;<br>/**<br> * 实现路由分割<br> * 需要配合React.Suspense<br> * @param &#123;*&#125; components 传递一个方法，这个方法是动态导入的组件<br> */<br>export default function dynamic(components) &#123;<br>  const LazyComponents = React.lazy(components);<br>  return () =&gt; (<br>    <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loading</span> /&gt;</span>&#125;&gt;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">LazyComponents</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span><br>  );<br>&#125;</span><br></code></pre></td></tr></table></figure><p><code>src -&gt; index.js</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs diff">import React from 'react';<br>import './index.css';<br><span class="hljs-deletion">- import App from './App';</span><br>import reportWebVitals from './reportWebVitals';<br>import ReactDOM from 'react-dom';<br><span class="hljs-addition">+ import &#123; HashRouter, Link, Route &#125; from 'react-router-dom';</span><br><span class="hljs-addition">+ import dynamic from './utils'</span><br><span class="hljs-addition">+ const dynamicAbout = dynamic(() =&gt; import('./components/About'))</span><br><span class="hljs-addition">+ const dynamicUser = dynamic(() =&gt; import('./components/User'))</span><br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br><span class="hljs-deletion">-    &lt;App /&gt;</span><br><span class="hljs-addition">+    &lt;HashRouter&gt;</span><br><span class="hljs-addition">+      &lt;Link to="/"&gt;User页面&lt;/Link&gt;&lt;br/&gt;</span><br><span class="hljs-addition">+      &lt;Link to="/about"&gt;切换到About页面&lt;/Link&gt;&lt;br/&gt;</span><br><span class="hljs-addition">+      &lt;Route exact=&#123;true&#125; path="/" component=&#123;dynamicUser&#125;/&gt;</span><br><span class="hljs-addition">+      &lt;Route path="/about" component=&#123;dynamicAbout&#125; /&gt;</span><br><span class="hljs-addition">+    &lt;/HashRouter&gt;</span><br>  &lt;/React.StrictMode&gt;,<br>  document.getElementById('root')<br>);<br><br>// If you want to start measuring performance in your app, pass a function<br>// to log results (for example: reportWebVitals(console.log))<br>// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals<br>reportWebVitals();<br></code></pre></td></tr></table></figure><p>修改完成之后保存，我们在终端执行 <code>npm start</code>，自动打开页面，我们发现修改的内容已经生效了，这个时候我们来回忆一下，在开发环境下 <code>webpack</code> 会将打包的文件放在内存中，其实跟手动 <code>build</code> 以文件的方式区别不大，只是在内存中这样读取会很快，所以我们重新刷新一下页面，加载的时候查看一下浏览器的 <code>network</code> 面板，发现加载了很多文件，我们能发现其中 <code>3.chunk.js</code> 就是我们的首页也就是 <code>User.js</code>，里面的逻辑就是一个 <code>webpackJsonp</code> 加载对应的 <code>chunk</code> 文件，再下边是一些热模块更新的内容。然后现在我们切换一下面板到 <code>Elements</code>，到 <code>head</code> 下查看一下，发现此时的 <code>script</code> 只有 <code>3.chunk.js</code> 也就是 <code>User.js</code>。<br><img src="../../../../images/initChunk.png" srcset="/img/loading.gif" alt="初始化加载"></p><p>我们切换路由到 <code>about</code> 页面，再来观察，发现页面 <code>network</code> 加载了我们对应的组件，并且 <code>Elements</code> 的 <code>head</code> 中增加了一个 <code>script</code> 标签，其 <code>src</code> 就是我们刚刚看到的 <code>2.chunk.js</code> 也就说，在我们切换路由的时候浏览器去下载了对用的文件，并将其插入到 <code>head</code> 中，从而实现我们在路由切换完成之后，看到了对应组件或者页面的显示。所以这就验证了我们第一步里的代码分析动态加载 <code>script</code> 的那块。<br><img src="../../../../images/%E5%8A%A0%E8%BD%BDabout%E7%BB%84%E4%BB%B6.jpg" srcset="/img/loading.gif" alt="切换路由的时候network下载的chunk"><br><img src="../../../../images/%E5%8A%A0%E8%BD%BDaboutScript%E5%88%B0head%E4%B8%AD.jpg" srcset="/img/loading.gif" alt="切换路由的时候动态加载的script脚本"></p><p>总结：所以至此我们大概能够清楚浏览器是如何加载我们 <code>webpack</code> 打包后的文件，流程大概应该是：<code>webpack</code> 将文件最终都打包成为<code>webpack_modules</code>的一个互相依赖的 <code>kay:value</code> 的一个映射，最外层是 <code>webpackBootstrap</code> 的一个 <code>IIFE</code>，<code>IIFE</code> 的最下边开始执行<code>webpack_require(&quot;./src/main.js&quot;)</code>也就是执行入口文件，因为已经形成了依赖，所以在执行对应文件的时候会按照我们代码编写的预期执行，至于动态加载的时候，动态加载方法只是在触发对应的事件的时候才会执行逻辑，而路由的懒加载则是，在切换路由之后，浏览器会发起一个对应的 <code>chunk</code> 的请求，将这个请求的文件下载成功之后，通过动态创建 <code>script</code> 的形式插入到 <code>head</code> 标签中，从而实现动态加载。</p><h2 id="HMR-热模块更新机制"><a href="#HMR-热模块更新机制" class="headerlink" title="HMR 热模块更新机制"></a>HMR 热模块更新机制</h2><p>我们能够在刚刚的截图中发现，在初始化的时候有一个 <code>ws://localhost:3000/sockjs-node</code> 的请求，那这个东西是干嘛的呢？其实这就是热模块更新的重要的机制。<br><img src="../../../../images/%E7%83%AD%E6%9B%B4%E6%96%B0%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" alt="初始化加载热模块更新的一些资源"></p><p>我们先修改一下 <code>About</code> 组件的内容：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff">import React from 'react'<br>const About = () =&gt; &#123;<br>  return &lt;&gt;<br>    关于用户的一些信息哈<br><span class="hljs-addition">+    &lt;h1&gt;这是一个标题&lt;/h1&gt;</span><br>  &lt;/&gt;<br>&#125;<br>export default About<br></code></pre></td></tr></table></figure><p>保存之后，发现页面自动更新了并且 <code>network</code> 自动加载了两个文件一个是 <code>json</code> 文件一个是 <code>js</code> 文件，我们来看看这些东西是什么。<br><img src="../../../../images/%E7%94%9F%E6%88%90json-js%E6%96%87%E4%BB%B6.jpg" srcset="/img/loading.gif" alt="第一次热更新加载的文件"></p><p>我们发现，在我们初始化的 <code>ws</code> 里接受的 <code>data</code> 的是一个 <code>205487be9270982f923b</code> 的 <code>hash</code> 值，在我们修改文件保存之后，热模块自动更新的时候，会生成一个 <code>205487be9270982f923b.hot-update.json</code> 和<code>[chunkId].205487be9270982f923b.hot-update.js</code> 的文件，这个 <code>json</code> 文件返回了一个 <code>e3ab8e66727600303a2d</code> 的 <code>hash</code> 是用于连接下次热更新的于本次类似的加载操作，而 <code>js</code> 文件则是热模块更新重新打包的需要执行的文件内容，同样我们切换到 <code>Elements</code> 能够发现，热模块更新的时候下载的文件也是被直接插入到 <code>head</code> 标签中的从而实现 <code>script</code> 的实时替换和页面自动刷新。<br><img src="../../../../images/hot-load-add-script.jpg" srcset="/img/loading.gif" alt="热模块更新插入脚本"></p><p>总结：热模块更新的机制大致是和懒加载的逻辑相同，只不过其在初始化时候，开启了一个 <code>ws</code> 的请求，当修改文件修改的时候，<code>webpack</code> 会监听文件的变动，<code>ws</code> 接受 <code>hash</code> 作为下一次热更新的文件请求，因为在初始化和每一次修改之后都会生成下一次热更新的一个需求请求文件的 <code>hash</code>，所以在修改文件之后，浏览器会根据上一次的热模块生成的 <code>hash</code> 来下载下一次的更新的 <code>js</code>，浏览器下载完成热更新打包的 <code>js</code> 之后再如同懒加载一样，动态创建 <code>script</code> 脚本插入到 <code>head</code> 标签中，实现自动更新页面。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始手写一个简单的 loader（二）</title>
    <link href="/2021/01/26/markdown-to-html-loader-optimization/"/>
    <url>/2021/01/26/markdown-to-html-loader-optimization/</url>
    
    <content type="html"><![CDATA[<p>这是关于 <code>webpack</code> 的一些扩展。</p><p><a href="https://tennesseesunshine.github.io/2021/01/25/markdownToHtmlLoader/" target="_blank" rel="noopener">从零开始手写一个简单的 loader（一）</a> 里面已经生成了 <code>html</code> 字符串并且渲染到了页面。但是我们发现其样式无美感，那这一期我们增加一些样式，将生成的 <code>html</code> 渲染的像咱们博客中的那样。</p><p>首先我们需要的 <code>loader</code> 是 <code>css-loader</code> 和 <code>style-loader</code>，我们开始安装这两个依赖。<br><code>css-loader</code> 用于将 <code>css</code> 可以模块化的引入，并将其转换为 <code>js</code> 代码，<code>style-loader</code> 用于将上一步生成的 <code>js</code> 中包含的 <code>css</code>，生成可用的样式并且，通过生成 <code>style</code> 标签插入到 <code>head</code> 标签中。</p><ul><li>安装依赖</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cnpm install --<span class="hljs-built_in">save</span>-dev css-loader <span class="hljs-built_in">style</span>-loader<br></code></pre></td></tr></table></figure><p>我们接着来配置 <code>webpack.config.js</code> 文件，在 <code>module</code> 的 <code>rules</code> 里再加上一个匹配项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">rules: [<br>  &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>    <span class="hljs-attr">use</span>: [<br>      <span class="hljs-string">'./loader/md2html-loader.js'</span><br>    ]<br>  &#125;,<br>+  &#123;<br>+    test: <span class="hljs-regexp">/\.css$/</span>,<br>+    use: [<br>+      <span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span><br>+    ]<br>+  &#125;<br>]<br></code></pre></td></tr></table></figure><ul><li>创建 <code>css</code> 文件</li></ul><p>紧接着我们在 <code>src</code> 下创建一个 <code>index.css</code> 文件，添加如下 <code>css</code> 样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pre</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#282c34</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">24px</span>;<br>  <span class="hljs-attribute">text-align</span>: left;<br>  <span class="hljs-attribute">font-family</span>: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid transparent;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">overflow-x</span>: auto;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">13px</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">white-space</span>: pre;<br>  <span class="hljs-attribute">word-spacing</span>: normal;<br>  <span class="hljs-attribute">word-break</span>: normal;<br>  <span class="hljs-attribute">word-wrap</span>: normal;<br>&#125;<br><br><span class="hljs-selector-tag">pre</span> <span class="hljs-selector-tag">code</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">code</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0.2em</span> <span class="hljs-number">0.4em</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">85%</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(27, 31, 35, 0.05);<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>  <span class="hljs-attribute">color</span>: palevioletred;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>引入样式文件</li></ul><p>然后我们回到 <code>main.js</code> 里将 <code>index.css</code> 引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">"./index.css"</span>;<br></code></pre></td></tr></table></figure><p>现在我们再去终端运行 <code>npx webpack</code>，再刷新页面，发现生成的 <code>html</code> 已经被我们加上了样式。</p><p><img src="../../../../images/rander-html.png" srcset="/img/loading.gif" alt="最终渲染的页面"></p><p>截至目前我们已经完成了一个可以生成 <code>html</code> 的 <code>loader</code>，并且已经为其加上了样式。</p><p>我们目前用的是 <code>style-loader</code> 是将生成的 <code>css</code> 通过 <code>style</code> 的方式插入到 <code>head</code> 标签中。其实我们还有一种办法，将 <code>css</code> 提取出来，作为单个文件通过 <code>link</code> 标签加载。话不多说，我们继续。</p><ul><li>提取 <code>css</code></li></ul><p>要提取 <code>css</code> 样式文件，<code>webpack4.0</code> 之后用的插件叫: <code>mini-css-extract-plugin</code><br>我们来安装这个插件:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cnpm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p>因为 <code>style-loader</code> 和 <code>mini-css-extract-plugin</code> 插件不能共存，所以我们需要删除 <code>webpack</code> 中之前配置的 <code>style-loader</code>，添加 <code>mini-css-extract-plugin</code>，具体修改如下：</p><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">+ <span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);<br><br><span class="hljs-built_in">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        <span class="hljs-string">'./loader/md2html-loader.js'</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>+        MiniCssExtractPlugin.loader, <span class="hljs-string">'css-loader'</span><br>      ]<br>    &#125;<br>  ]<br>&#125;,<br><span class="hljs-attr">plugins</span>: [<br>  <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>  <span class="hljs-keyword">new</span> HtmlWebpackPlugin(),<br>+  <span class="hljs-keyword">new</span> MiniCssExtractPlugin()<br>]<br></code></pre></td></tr></table></figure><p>我们再去终端运行 <code>npx webpack</code>，刷新页面发现样式没改变再去看开发人员选项，发现样式文件目前是通过 <code>link</code> 标签引入的，证明我们的提取 <code>css</code> 配置是生效的。</p><p><img src="../../../../images/link-element.jpg" srcset="/img/loading.gif" alt="控制台标签元素"></p><p>至此，我们一个简单的 <code>loader</code> 就全部完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始手写一个简单的 loader（一）</title>
    <link href="/2021/01/25/markdown-to-html-loader/"/>
    <url>/2021/01/25/markdown-to-html-loader/</url>
    
    <content type="html"><![CDATA[<p>重学 <code>webpack</code> 之后，对 <code>webpack</code> 的理解又上了一个层次，<code>webpack</code> 的 <code>loader</code> 作为其一个非常重要的链路，能用自定义的 <code>loader</code> 来处理日常工作中遇到的问题俨然已经成为了一个前端工程师的基本素养，所以最基本的要求就是能够手写自定义的 <code>loader</code>。</p><p><code>webpack</code> 自身只能够处理 <code>JS</code> 和 <code>JSON</code> 文件，而作为非此二者的其他文件，<code>webpack</code> 也是支持其作为模块通过 <code>import、export、export.default</code> 等，所以在对这些文件处理的时候，就需要对应的一些 <code>loader</code> 来解析，例如在项目中使用 <code>sass</code>，那肯定是不能缺少解析 <code>sass</code> 的 <code>loader</code>。使用 <code>ts</code> 少不了 <code>ts-loader</code> 等等。</p><p>而且 <code>loader</code> 在 <code>webpack</code> 中是可以进行串联调用，从其从后往前或者从右往左的顺序可以知道，<code>webpack</code> 采用的是 <code>compose</code> 的方式来在下一个 <code>loader</code> 中结合上一个 <code>loader</code> 处理完的结果。其实在这种串联组合中的 <code>loader</code> 并不一定要返回 <code>JS</code> 代码。只要下游的 <code>loader</code> 能有效处理上游 <code>loader</code> 的输出，那么上游的 <code>loader</code> 可以返回任意类型的模块。</p><p>今天的任务是写一个，将 <code>markdown</code> 转为 <code>html</code> 的 <code>loader</code>。</p><h2 id="依赖分析"><a href="#依赖分析" class="headerlink" title="依赖分析"></a>依赖分析</h2><p>先分析一下构建这些， <code>webpack</code> 工具需要哪些东西，首先肯定需要 <code>webpack</code> 和 <code>webpack-cli</code> 作为最基础的依赖，然后需要 <code>marked</code> 将 <code>md</code> 文件转为 <code>html</code>，而且即便很简单的 <code>loader</code>，我们仍然需要一个 <code>CleanWebpackPlugin</code> 和 <code>HtmlWebpackPlugin</code> 作为在打包之前和成功之后最底层的支持，一个用于清除打包结果，一个用于生成打包后的 <code>html</code> 文件。所以我们汇总一下需要安装的几个依赖，分别是：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-bullet">- </span>webpack<br><span class="hljs-bullet">- </span>webpack-cli<br><span class="hljs-bullet">- </span>marked<br><span class="hljs-bullet">- </span>CleanWebpackPlugin<br><span class="hljs-bullet">- </span>HtmlWebpackPlugin<br></code></pre></td></tr></table></figure><h2 id="创建对应的文件夹、文件"><a href="#创建对应的文件夹、文件" class="headerlink" title="创建对应的文件夹、文件"></a>创建对应的文件夹、文件</h2><p>首先我们需要利用 <code>npm</code> 自动生成一个 <code>package.json</code> 文件：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure><p>紧接着，我们在根目录下创建一个 <code>src</code> 文件夹、<code>loader</code> 文件夹以及其子文件 <code>md2html-loader.js</code> 和 <code>webpack.config.js</code> 文件，并且在 <code>src</code> 下创建 <code>index.md、main.js</code>，成功之后我们的文件夹目录应该是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">+ src<br>  - index<span class="hljs-selector-class">.md</span><br>  - main<span class="hljs-selector-class">.js</span><br>+ loader<br>  - md2html-loader<span class="hljs-selector-class">.js</span><br>- package<span class="hljs-selector-class">.json</span><br>- webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>我们利用 <code>cnpm</code> 一次性将所需要的依赖全部安装完成。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cnpm install --<span class="hljs-keyword">save</span>-dev html-webpack-<span class="hljs-keyword">plugin</span> webpack webpack-<span class="hljs-keyword">cli</span> marked clean-webpack-<span class="hljs-keyword">plugin</span><br></code></pre></td></tr></table></figure><p>我们看看下载成功之后的依赖分别都是什么版本。发现 <code>clean-webpack-plugin</code> 是 <code>3.0.0</code>，在使用的时候我们需要解构出构造函数从而实例化，否则 <code>webpack</code> 会抛出<code>TypeError: CleanWebpackPlugin is not a constructor</code>的错误。</p><ul><li><code>package.json</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">"devDependencies": &#123;<br>  "clean-webpack-plugin": "^3.0.0",<br>  "html-webpack-plugin": "^4.5.1",<br>  "marked": "^1.2.7",<br>  "webpack": "^5.17.0",<br>  "webpack-cli": "^4.4.0"<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h2><ul><li><code>index.md</code></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment"># 今天是 2021 年，开始认真工作的一天</span><br><br>这是一个段落<br><br>- 这是第一项<br>- 这是第二项<br><br>这是一段落`code`<br><br>const <span class="hljs-keyword">a</span> = <span class="hljs-string">'webpack-demo'</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'a'</span>, <span class="hljs-keyword">a</span>)<br></code></pre></td></tr></table></figure><ul><li><code>main.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> md <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.md"</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"md"</span>, md);<br></code></pre></td></tr></table></figure><ul><li><code>md2html-loader.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"source"</span>, source);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">"source"</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>webpack.config.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<br><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"clean-webpack-plugin"</span>);<br><br><span class="hljs-comment">// 增加Configuration是为了配置的key提示</span><br><span class="hljs-comment">/**<br> * @type &#123;webpack.Configuration&#125;<br> */</span><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">"./src/main.js"</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">"bundle.js"</span>,<br>    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">"dist"</span>)<br>  &#125;,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">"./loader/md2html-loader.js"</span>]<br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> CleanWebpackPlugin(), <span class="hljs-keyword">new</span> HtmlWebpackPlugin()]<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = config;<br></code></pre></td></tr></table></figure><p>在终端输入 <code>npx webpack</code> 之后运行，我们能够发现，打印出了我们 <code>loader</code>文件里打印的 <code>source</code> 的内容，如下：</p><hr><p>source # 今天是 2021 年，开始认真工作的一天</p><p>这是一个段落</p><ul><li>这是第一项</li><li>这是第二项</li></ul><p>这是一段落<code>code</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const <span class="hljs-keyword">a</span> = <span class="hljs-string">'webpack-demo'</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'a'</span>, <span class="hljs-keyword">a</span>)<br></code></pre></td></tr></table></figure><hr><p>从这里我们能发现，其实 <code>loader</code> 接受的参数就是我们 <code>md</code> 文件的内容，所以我们需要将 <code>md</code> 文件转换为 <code>html</code>，就需要使用 <code>marked</code> 方法，继续编写 <code>loader</code> 文件，引入 <code>marked</code>，处理完成 <code>md</code> 文件之后，我们再将处理的文件组成文件内容导出。</p><ul><li><code>md2html-loader.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">"marked"</span>);<br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> html = marked(source);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"html"</span>, html);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(html)&#125;</span>`</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们再去执行，<code>npx webpack</code> 发现终端打印的输出为一段 <code>html</code> 字符串，这就是 <code>md</code> 文件被转换为 <code>html</code>：</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">html <span class="hljs-variable">&lt;h1 id="今天是-2021-年，开始认真工作的一天"&gt;</span>今天是 2021 年，开始认真工作的一天<span class="hljs-variable">&lt;/h1&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一个段落<span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;ul&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第一项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第二项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;/ul&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一段落<span class="hljs-variable">&lt;code&gt;</span>code<span class="hljs-variable">&lt;/code&gt;</span><span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;pre&gt;</span><span class="hljs-variable">&lt;code&gt;</span>const a = &amp;<span class="hljs-comment">#39;webpack-demo&amp;#39;</span><br>console.log(&amp;<span class="hljs-comment">#39;a&amp;#39;, a)&lt;/code&gt;&lt;/pre&gt;</span><br></code></pre></td></tr></table></figure><hr><p>然后我们再打开 <code>dist</code> 目录下的 <code>index.html</code> 查看页面，<code>F12</code> 打开控制台发现浏览器控制台打印出了以下内容：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">md <span class="hljs-variable">&lt;h1 id="今天是-2021-年，开始认真工作的一天"&gt;</span>今天是 2021 年，开始认真工作的一天<span class="hljs-variable">&lt;/h1&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一个段落<span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;ul&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第一项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第二项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;/ul&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一段落<span class="hljs-variable">&lt;code&gt;</span>code<span class="hljs-variable">&lt;/code&gt;</span><span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;pre&gt;</span><span class="hljs-variable">&lt;code&gt;</span>const a = &amp;<span class="hljs-comment">#39;webpack-demo&amp;#39;</span><br>console.log(&amp;<span class="hljs-comment">#39;a&amp;#39;, a)&lt;/code&gt;&lt;/pre&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器控制台的内容就是我们 <code>main.js</code> 里打印的内容，至此，说明我们的模块已经生效，<code>md</code> 转为 <code>html</code> 也已经生效，并且当我们看到这个字符串的时候其实就已经明白怎么显示到页面上了。</p><p>于是我们继续编写 <code>main.js</code>将 html 字符串渲染到页面上：</p><ul><li><code>main.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> md <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.md"</span>;<br><span class="hljs-comment">// console.log("md", md);</span><br><span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);<br>ele.innerHTML = md;<br><span class="hljs-built_in">document</span>.body.appendChild(ele);<br></code></pre></td></tr></table></figure><p>继续运行，<code>npx webpack</code>，然后我们刷新刚刚的页面，发现生成的 <code>html</code> 字符串已经被我们渲染到页面上了。</p><p>至此一个 <code>md</code> 转换为 <code>html</code> 并且显示在页面的简单 <code>loader</code> 已经完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pipe 和 compose 在 JavaScript 中的应用</title>
    <link href="/2021/01/17/pipe-compose/"/>
    <url>/2021/01/17/pipe-compose/</url>
    
    <content type="html"><![CDATA[<p>函数式编程的中从左往右的 <code>pipe</code> 函数和从右往左的 <code>compose</code> 函数，在 <code>js</code> 中的一些应用场景。</p><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>也称为管道函数，它接受 <code>n</code> 多个函数，依次从左往右执行，用最后一个函数作为最终的输出。用于改善函数嵌套调用，一个简单的示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`我是第一个函数，我获取我的参数「<span class="hljs-subst">$&#123;params&#125;</span>」并且返回`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`我接受了第一个函数的返回值「<span class="hljs-subst">$&#123;params&#125;</span>」，作为我的参数，然后和我的数据拼接再返回`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`我是最后的数据的拼接处理，结合了first函数和second的返回值「<span class="hljs-subst">$&#123;params&#125;</span>」`</span><br>&#125;<br><br>end(second(first(<span class="hljs-string">`hi～我来了！💐`</span>)))<br></code></pre></td></tr></table></figure><p>最终返回： “我是最后的数据的拼接处理，结合了 <code>first</code> 函数和 <code>second</code> 的返回值「我接受了第一个函数的返回值「我是第一个函数，我获取我的参数「<code>hi</code> ～我来了！💐」并且返回」，作为我的参数，然后和我的数据拼接再返回」”</p><p>能看到的是，函数之间形成一种关系，即后一个函数接受上一个函数的返回值作为参数，本例中也就是 <code>end</code> 函数接受 <code>second</code> 的返回值作为参数，而 <code>second</code> 的返回值又是接受 <code>first</code> 的返回值作为参数。</p><p>其实能看到 <code>end(second(first()))</code>这么调用嵌套不直观，我们用<code>reduce</code>实现管道 <code>pipe</code> 依次调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> pipe = <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> arg.reduce(<span class="hljs-function">(<span class="hljs-params">res, callback</span>) =&gt;</span> callback(res), result)<br></code></pre></td></tr></table></figure><p>调用 <code>pipe(first, second, end)(&#39;hi ～我来了！💐&#39;)</code>，会将参数先传递给 <code>first</code>，然后处理成功之后，再将结果作为 <code>second</code> 的参数，传递，<code>second</code> 处理完成之后，将结果作为 <code>end</code> 函数的参数，在 <code>end</code> 函数处理完成之后，将所有结果返回。最终 <code>pipe</code> 函数调用的结果，将会上边函数嵌套执行的结果一致。</p><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>组合函数和 <code>pipe</code> 原理都是一样的，只不过是其调用顺序是从右往左。</p><p>组合函数在 <code>webpack</code> 的 <code>loader</code> 中也有应用，本例中的 <code>pipe</code> 是从左往右依次执行，<code>webpack</code> 的 <code>loader</code> 是从右向左执行（<code>compose）</code>，其实可以利用 <code>reduceRight</code> 实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> compose = <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> arg.reduceRight(<span class="hljs-function">(<span class="hljs-params">res, callback</span>) =&gt;</span> callback(res), result)<br></code></pre></td></tr></table></figure><p>这里的话，如果上述的例子是通过 <code>compose</code> 函数来实现的话，应该是 <code>compose(first, second, end)(&#39;hi ～我来了！💐&#39;)</code>，最外边的参数应该先是给 <code>end</code> 函数，处理完成之后再给 <code>second</code>，最终给 <code>first</code>，由 <code>first</code> 处理，最终返回结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果一个数据最终结果，是需要经过很多函数的处理，并且那些函数，需要用上一个函数的返回值作为下一个函数的参数，这种场景下可以考虑使用 <code>pipe</code> 或者 <code>compose</code> 函数来处理，其实使用 <code>pipe</code> 或者 <code>compose</code> 都是可以的，只需要保证传入的函数的顺序是按照数据正确执行的函数顺序即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce高级函数的一些应用</title>
    <link href="/2021/01/15/js-reduce-function/"/>
    <url>/2021/01/15/js-reduce-function/</url>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>在最近的工作中，<code>reduce</code> 成为了出境率和使用率非常高的一个高阶函数，所以总结一下工作中以及 <code>reduce</code> 可能会实现的一些功能。</p><p>先简单说一下 <code>reduce</code> 函数，它的语法为 <code>Array.reduce(callback, [initialValue])</code>，接受的参数是：</p><ul><li>第一个参数为一个回调函数，其回调函数接受四个参数分别为初始值（或者上次的回调函数的返回值）、当前元素、当前索引、原数组。</li><li>第二个参数 <code>initialValue</code> 为可选，如果传递，则 <code>initialValue</code> 作为第一次回调函数的第一个参数。</li></ul><p>需要记住的点是：如果为 <code>reduce</code> 提供 <code>initialValue</code> 参数，则回调函数会从索引为 <code>0</code> 的地方开始执行 <code>callback</code>，否则会从索引为 <code>1</code> 的地方开始执行。</p><p>我们可以用个 <code>demo</code> 验证一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- 无初始化参数 --&gt;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>]<br>arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur, idx</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(pre, cur, <span class="hljs-string">'看索引开始:'</span>, idx)<br>  <span class="hljs-keyword">return</span> pre + cur<br>&#125;)<br><br><span class="hljs-comment">// 9 19 "看索引开始:" 1</span><br><span class="hljs-comment">// 28 20 "看索引开始:" 2</span><br><span class="hljs-comment">// 48</span><br><br>&lt;!-- 有初始化参数 --&gt;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">9</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>]<br>arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur, idx</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(pre, cur, <span class="hljs-string">'看索引开始:'</span>, idx)<br>  <span class="hljs-keyword">return</span> pre + cur<br>&#125;, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment">// 0 9 "看索引开始:" 0</span><br><span class="hljs-comment">// 9 19 "看索引开始:" 1</span><br><span class="hljs-comment">// 28 20 "看索引开始:" 2</span><br><span class="hljs-comment">// 48</span><br></code></pre></td></tr></table></figure><h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><ul><li>简单数组求和</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> pre + cur, <span class="hljs-number">0</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><ul><li>复杂一点的，数组对象中的数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> list = [<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">'苹果'</span>,<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">20</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">'香蕉'</span>,<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">40</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">'猕猴桃'</span>,<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">90</span>,<br>  &#125;<br>]<br>list.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> pre + cur.count, <span class="hljs-number">0</span>) <span class="hljs-comment">// 150</span><br></code></pre></td></tr></table></figure><h3 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h3><p>利用 <code>{}</code> 对象来判断是否能取到当前值，获取不到则表示当前元素没有，设置次数为 <code>1</code>，有则次数递增。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">'aabcddeffghhijklllm'</span><br>str.split(<span class="hljs-string">''</span>).reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> &#123;<br>  pre[cur] ? pre[cur]++ : pre[cur] = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> pre<br>&#125;, &#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>利用 <code>includes</code> 判断上次累加的数组中是否具有当前值，没有的话就将当前值和上次的返回值连接起来返回，有的话直接返回上一次的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]<br>arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> !pre.includes(cur) ? [...pre, ...[cur]] : pre, [])<br></code></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><ul><li>二维简单数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>]]<br>arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> [...pre, ...cur], [])<br><span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><ul><li>复杂的高纬度数组</li></ul><p>利用递归扁平深层嵌套的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]]], [<span class="hljs-number">3</span>, [[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>], [<span class="hljs-number">8</span>, <span class="hljs-number">1</span>]]], [<span class="hljs-number">5</span>, [[<span class="hljs-number">5</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]]]]<br><span class="hljs-keyword">var</span> flat = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre, cur</span>) =&gt;</span> [...pre, ...(<span class="hljs-built_in">Array</span>.isArray(cur) ? flat(cur) : [cur])], [])<br>flat(arr)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6, 3, 7, 8, 8, 1, 5, 5, 4, 9, 10]</span><br></code></pre></td></tr></table></figure><p><code>ES6</code> 的解决办法：<br>使用数组的 <code>flat</code> 方法，语法 <code>arr.flat([depth])</code>，<code>depth</code> 参数为深度，不传参数默认扁平 <code>1</code> 级嵌套，可以输入关键字 <code>Infinity</code> 实现任何层数嵌套的扁平。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个简单的 vue 中的 EventBus</title>
    <link href="/2021/01/14/concis-event-bus/"/>
    <url>/2021/01/14/concis-event-bus/</url>
    
    <content type="html"><![CDATA[<p>先分析一下 <code>vue</code> 中的一些用法</p><h3 id="on-注册"><a href="#on-注册" class="headerlink" title="on 注册"></a><code>on</code> 注册</h3><ul><li><code>this.$on(&#39;eventName&#39;, (...params) =&gt; {})</code><br>其实我们在使用的过程中可以发现，<code>$on</code>的事件可以注册多次，也就是说可以在很多组件里进行一个事件的注册，在<code>$emit</code> 触发相应的事件的时候，对应注册的所有事件都会执行回调函数，所以我们能想到它的实现一定是，如果在一个对象中，注册了相同的事件，会一直往当前的这个事件数组的集合中追加回调函数。</li></ul><h3 id="emit触发"><a href="#emit触发" class="headerlink" title="emit触发"></a><code>emit</code>触发</h3><ul><li><code>this.$emit(&#39;eventName&#39;, params)</code><br>上一步提到，<code>$emit</code> 的时候，相应注册的事件都会执行回调函数，而且 <code>on</code> 注册的是一个数组，所以其实现应该是遍历 <code>emit</code> 事件所对应的数组，依次执行 <code>callback</code> 并且将参数传递出去。</li></ul><h3 id="once-一次触发"><a href="#once-一次触发" class="headerlink" title="once 一次触发"></a><code>once</code> 一次触发</h3><ul><li><code>this.$once(&#39;eventName&#39;, (...params) =&gt; {})</code><br>触发一次，它的实现应该是无需判断之前事件有没有注册，要是注册直接放进去，也就是说，注册相同的事件后者会覆盖掉前者，注册新的会增加。</li></ul><h3 id="off移除"><a href="#off移除" class="headerlink" title="off移除"></a><code>off</code>移除</h3><ul><li><code>this.$off(&#39;eventName)</code><br><code>off</code> 也很简单，就是直接用对象上删掉当前的事件。</li></ul><p>在 <code>vue2.0</code> 的 <code>SFC</code> 中，<code>this</code> 指向是 <code>new Vue()</code>的实例 <code>vm</code>，因为其上实例上已经具有 <code>eventBus</code> 的方法，所以可以使用。</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> EventBus = &#123;<br>  <span class="hljs-attr">taskMap</span>: &#123;&#125;,<br>  $on(eventName, fn) &#123;<br>    &lt;!-- 如果map中无注册事件，则将事件推入，如果有注册的事件，继续往里追加 --&gt;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.taskMap[eventName]) &#123;<br>      <span class="hljs-keyword">this</span>.taskMap[eventName] = [fn]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">this</span>.taskMap[eventName].push(fn)<br>    &#125;<br>  &#125;,<br>  $emit(eventName, ...msg) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.taskMap[eventName]) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      &lt;!-- 遍历注册过的事件，依次执行 --&gt;<br>      <span class="hljs-keyword">this</span>.taskMap[eventName].forEach(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> callback(...msg))<br>    &#125;<br>  &#125;,<br>  $once(eventName, fn) &#123;<br>    &lt;!-- 不需要判断，后来的覆盖前边的 --&gt;<br>    <span class="hljs-keyword">this</span>.taskMap[eventName] = [fn]<br>  &#125;,<br>  $off(eventName) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.taskMap[eventName]) &#123;<br>      <span class="hljs-keyword">return</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      &lt;!-- 删掉注册的事件 --&gt;<br>      <span class="hljs-built_in">Reflect</span>.deleteProperty(<span class="hljs-keyword">this</span>.taskMap, [eventName])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注册</span><br>EventBus.$on(<span class="hljs-string">'begin'</span>, (...x) =&gt; &#123;<span class="hljs-built_in">console</span>.log(...x)&#125;)<br>EventBus.$off(<span class="hljs-string">'begin'</span>)<br>EventBus.$emit(<span class="hljs-string">'begin'</span>, <span class="hljs-string">'参数1000000'</span>, <span class="hljs-string">'参数2'</span>) <span class="hljs-comment">// 不会触发</span><br>EventBus.$once(<span class="hljs-string">'begin'</span>, (...x) =&gt; &#123;<span class="hljs-built_in">console</span>.log(x)&#125;)<br>EventBus.$emit(<span class="hljs-string">'begin'</span>, <span class="hljs-string">'🍅'</span>, <span class="hljs-string">'🍉'</span>) <span class="hljs-comment">// 触发一次once ["🍅", "🍉"]</span><br>EventBus.$off(<span class="hljs-string">'begin'</span>)<br><br>EventBus.$on(<span class="hljs-string">'begin'</span>, (...x) =&gt; &#123;<span class="hljs-built_in">console</span>.log(...x, <span class="hljs-string">'1'</span>)&#125;)<br>EventBus.$on(<span class="hljs-string">'begin'</span>, (...x) =&gt; &#123;<span class="hljs-built_in">console</span>.log(...x, <span class="hljs-string">'2'</span>)&#125;)<br>EventBus.$emit(<span class="hljs-string">'begin'</span>, <span class="hljs-string">'🏃‍♀️'</span>, <span class="hljs-string">'🚢'</span>) <span class="hljs-comment">// 触发2次on 🏃‍♀️，🚢，1  🏃‍♀️，🚢，2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨深组件传递数据和调用方法</title>
    <link href="/2021/01/03/use-context/"/>
    <url>/2021/01/03/use-context/</url>
    
    <content type="html"><![CDATA[<p>在父子组件传递数据的时候，<code>react</code> 最常用的</p><h4 id="传统简单的组件通信方式"><a href="#传统简单的组件通信方式" class="headerlink" title="传统简单的组件通信方式"></a>传统简单的组件通信方式</h4><ul><li>父组件 —&gt; 子组件 <code>props</code></li><li>子组件 —&gt; 父组件 <code>callback</code><br>但是有一些特殊的情况，比如是嵌套比较深的组件，<code>A—&gt;B—&gt;C—&gt;D</code> 嵌套，一旦这种结果使用 <code>props</code> 传递数据，就会显得组件非常臃肿，而 <code>react</code> 有提供方式来解决，即 <code>useContext</code></li></ul><h4 id="嵌套深的组件的通信"><a href="#嵌套深的组件的通信" class="headerlink" title="嵌套深的组件的通信"></a>嵌套深的组件的通信</h4><ul><li><code>React.createContext</code></li><li><code>useContext</code></li></ul><p>假如现在有依赖关系的，组件 <code>A-&gt;B-&gt;C</code>，<code>useContext</code> 使用小结:</p><p>可以全局维护一个 <code>context.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 利用 React.CreateContext api 创建一个带有默认值的context</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CreateContextData = React.createContext(<span class="hljs-string">''</span>)<br></code></pre></td></tr></table></figure><p><code>A.jsx</code><br>必须要使用 <code>Provider</code> 并且将数据以 <code>value</code> 的形式传递下去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const A = () =&gt; &#123;<br>  const text = &apos;react&apos;<br>  return (<br>    &lt;CreateContextData.Provider value=&#123;text&#125;&gt;<br>      &lt;B /&gt;<br>    &lt;/CreateContextData.Provider&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>B.jsx</code><br>中间组件不用在意 <code>A</code> 往下传递的参数和数据是什么，其只需要保证 <code>B</code> 和 <code>C</code> 的接口稳定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx">const B = () =&gt; &#123;<br>  return (<br>    &lt;div&gt;<br>      &lt;div&gt;大纲&lt;/div&gt;<br>      &lt;C/&gt;<br>    &lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>C.jsx</code><br>通过获取全局创建的 <code>context</code> 对象来获取 <code>A</code> 组件的通信数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx">import &#123; CreateContextData &#125; from &apos;./context.js&apos;<br><br>const C = () =&gt; &#123;<br>  // 通过useContext获取context的数据 一定要传入创建的上下文实例 否则获取不到数据<br>  const initText = useContext(CreateContextData)<br>  return (&lt;&gt;我正在学习&#123;initText&#125;&lt;/&gt;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果嵌套的组件，子组件中也有 <code>provider</code> 提供，则按照最近的取值，一般正常的使用方式就是最顶层组件增加 <code>provider</code></p><p>每次创建的的上下文实例，都需要导出，所以可以用统一的文件管理这种创建的上下文，最后 <code>export</code> 以及在需要的地方 <code>import</code></p><p>透传不仅仅可以是 <code>state</code>，还可以是父组件的方法，在深层组件获取之后，可以直接修改父组件数据</p><p>调用了 <code>useContext</code> 的组件总会在 <code>context</code> 值变化时重新渲染，如果组件渲染开销太大，可以使用 <code>useMome</code> 包装一下</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次关于node中间层处理的文件上传</title>
    <link href="/2021/01/01/upload-file/"/>
    <url>/2021/01/01/upload-file/</url>
    
    <content type="html"><![CDATA[<p>公司项目的架构是 <code>umi</code> —&gt;  <code>nodejs</code> —&gt; <code>api</code></p><p>在最近一次的需求中，有一个批量上传的功能，大体的交互是：在 <code>excel</code> 里先填写好数据，<code>web</code> 通过上传文件来在页面表格里预览，然后再将 <code>excel</code> 文件绑定一些表单的数据一起打包发送给后台，有点类似于表单中嵌套了文件上传，最后再提交表单。</p><h4 id="一些想法和对交互的调整"><a href="#一些想法和对交互的调整" class="headerlink" title="一些想法和对交互的调整"></a>一些想法和对交互的调整</h4><p>最初的页面设计是放在步骤条里一共分为三步。上传在步骤条的第一步，表单在第二步，<code>ant-design</code> 的步骤条在切换上下步骤之后，上一个组件的 <code>dom</code> 会销毁，导致第二步无法获取到第一步在上传的时候生成的文件对象，也就无法上传文件。于是后来调整页面，将表单和上传文件放在一个页面，这样在解析文件成功之后，在当前这一步里就能一直获取到文件的对象，拿到文件对象就可以向接口发起请求。</p><h4 id="未使用-ant-design-上传组件的原因"><a href="#未使用-ant-design-上传组件的原因" class="headerlink" title="未使用 ant-design 上传组件的原因"></a>未使用 <code>ant-design</code> 上传组件的原因</h4><p><code>ant-design</code> 的 <code>Upload</code> 组件上传之后的文件对象会立马返回，但是前端无法将这个对象一直拿着在提交的时候再给接口，因为文件对象的一些 <code>key</code> 不能拷贝过去【也是这次才发现只有 <code>uid</code> 一个字段可以遍历】，而且在通过 <code>document.getElementById(&#39;file&#39;).files</code> 获取上传的文件对，其 <code>FileList</code> 是 <code>{length: 0}</code>，所以后来选择利用原生 <code>input</code> 来解决问题，通过创建 <code>ref</code> 将 <code>input</code> 的 <code>dom</code> 属性存起来，然后将 <code>ref</code> 获取的属性返回到父组件，在父组件里提交的时候，获取 <code>ref</code> 中的文件对象，传递给接口。</p><h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><ul><li>创建 <code>ref</code> 对象来存储 <code>input</code> <code>dom</code> 属性</li><li>初始化利用 <code>addEventListener</code> 来监听原生 <code>input</code> 的 <code>change</code> 事件</li><li>利用 <code>button</code> 覆盖默认的上传样式，点击 <code>button</code> 的时候模拟触发点击 <code>input</code> 上传</li><li>捕获到事件之后，成功获取到文件对象，依次将文件对象传递给 <code>xlsx</code> 来解析为 <code>json</code> 数据，再将 <code>json</code> 数据传递给 <code>and-table</code> 来显示预览、将 <code>input</code> 的 <code>ref</code> 属性值回传到父组件（<code>handleFileInputRefs</code> 方法是父组件传递的 <code>props</code> 来获取自组件的 <code>input ref</code>）</li><li>父组件中也已经接受了表单的数据，并且接受了 <code>input</code> 的属性，通过 <code>FormData</code> 将数据和文件混传给 <code>node</code> 的 <code>controller</code></li><li><code>controller</code> 获取到文件对象和额外的表单参数，再向真正的接口发起请求</li></ul><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>子组件 <code>paresExcel.tsx</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> ONE_M_TO_BYTES: number = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">const</span> MAX_FILE_SIZE: number = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 初始化定义ref来存储input dom对象，这个对象里的files对象可以一直获取到</span><br><span class="hljs-keyword">const</span> uploadInput = useRef(<span class="hljs-literal">null</span>);<br><br><span class="hljs-comment">/**<br> * 获取column的对象key，数组转对象<br> * tableColumnKey 是父组件传递回来的table的json，类似<br> *<br> * [&#123;<br> *    title: '关键词',<br> *    dataIndex: 'word',<br> *    key: 'word',<br> *  &#125;,<br> *  &#123;<br> *    title: '豁免词',<br> *    dataIndex: 'exWord',<br> *    key: 'exWord',<br> *  &#125;]<br> */</span><br><span class="hljs-keyword">const</span> formatTitleOrFileld = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> entozh = tableColumnKey.map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      index,<br>      <span class="hljs-attr">key</span>: item.key,<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> entozh;<br>&#125;;<br><br><span class="hljs-comment">/**<br> * 这个方法其实就是将数据转为表格可以用的json<br> */</span><br><span class="hljs-keyword">const</span> handleImpotedJson = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [header, ...tableBody] = jsonArr;<br>  <span class="hljs-keyword">const</span> keysArr = formatTitleOrFileld();<br>  <span class="hljs-keyword">const</span> len = header.length;<br><br>  <span class="hljs-comment">// 稀疏数组补全empty项，因为excel中有的数据是空，解析出来的数据是索引不连续的，这一步的目的就是补全index</span><br>  tableBody.forEach(<span class="hljs-function">(<span class="hljs-params">item: any</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= len - <span class="hljs-number">1</span>; i++) &#123;<br>      item[i] = item[i] || <span class="hljs-string">''</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-comment">/**<br>   * 将解析的excel数据转换为ant-table支持渲染的数据格式<br>   */</span><br>  <span class="hljs-keyword">const</span> parsedExcelData = tableBody.map(<span class="hljs-function">(<span class="hljs-params">ele: any</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> newitem = &#123;&#125;;<br>    ele.forEach(<span class="hljs-function">(<span class="hljs-params">im: any, i: number</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> newKey = keysArr[i].key;<br>      newitem[newKey] = im;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> newitem;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">/**<br> * 上传文件的方法，主要做一些文件大小的判断、文件的读取将excel的数据转换为json<br> * 这里有一个比较重要的方法是，解析完成的json数据，实际上是没有key的<br> * 表格在展示的时候需要key对应上，value才会在表格里显示，所以需要调方法处理一下<br> */</span><br><span class="hljs-keyword">const</span> beforeUpload = <span class="hljs-function">(<span class="hljs-params">file: any</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (file.size / ONE_M_TO_BYTES &gt; MAX_FILE_SIZE) &#123;<br><br>    message.warning(<span class="hljs-string">'请上传小于10M的文件！'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    <span class="hljs-keyword">const</span> f = file;<br>    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();<br><br>    reader.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;<br>      <span class="hljs-keyword">const</span> datas = e?.target?.result;<br>      <span class="hljs-comment">// 解析datas</span><br>      <span class="hljs-keyword">const</span> workbook = XLSX.read(datas, &#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">'binary'</span>,<br>      &#125;);<br><br>      <span class="hljs-comment">// 是工作簿中的工作表的有序列表</span><br>      <span class="hljs-keyword">const</span> first_worksheet = workbook.Sheets[workbook.SheetNames[<span class="hljs-number">0</span>]];<br>      <span class="hljs-comment">// 将工作簿对象转换为JSON对象数组</span><br>      <span class="hljs-keyword">const</span> jsonArr = XLSX.utils.sheet_to_json(first_worksheet, &#123; <span class="hljs-attr">header</span>: <span class="hljs-number">1</span> &#125;);<br><br>      handleImpotedJson(jsonArr);<br>    &#125;;<br><br>    reader.readAsBinaryString(f);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在事件监听文件的change的回调函数中，获取到文件对象之后调用方法来将excel数据解析为json</span><br><span class="hljs-keyword">const</span> handleUpload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  beforeUpload(uploadInput?.current?.files[<span class="hljs-number">0</span>]);<br>&#125;;<br><br><span class="hljs-comment">// 点击按钮的时候，触发input的上传click事件</span><br><span class="hljs-keyword">const</span> handleFakeUpload = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  uploadInput?.current?.click();<br>&#125;;<br><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>) &#123;<br>    <span class="hljs-comment">/**<br>      * 监听input上传事件 在得到文件流之后 把input的ref回传到父组件<br>      * 并且解析文件转为json来在表格里显示<br>      */</span><br>    <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`[name=uploadExcel]`</span>)!.addEventListener(<span class="hljs-string">'change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (event?.target &amp;&amp; event?.target?.files) &#123;<br>        handleFileInputRefs &amp;&amp; handleFileInputRefs(uploadInput);<br>        handleUpload();<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;, []);<br><br><span class="hljs-keyword">return</span> (<br>  &lt;div className="fix-input-button"&gt;<br>    &lt;input type="file" name="uploadExcel" ref=&#123;uploadInput&#125; /&gt;<br>    &lt;Button icon=&#123;&lt;Iconfont name="iconshangchuan" /&gt;&#125; onClick=&#123;handleFakeUpload&#125;&gt;<br>      上传<br>    &lt;/Button&gt;<br>  &lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// uploadRefs 是useState定义的保存ref的变量</span><br><br><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();<br><br>formData.append(<span class="hljs-string">'fileStream'</span>, uploadRefs?.current?.files[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 接口还需要一些别的参数</span><br>formData.append(<span class="hljs-string">'connectBusiness'</span>, <span class="hljs-built_in">JSON</span>.stringify(connectBusiness));<br><span class="hljs-comment">/**<br>  * 这里不能设置请求头<br>  * 浏览器检测到后自己加上 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXXXx 这样<br>  */</span><br>setIsLoading(<span class="hljs-literal">true</span>)<br>fetch(<span class="hljs-string">'/api/appName/parseExcelUpload'</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,<br>  <span class="hljs-attr">body</span>: formData,<br>&#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'err'</span>, err);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    setIsLoading(<span class="hljs-literal">false</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><h5 id="node-层"><a href="#node-层" class="headerlink" title="node 层"></a><code>node</code> 层</h5><p><code>node</code> 用的是 <code>thinkjs</code>，<code>controller</code> 其实很简单，包装一下然后请求真正的接口避免直接调接口跨域</p><p>伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Base = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../base'</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);<br><br><span class="hljs-keyword">const</span> UPLOAD_SERVICE = <span class="hljs-string">'http://xxx'</span>;<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br><br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> parseExcelUploadAction() &#123;<br><br>    <span class="hljs-comment">// 获取文件信息</span><br>    <span class="hljs-keyword">const</span> files = <span class="hljs-keyword">this</span>.file(<span class="hljs-string">'fileStream'</span>);<br><br>    <span class="hljs-comment">// 利用request发起请求</span><br>    <span class="hljs-keyword">var</span> req = request.post(UPLOAD_SERVICE, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, resp, body</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">this</span>.json(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-string">'failed'</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">`上传失败，url:<span class="hljs-subst">$&#123;UPLOAD_SERVICE&#125;</span>`</span><br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.json(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-string">'success'</span>,<br>          <span class="hljs-attr">data</span>: body<br>        &#125;)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'返回请求'</span> + body);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">var</span> form = req.form();<br><br>    <span class="hljs-comment">// request上传文件的时候需要append一些stream和string</span><br>    <span class="hljs-comment">// node也会自己获取前端上传发起请求的头 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXXXx</span><br>    form.append(<span class="hljs-string">'file'</span>, fs.createReadStream(files.path), &#123;<br>      <span class="hljs-attr">filename</span>: files.name,<br>      <span class="hljs-attr">contentType</span>: <span class="hljs-string">'application/vnd.ms-excel'</span><br>    &#125;);<br><br>    form.append(<span class="hljs-string">'connectBusiness'</span>, <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.post(<span class="hljs-string">'connectBusiness'</span>)));<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>至此通过 <code>node</code> 中间层来上传的一个功能实现了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>umi 中使用 iconfont</title>
    <link href="/2020/12/21/umi-use-iconfont/"/>
    <url>/2020/12/21/umi-use-iconfont/</url>
    
    <content type="html"><![CDATA[<p><code>ant-design</code> 自带的 <code>icon</code> 种类太少，遂找替代方案 <code>iconfont</code>。</p><p>首先需要创建一个函数组件，使其接受一个名为 <code>name</code> 或者 <code>type</code> 的参数，用来指定当前渲染的 <code>icon</code> 名称。</p><p><code>Iconfont.tsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'./index.less'</span>;<br><br>interface IconfontProps &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  className?: string;<br>&#125;<br><br><span class="hljs-keyword">const</span> Iconfont: React.FC&lt;IconfontProps&gt; = <span class="hljs-function">(<span class="hljs-params">&#123; name, className = <span class="hljs-string">''</span> &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">icon</span> $&#123;<span class="hljs-attr">className</span>&#125;`&#125; <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlinkHref</span>=<span class="hljs-string">&#123;</span>`#$&#123;<span class="hljs-attr">name</span>&#125;`&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Iconfont;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;!<span class="hljs-selector-tag">--</span> 这其中的样式根据项目调整 <span class="hljs-selector-tag">--</span>&gt;<br><span class="hljs-selector-class">.icon</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">22px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">22px</span>;<br>  <span class="hljs-attribute">vertical-align</span>: -<span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">fill</span>: currentColor;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Umi.rc</code>中配置在 <code>iconfont</code> 中生成的静态资源地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">plugins: [<br>  scripts: [<br>    &#123;<br>      <span class="hljs-attr">src</span>: <span class="hljs-string">`//at.alicdn.com/t/font_xxx_jxx.js`</span>,<br>    &#125;<br>  ]<br>]<br></code></pre></td></tr></table></figure><p><code>tsx</code> 中使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Iconfont <span class="hljs-keyword">from</span> <span class="hljs-string">'Iconfont'</span><br><br>&lt;Iconfont name=<span class="hljs-string">"xxx"</span>/&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>momentjs 一键切换为 dayjs</title>
    <link href="/2020/12/21/replace-moment-to-dayjs/"/>
    <url>/2020/12/21/replace-moment-to-dayjs/</url>
    
    <content type="html"><![CDATA[<p>公司 <code>umi</code> 创建的项目中，时间的处理使用的是 <code>momentjs</code>，组件用的 <code>ant-design</code>，而且 <code>ant-design</code> 的日期底层的时间处理也是用的 <code>moment</code>。项目一次打包成功之后发现 <code>moment</code> 占的体积比较大，于是考虑下将 <code>moment</code> 切换为比较小的 <code>dayjs</code>。</p><p><code>.umirc.ts</code> 的默认配置中是支持不将 <code>locale</code> 文件打包进去的，但是需要配置 <code>ignoreMomentLocale:true</code> 来开启，但是虽然开启之后仍然还是有 <code>54kb</code> 左右的大小，于是考虑将其换做 <code>dayjs</code>，具体的是利用 <code>antd-dayjs-webpack-plugin</code> 插件，此插件是已经将 <code>moment</code> 替换为 <code>dayjs</code>，之前项目里写的 <code>import moment from &#39;moment&#39;</code>，可以继续使用，虽然引入的是 <code>moment</code>，但其实引用的是 <code>dayjs</code>，这是因为这个插件的底层 <code>alias</code> 了名称。所以在 <code>dayjs</code> 不支持的一些地方，需要利用 <code>dayjs</code> 的扩展方法来增加，例如我的项目中使用了 <code>utc</code>，所以需要在 <code>global.ts</code> 里先<br><code>var utc = require(&#39;dayjs/plugin/utc&#39;)</code> 引入 <code>dayjs</code> 的 <code>utc</code> 插件，再<code>dayjs.extend(utc)</code> 拓展，使用就可以了。</p><p>而 <code>.umirc.ts</code> 具体的配置，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> AntdDayjsWebpackPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">'antd-dayjs-webpack-plugin'</span>;<br><br>chainWebpack(config) &#123;<br>  config.plugin(<span class="hljs-string">'dayjs'</span>).use(AntdDayjsWebpackPlugin);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于 <code>ignoreMomentLocale:true</code> 的原理应该是使用的 <code>webpack</code> 的 <code>ContextReplacementPlugin</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">chainWebpack(config) &#123;<br>  <span class="hljs-comment">//过滤掉 momnet 的那些不使用的国际化文件 只选择zh-cn</span><br>  config<br>    .plugin(<span class="hljs-string">'replace'</span>)<br>    .use(<span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>).ContextReplacementPlugin)<br>    .tap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-regexp">/moment[\/\\]locale$/</span>, /zh-cn/];<br>  &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 工具类型使用总结</title>
    <link href="/2020/11/22/typeScript-use/"/>
    <url>/2020/11/22/typeScript-use/</url>
    
    <content type="html"><![CDATA[<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> IMyInfo &#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: <span class="hljs-built_in">number</span><br>  address: <span class="hljs-built_in">string</span><br>  money: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> BasicSelect = <span class="hljs-string">'name'</span> | <span class="hljs-string">'age'</span><br></code></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a><code>keyof</code></h3><ul><li>该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</li><li>例如：</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> koT = keyof IMyInfo<br><br><span class="hljs-comment">// type koT = "name" | "age" | "address" | "money"</span><br></code></pre></td></tr></table></figure><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h3><ul><li><code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> naBasicT = <span class="hljs-string">'name'</span> | <span class="hljs-string">'age'</span><br><br><span class="hljs-comment">// 从T中选择出K的类型作为当前变量的类型</span><br><span class="hljs-keyword">const</span> naData: Pick&lt;IMyInfo, naBasicT&gt;  = &#123;<br>  name: <span class="hljs-string">'sss'</span>,<br>  age: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">type</span> naT = <span class="hljs-keyword">typeof</span> naData<br><br><span class="hljs-comment">// 等价于 </span><br><span class="hljs-comment">// type naT = &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><ul><li>遍历枚举类型或判断在不在某一个类型中</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Keys = <span class="hljs-string">"a"</span> | <span class="hljs-string">"b"</span> | <span class="hljs-string">"c"</span><br><br><span class="hljs-keyword">type</span> Obj =  &#123;<br>  [P <span class="hljs-keyword">in</span> Keys]: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-comment">// &#123; a: string, b: string, c: string &#125;</span><br></code></pre></td></tr></table></figure><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a><code>extends</code></h3><ul><li>理解为约束比较好</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Len = &#123;<br>  length: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-comment">// 利用Len类型来约束T使其具有length的类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLen</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Len</span>&gt; (<span class="hljs-params">arg: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arg.length<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a><code>Pick</code></h3><ul><li><code>Pick&lt;T, K&gt;</code> <code>K</code>可以是一个联合类型 从泛型<code>T</code>中过滤出<code>K</code>联合的类型，第一个参数是基准，第二个参数是需要选择出来的类型的联合，或者单个类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> pickT = Pick&lt;IMyInfo, BasicSelect&gt;<br><br><span class="hljs-comment">// 等价于 type nameT = &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a><code>Partial</code></h3><ul><li><code>Partial&lt;T&gt;</code> 将<code>T</code>都变为可选类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> partialT = Partial&lt;IMyInfo&gt;<br></code></pre></td></tr></table></figure><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a><code>Required</code></h3><ul><li><code>Required&lt;T&gt;</code> 将传入的泛型变为必选项</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> requiredT = Required&lt;partialT&gt;<br></code></pre></td></tr></table></figure><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a><code>Readonly</code></h3><ul><li><code>Readonly&lt;T&gt;</code> 将泛型变为 <code>readonly</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> readonlyT = Readonly&lt;IMyInfo&gt;<br></code></pre></td></tr></table></figure><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a><code>Record</code></h3><ul><li><code>Record&lt;K, T&gt;</code> 将<code>T</code>的类型赋给每一个<code>K</code></li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> recodeT = Record&lt;BasicSelect, IMyInfo&gt;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-comment">// type recodeT = &#123;</span><br><span class="hljs-comment">//   name: IMyInfo;</span><br><span class="hljs-comment">//   age: IMyInfo;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="Exclude、Extract"><a href="#Exclude、Extract" class="headerlink" title="Exclude、Extract"></a><code>Exclude</code>、<code>Extract</code></h3><ul><li><code>Exclude&lt;T, U&gt;</code> 其中 <code>T</code>，<code>U</code> 比较，排除<code>U</code>和<code>T</code>中共有，返回<code>T</code>中剩下的 返回的是第一个泛型 第一个作为基准</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T1 = <span class="hljs-string">'a'</span> | <span class="hljs-string">'b'</span> | <span class="hljs-string">'c'</span> | <span class="hljs-string">'m'</span><br><span class="hljs-keyword">type</span> T2 = <span class="hljs-string">'b'</span> | <span class="hljs-string">'c'</span> | <span class="hljs-string">'d'</span><br><br><span class="hljs-keyword">type</span> excludeT = Exclude&lt;T1, T2&gt;<br><span class="hljs-comment">// 等价于 type excludeT = "a"</span><br><br><span class="hljs-keyword">type</span> extractT = Extract&lt;T1, T2&gt;<br><span class="hljs-comment">// 等价于 type extractT = "b" | "c"</span><br></code></pre></td></tr></table></figure><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a><code>Omit</code></h3><ul><li><code>Omit&lt;T, K&gt;</code> 跟<code>Pick</code>类似，但是功能相反 从<code>T</code>中排除掉<code>K</code>的类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> omitT = Omit&lt;IMyInfo, <span class="hljs-string">'age'</span>&gt;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-comment">// type omitT = &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   address: string;</span><br><span class="hljs-comment">//   money: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a><code>ReturnType</code></h3><ul><li>从函数的返回值中提取类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userinfo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    age: <span class="hljs-number">25</span>,<br>    name: <span class="hljs-string">'jack'</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> ObjT = ReturnType&lt;<span class="hljs-keyword">typeof</span> userinfo&gt;<br><br><span class="hljs-comment">// 等同于 type ObjT = &#123;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a><code>Parameters</code></h3><ul><li>从函数的参数中提取出需要的类型</li></ul><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 定义的参数类型是 string, number</span><br><span class="hljs-keyword">type</span> fnT = &#123;<br>  (name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>): &#123;<br>    breif: <span class="hljs-built_in">string</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> TParams = Parameters&lt;fnT&gt;<br><span class="hljs-comment">// type TParams = [string, number]</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInfo</span> (<span class="hljs-params">name: TParams[0], age: TParams[1]</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 2.X 两个不同的运行版本</title>
    <link href="/2020/11/08/vue-version/"/>
    <url>/2020/11/08/vue-version/</url>
    
    <content type="html"><![CDATA[<h2 id="Runtime-Only"><a href="#Runtime-Only" class="headerlink" title="Runtime Only"></a><code>Runtime Only</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br>  router,<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>说明：<code>vue-loader + webpack</code>，会在构建的时候将<code>*.vue</code>打包为静态资源文件，最终的文件是已经被预编译之后的静态浏览器可以识别的资源，也是不需要编译器的可以直接运行的，即只有运行时。</li></ul><h2 id="Runtime-Compiler"><a href="#Runtime-Compiler" class="headerlink" title="Runtime + Compiler"></a><code>Runtime + Compiler</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,<br>  router,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">'&lt;App/&gt;'</span>,<br>  <span class="hljs-attr">components</span>: &#123; App &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>运行时+编译器，在<code>vue-loader + webpack</code>构建的时候，是不会进行编译的，在浏览器运行的时候进行编译。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两种常见的设置锚点的方法</title>
    <link href="/2020/11/06/anchor-setting/"/>
    <url>/2020/11/06/anchor-setting/</url>
    
    <content type="html"><![CDATA[<p>概述：在潜意识里使用最多的应该就是<code>a</code>标签配合其他标签的<code>id</code>属性去做页面锚点跳转，然而在有<code>prompt</code>并且路由在变化的时候会导致一些问题。因为在设置了<code>prompt</code>有数据的话会做离开页面数据不保存或者结束任务的提示逻辑，但是这个<code>prompt</code>又是基于路由的变化来确定有没有触发，所以在使用传统的方法增加锚点的时候<code>url</code>后会追加哈希值导致触发了<code>url</code>变动，<code>prompt</code>没法简单判断出来目前是因为什么事件触发，从而导致在点击锚点的时候触发了<code>prompt</code>提示。正好最近学习了<code>scrollIntoView</code>就正好想着尝试解决一下。</p><ul><li><h2 id="传统的方法利用a标签和id"><a href="#传统的方法利用a标签和id" class="headerlink" title="传统的方法利用a标签和id"></a>传统的方法利用<code>a</code>标签和<code>id</code></h2></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">// 设置，用户点击并跳转<br>&lt;a href="#anchorId"&gt;锚点1&lt;/a&gt;<br><br>// 待跳转标识的位置，使用id<br>&lt;div id="anchorId"&gt;跳转到锚点1&lt;/div&gt;<br><br>在点击 “跳转到锚点1” 的时候就会在url中加入哈希从而实现锚点跳转<br></code></pre></td></tr></table></figure><ul><li><h2 id="利用浏览器h5的新api-scrollIntoView来解决"><a href="#利用浏览器h5的新api-scrollIntoView来解决" class="headerlink" title="利用浏览器h5的新api scrollIntoView来解决"></a>利用浏览器<code>h5</code>的新<code>api scrollIntoView</code>来解决</h2><ul><li>语法说明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.scrollIntoView(); <span class="hljs-comment">// 等同于element.scrollIntoView(true)</span><br>element.scrollIntoView(alignToTop); <span class="hljs-comment">// Boolean型参数</span><br>element.scrollIntoView(scrollIntoViewOptions); <span class="hljs-comment">// Object型参数</span><br></code></pre></td></tr></table></figure><ul><li><p>参数说明</p><ul><li><p><code>alignToTop</code>可选，一个<code>Boolean</code>值：</p><ul><li>如果为<code>true</code>，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的 <code>scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}</code>。这是这个参数的默认值。</li><li>如果为<code>false</code>，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的<code>scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest”}</code>。</li></ul></li><li><p><code>scrollIntoViewOptions</code> 可选 一个包含下列属性的对象：</p><ul><li><code>behavior</code> 可选 定义动画过渡效果， <code>auto</code>或 <code>smooth</code> 之一。默认为 <code>auto</code>。</li><li><code>block</code> 可选 定义垂直方向的对齐， <code>start</code>, <code>center</code>, <code>end</code>, 或 <code>nearest</code>之一。默认为 <code>start</code>。</li><li><code>inline</code> 可选 定义水平方向的对齐， <code>start</code>, <code>center</code>, <code>end</code>, 或 <code>nearest</code>之一。默认为 <code>nearest</code>。</li></ul></li></ul></li><li><p>伪代码</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 因为有兼容问题，所以需要用第三方包来处理一下兼容</span><br><span class="hljs-keyword">import</span> smoothscroll <span class="hljs-keyword">from</span> <span class="hljs-string">'smoothscroll-polyfill'</span>;<br>smoothscroll.polyfill();<br><br><span class="hljs-comment">// 在render之前为需要锚点的元素增加data-xxx属性，在触发对应的事件，需要锚点到对应的位置的时候利用api跳转，如果是数组循环下来的结构的话可以将对应的id传递给函数，点击的时候获取对应的元素并且再去执行操作</span><br><br><span class="hljs-keyword">const</span> scrollToAnchor = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 利用属性选择器 + querySelector</span><br>  <span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`[data-imageId=<span class="hljs-subst">$&#123;id&#125;</span>]`</span>)<br>  <span class="hljs-keyword">if</span> (ele) &#123;<br>    ele.scrollIntoView(&#123;<span class="hljs-attr">block</span>: <span class="hljs-string">'start'</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'smooth'</span>&#125;)<br>  &#125;<br>&#125;<br><br>&lt;img data-imageId=<span class="hljs-string">"img1"</span> /&gt;<br>&lt;div onClick=&#123;() =&gt; scrollToAnchor('img1')&#125;&gt;跳转&lt;div/&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>h5-api</tag>
      
      <tag>scrollIntoView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生实现浏览器支持的图片懒加载方案</title>
    <link href="/2020/11/05/lazy-load/"/>
    <url>/2020/11/05/lazy-load/</url>
    
    <content type="html"><![CDATA[<p>概述：因为内部项目运营工具中有遇到处理大量图片在一瞬间请求的场景，在开发阶段遇到了如果不处理图片，不用懒加载的话，浏览器会在一瞬间造成卡顿，用户体验和效果非常差。</p><p>解决方案</p><ul><li><h3 id="未调研的-React-三方懒加载库"><a href="#未调研的-React-三方懒加载库" class="headerlink" title="未调研的 React 三方懒加载库"></a>未调研的 <code>React</code> 三方懒加载库</h3></li><li><h3 id="img-图片的属性-loading"><a href="#img-图片的属性-loading" class="headerlink" title="img 图片的属性 loading"></a><code>img</code> 图片的属性 <code>loading</code></h3><p>因为项目采用的是 <code>umi+ts</code>，而 <code>img</code> 属性的 <code>loading</code> 并未标准化，还处在实验阶段，但是 <code>Chrome 76+</code> 已经支持。代码中直接在 <code>jsx</code> 中为<code>img</code> 标签加上 <code>loading=&quot;lazy&quot;</code> 属性之后会报错，是因为 <code>ts</code> 的类型中 <code>img</code> 不存在 <code>loading</code> 的属性，解决办法是声明一个类型文件，将需要设置的标签属性继承到 <code>HTML</code> 属性就好了，别的标签也类似。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// react-unstable-attributes.d.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"react"</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">module</span> "react" &#123;<br>  <span class="hljs-keyword">interface</span> ImgHTMLAttributes&lt;T&gt; <span class="hljs-keyword">extends</span> HTMLAttributes&lt;T&gt; &#123;<br>    loading?: <span class="hljs-string">"auto"</span> | <span class="hljs-string">"eager"</span> | <span class="hljs-string">"lazy"</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 参数</span><br>lazy：延迟加载。<br>eager：立即加载。<br>auto：由浏览器来决定是否延迟加载。<br></code></pre></td></tr></table></figure><p>但是在直接为图片加了 <code>loading</code> 属性之后并没有实现懒加载，后来在调试的时候意外为图片加了 <code>width</code> 尺寸之后发现竟然生效了，或许在真实场景之下还需要微调。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">loading</span>=<span class="hljs-string">"lazy"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"90px"</span> /&gt;</span><br></code></pre></td></tr></table></figure><p><code>loading=&quot;lazy&quot;</code> 的属性对于别的浏览器的兼容一般，可以利用 <code>js</code> 判断，不支持 <code>loading</code> 的话使用<code>IntersectionObserver</code>优雅降级。<a href="https://juejin.im/post/6844903830581149710" target="_blank" rel="noopener">可参考</a></p></li><li><h3 id="h5-IntersectionObserver-api"><a href="#h5-IntersectionObserver-api" class="headerlink" title="h5 IntersectionObserver api"></a><code>h5 IntersectionObserver api</code></h3><p><code>IntersectionObserver</code> 提供了一种异步检测目标元素与祖先元素或 <code>viewport</code> 相交情况变化的方法。它会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时(或者 视口 )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。这样，我们网站的主线程不需要再为了监听元素相交而辛苦劳作，浏览器会自行优化元素相交管理。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">摘自 MDN</a></p><p>兼容的 <code>folyfill intersection-observer</code></p><p>伪代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 注册一个回调函数 满足条件的时候自动执行为图片src赋值</span><br><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">changes</span>) </span>&#123;<br>  changes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, index</span>) </span>&#123;<br><br>    <span class="hljs-comment">// 当这个值大于0，说明满足我们的加载条件了，这个值可通过rootMargin手动设置</span><br>    <span class="hljs-keyword">if</span> (element.intersectionRatio &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 设置图片src属性来加载</span><br>      element.target.src = element.target.dataset.src;<br><br>      <span class="hljs-comment">// 放弃监听，防止性能浪费。</span><br>      observer.unobserve(element.target);<br>    &#125;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initObserver</span>(<span class="hljs-params"></span>) </span>&#123;<br>  [...document.querySelectorAll(<span class="hljs-string">'.list-item-img'</span>)].forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对每个list元素进行监听</span><br>    observer.observe(item);<br>  &#125;);<br>&#125;<br><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  initObserver()<br>&#125;, [])<br><br><span class="hljs-comment">// jsx</span><br>&lt;img <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"list-item-img"</span> data-src=<span class="hljs-string">"1.png"</span>/&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item-img"</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">"2.png"</span>/&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>h5-api</tag>
      
      <tag>IntersectionObserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlab-ci.yml文件的一些总结</title>
    <link href="/2020/10/24/gitlab-ci/"/>
    <url>/2020/10/24/gitlab-ci/</url>
    
    <content type="html"><![CDATA[<h2 id="基础抽象概念"><a href="#基础抽象概念" class="headerlink" title="基础抽象概念"></a>基础抽象概念</h2><ul><li><h3 id="runner"><a href="#runner" class="headerlink" title="runner"></a><code>runner</code></h3>用来执行软件集成脚本的东西，<code>runner</code> 的机器是需要能够通过网络访问 <code>GitLab</code> 服务器<ul><li><code>Shared Runner</code> 场景：所有的工程都有可能需要在公司的服务器上进行编译、测试、部署等工作，这个时候注册一个<code>Shared Runner</code>供所有工程使用就很合适</li><li><code>Specific Runner</code> 场景：个人的电脑或者服务器上自动构建我参与的某个工程，这个时候注册一个 <code>Specific Runner</code> 就很合适</li></ul></li><li><h3 id="pipleline"><a href="#pipleline" class="headerlink" title="pipleline"></a><code>pipleline</code></h3>一整个工作流</li><li><h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a><code>stage</code></h3>一整个工作流是由于多个 <code>stage</code> 组成<ul><li>如果两个任务对应的 <code>stage</code> 名相同，则这两个任务会并行运行</li><li>下一个 <code>stage</code> 关联的任务会等待上一个 <code>stage</code> 执行成功后才继续运行，失败则不运行</li></ul></li><li><h3 id="job"><a href="#job" class="headerlink" title="job"></a><code>job</code></h3>每一个 <code>stage</code> 由至少一个 <code>Job</code> 组成</li><li><h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3>镜像 指定一个任务 <code>（job）</code> 所使用的 <code>docker</code> 镜像</li><li><h3 id="only-except"><a href="#only-except" class="headerlink" title="only / except"></a><code>only / except</code></h3>当符合定义的策略时才会触发 <code>Pipelines</code> 的执行，<code>except</code> 则相反。</li><li><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a><code>variables</code></h3>定义变量</li></ul><h2 id="gitlab-ci-yml-示例说明"><a href="#gitlab-ci-yml-示例说明" class="headerlink" title=".gitlab-ci.yml 示例说明"></a><code>.gitlab-ci.yml</code> 示例说明</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">stages:</span><br>  <span class="hljs-comment">#- 先定义几个阶段 在yml加载完成之后就会在pipeline里出现三个stages stage的名称是下边开始的最前边的名称【name1、name2、name3】</span><br><span class="hljs-bullet">  -</span> <span class="hljs-string">assemble</span><br><span class="hljs-bullet">  -</span> <span class="hljs-string">deploy</span><br><span class="hljs-bullet">  -</span> <span class="hljs-string">success</span><br><br>  <span class="hljs-comment">#- stage的名称</span><br><span class="hljs-attr">name1:</span><br>  <span class="hljs-comment">#- 对应第一个需要处理的阶段</span><br><span class="hljs-attr">  stage:</span> <span class="hljs-string">assemble</span><br>  <span class="hljs-comment">#- 需要在assemble的时候运行的脚本 `linux` 的命令</span><br><span class="hljs-attr">  script:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">ls</span> <span class="hljs-bullet">-la</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">rm</span> <span class="hljs-bullet">-rf</span> <span class="hljs-string">node_module</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">pwd</span><br><span class="hljs-attr">name2:</span><br><span class="hljs-attr">  stage:</span> <span class="hljs-string">deploy</span><br>  <span class="hljs-comment">#- 依赖项目</span><br><span class="hljs-attr">  dependencies:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">name1</span><br>  <span class="hljs-comment">#- 需要在deploy的时候运行的脚本</span><br><span class="hljs-attr">  script:</span><br><br><span class="hljs-attr">name3:</span><br><span class="hljs-attr">  stage:</span> <span class="hljs-string">success</span><br>  <span class="hljs-comment">#- 依赖项目</span><br><span class="hljs-attr">  dependencies:</span><br><span class="hljs-bullet">    -</span> <span class="hljs-string">name2</span><br>  <span class="hljs-comment">#- 需要在success的时候运行的脚本</span><br><span class="hljs-attr">  script:</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gitlab-ci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中下载的一些总结</title>
    <link href="/2020/10/21/browser-download/"/>
    <url>/2020/10/21/browser-download/</url>
    
    <content type="html"><![CDATA[<h1 id="通过-http-请求返回的-json-数据，如何下载到本地作为调试的-mock-数据？"><a href="#通过-http-请求返回的-json-数据，如何下载到本地作为调试的-mock-数据？" class="headerlink" title="通过 http 请求返回的 json 数据，如何下载到本地作为调试的 mock 数据？"></a>通过 <code>http</code> 请求返回的 <code>json</code> 数据，如何下载到本地作为调试的 <code>mock</code> 数据？</h1><h2 id="二进制文件等部分涉及"><a href="#二进制文件等部分涉及" class="headerlink" title="二进制文件等部分涉及"></a>二进制文件等部分涉及</h2><h3 id="浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多Blob，DataURL，Base64-，ObjectURL"><a href="#浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多Blob，DataURL，Base64-，ObjectURL" class="headerlink" title="浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多Blob，DataURL，Base64 ，ObjectURL"></a>浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多<code>Blob，DataURL，Base64 ，ObjectURL</code></h3><ul><li><p><code>Blob</code> 是浏览器端的类文件对象，存储着二进制的数据，其接受两个参数，第一个参数，<code>array</code> 是一个由 <code>ArrayBuffer</code> , <code>ArrayBufferView</code> , <code>Blob</code> , <code>DOMString</code> 等对象构成的 <code>Array</code> ，或者其他类似对象的混合体，它将会被放进 <code>Blob</code> 。<code>DOMStrings</code> 会被编码为 <code>UTF-8</code> 。第二个参数是文件的 <code>MIME</code> 类型</p></li><li><p><code>Data URL</code> 格式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 格式</span><br>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;<br><br>// 浏览器地址栏可以直接访问<br>data:text/html,&lt;h1&gt;Hello%2C%20World!&lt;/h1&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>Base64</code> 最常用的场景一般是将图片压缩处理，但是编码之后存储较大</p></li><li><p><code>ObjectURL</code> 浏览器的 <code>URL</code> 对象生成一个地址来表示 <code>Blob</code> 数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">URL.createObjectURL(<span class="hljs-keyword">new</span> Blob(<span class="hljs-string">'hello, world'</span>.split(<span class="hljs-string">''</span>)))<br></code></pre></td></tr></table></figure></li></ul><h2 id="具体下载思路"><a href="#具体下载思路" class="headerlink" title="具体下载思路"></a>具体下载思路</h2><h3 id="一般接口返回值都是-json-结构，所以可以先将其-JSON-stringify-序列化为-JSON-字符串，想要将接口返回的数据下载，有两种思路"><a href="#一般接口返回值都是-json-结构，所以可以先将其-JSON-stringify-序列化为-JSON-字符串，想要将接口返回的数据下载，有两种思路" class="headerlink" title="一般接口返回值都是 json 结构，所以可以先将其 JSON.stringify 序列化为 JSON 字符串，想要将接口返回的数据下载，有两种思路"></a>一般接口返回值都是 <code>json</code> 结构，所以可以先将其 <code>JSON.stringify</code> 序列化为 <code>JSON</code> 字符串，想要将接口返回的数据下载，有两种思路</h3><ul><li>将 <code>JSON</code> 字符串文本转换为 <code>Data URL</code></li><li>将 <code>JSON</code> 字符串文本转换为 <code>Blob</code> ，再由 <code>Blob</code> 创建 <code>ObjectURL</code></li><li>最终都通过 <code>a</code> 标签的模拟点击来下载</li></ul><p>具体伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> download = <span class="hljs-function">(<span class="hljs-params">url: string, name: string</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> aTag = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"a"</span>);<br>  aTag.download = name;<br>  aTag.rel = <span class="hljs-string">"noopener"</span>;<br>  aTag.href = url;<br>  <span class="hljs-comment">// 触发模拟点击</span><br>  aTag.dispatchEvent(<span class="hljs-keyword">new</span> MouseEvent(<span class="hljs-string">"click"</span>));<br>&#125;;<br><br><span class="hljs-comment">// 方案1:</span><br><span class="hljs-keyword">const</span> downloadStr = <span class="hljs-built_in">JSON</span>.stringify(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 第三个参数用来将数据格式化一下</span><br><span class="hljs-keyword">const</span> dataUrl = <span class="hljs-string">`data:,<span class="hljs-subst">$&#123;downloadStr&#125;</span>`</span>;<br>download(dataUrl, <span class="hljs-string">"data.json"</span>);<br><br><span class="hljs-comment">// 方案2:</span><br><span class="hljs-keyword">const</span> downloadUrl = URL.createObjectURL(<span class="hljs-keyword">new</span> Blob(downloadStr.split(<span class="hljs-string">""</span>)));<br>download(downloadUrl, <span class="hljs-string">"data.json"</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常工作git命令总结</title>
    <link href="/2020/09/15/git-summary/"/>
    <url>/2020/09/15/git-summary/</url>
    
    <content type="html"><![CDATA[<p>结合vscode会很强大</p><h2 id="生成sshkey"><a href="#生成sshkey" class="headerlink" title="生成sshkey"></a>生成sshkey</h2><ul><li><code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></li><li><code>cd ~/.ssh</code> 复制 <code>id_rsa.pub</code> 内容复制到 <code>git</code> 库中</li></ul><h2 id="配置信息以及查看"><a href="#配置信息以及查看" class="headerlink" title="配置信息以及查看"></a>配置信息以及查看</h2><ul><li><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><ul><li><code>git config --list</code></li></ul></li><li><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><ul><li><p><code>git config --global user.name &quot;yourname&quot;</code></p></li><li><p><code>git config --global user.email &quot;your_email&quot;</code></p></li></ul></li><li><h3 id="在不同-git-文件下-config-中设置不同的局部变量"><a href="#在不同-git-文件下-config-中设置不同的局部变量" class="headerlink" title="在不同 .git 文件下 config 中设置不同的局部变量"></a>在不同 <code>.git</code> 文件下 <code>config</code> 中设置不同的局部变量</h3><ul><li><code>git config  user.name &quot;name&quot;</code></li><li><code>git config  user.email &quot;email&quot;</code></li></ul></li></ul><h2 id="常用的基本操作"><a href="#常用的基本操作" class="headerlink" title="常用的基本操作"></a>常用的基本操作</h2><ul><li><h3 id="初始化创建-git"><a href="#初始化创建-git" class="headerlink" title="初始化创建 .git"></a>初始化创建 <code>.git</code></h3><ul><li><code>git init -y</code> // 加参数可以跳过填写信息</li></ul></li><li><h3 id="添加本地已有文件到-git-远程仓库"><a href="#添加本地已有文件到-git-远程仓库" class="headerlink" title="添加本地已有文件到 git 远程仓库"></a>添加本地已有文件到 <code>git</code> 远程仓库</h3><ul><li><code>git remote add origin xxxx.git</code></li></ul></li><li><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><ul><li><code>git branch</code> // 当前本地分支</li><li><code>git branch -a</code> // 查看所有分支【本地+远程】</li></ul></li><li><h3 id="更新远程分支到本地分支"><a href="#更新远程分支到本地分支" class="headerlink" title="更新远程分支到本地分支"></a>更新远程分支到本地分支</h3><ul><li><code>git checkout -b &lt;localBranch&gt; origin/&lt;remoteBranch&gt;</code> // 更新远程分支 <code>remoteBranch</code> 在本地的 <code>localBranch</code> 分支上</li></ul></li><li><h3 id="临时存储"><a href="#临时存储" class="headerlink" title="临时存储"></a>临时存储</h3><p>开发了一半还没完成突然线上出现了紧急问题，这个时候工作区未清空的状态下 <code>git</code> 不允许签出和签入，此时不想 <code>commit</code> 的话，就要用到以下命令</p><ul><li><code>git stash</code> // 将目前的改动存储起来</li><li><code>git stash list</code> // 查看 <code>stash</code> 了哪些</li><li><code>git stash apply</code> // 如果要使用其他个，<code>git stash apply stash@{$num}</code> <code>num</code> 从 <code>0</code> 开始 结合 <code>vocode</code> 可以点击对应的就可以应用</li><li><code>git stash clear</code> // 清除掉 <code>stash</code></li></ul></li><li><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><ul><li><code>git checkout &lt;branch&gt;</code></li></ul></li><li><h3 id="若想基于当前分支拉出来一个新的分支"><a href="#若想基于当前分支拉出来一个新的分支" class="headerlink" title="若想基于当前分支拉出来一个新的分支"></a>若想基于当前分支拉出来一个新的分支</h3><ul><li><code>git checkout -b &lt;newBranch&gt;</code></li><li>推送到远程仓库 <code>git push origin &lt;newBranch&gt;</code></li></ul></li><li><h3 id="删除本地和远程分支"><a href="#删除本地和远程分支" class="headerlink" title="删除本地和远程分支"></a>删除本地和远程分支</h3><ul><li><code>git branch -d &lt;branch&gt;</code> // 有时候不生效可能需要换成 <code>-D</code></li><li><code>git push origin --delete &lt;branch&gt;</code></li></ul></li><li><h3 id="查看状态、将文件添加到缓冲区、提交到本地仓库"><a href="#查看状态、将文件添加到缓冲区、提交到本地仓库" class="headerlink" title="查看状态、将文件添加到缓冲区、提交到本地仓库"></a>查看状态、将文件添加到缓冲区、提交到本地仓库</h3><ul><li><code>git status</code></li><li><code>git log</code></li><li><code>git reflog</code> // 相比 <code>git log</code> 它每一步操作都能看到（ <code>.git</code> 下的 <code>refs</code> 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针，所以猜测 <code>git reflog</code> 基本上跟 <code>refs</code> 有关）</li><li><code>git add . | git add fileName</code></li><li><code>git commit -m &quot;msg&quot;</code> // <code>-m</code> 参数表示可以直接输入后面的 <code>message</code></li><li><code>git commit -a -m &quot;msg&quot;</code> // 相当于执行了 <code>git add . + git commit -m &quot;msg&quot;</code></li></ul></li><li><h3 id="重置提交信息"><a href="#重置提交信息" class="headerlink" title="重置提交信息"></a>重置提交信息</h3><ul><li><code>git commit --amend</code> // <code>git push</code> 的时候需要校验 <code>message</code> 格式，如果第一次写错的话就无法 <code>push</code> 到远程仓库，可以用这个修改提交的 <code>message</code> 重新 <code>push</code></li></ul></li><li><h3 id="pull-不下代码的情况"><a href="#pull-不下代码的情况" class="headerlink" title="pull 不下代码的情况"></a><code>pull</code> 不下代码的情况</h3><ul><li><code>git pull origin &lt;branch&gt;</code> // 偶尔会遇到服务器上的代码一直 <code>pull</code> 不下来，可以加上 <code>origin &lt;branch&gt;</code></li></ul></li><li><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul><li>个人习惯和原则：所有本地改动均已经推送到远程分支的前提</li><li><code>git merge &lt;branch&gt;</code> // 将 <code>branch</code> 分支合并到当前分支</li><li>简单的合并出现冲突，用 <code>vscode</code> 解决掉冲突，重新<code>add 、commit、push</code> 就可以，但是一些有时候出现一些比较复杂的冲突导致合并失败，再次操作的时候会提示当前正在处于合并之中（分支名后带着｜<code>MERGING</code>），需要 <code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态<br>如果已经合并发现合并错分支（所以合并的东西是不需要保留在工作空间的），可以使用 <code>git reset --hard HEAD~</code> 来还原到未合并之前，并且工作区是干净的状态</li><li>合并中出现 <code>Swap file .MERGE_MSG.swp already exists</code> 的情况需要打开当前项目 <code>.git</code> 文件删除 <code>.MERGE_MSG.sw*</code> 文件，再继续操作</li></ul></li><li><h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><ul><li><code>git reset --(soft | mixed | hard ) &lt; HEAD ~(num) &gt; |</code></li><li>用的比较多的是 <code>soft</code> 和 <code>hard</code></li><li>跟时间旅行一个道理，<code>git reset HEAD</code> 跟着  <code>HEAD@{1}(HEAD~) HEAD@{2}...</code> 或者分支的 <code>hash</code> 值可以将本地存储库切换到任意的版本</li><li>一种场景如果需要回退到某一次版本，并且不要那些版本的改动文件，可以使用 <code>git reset --hard HEAD</code>【硬回退】这个命名回回退到指定的版本并且删掉之前的改动文件，不会出现在暂存区。如果想回退到某次版本，并且需要暂存区看到改动的文件可以使用 <code>git reset --soft HEAD</code>【软回退】</li><li>回退到某个之前的版本的话， 需要 <code>git push origin &lt;branch&gt; --force</code> 推送到远程分支</li></ul></li><li><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ul><li><code>master</code> 分支推送可以直接使用 <code>git push</code></li><li>非 <code>master</code> 分支需要加上 <code>origin &lt;remoteBranch&gt;</code> 即：<code>git push origin remoteBranch</code></li></ul></li><li><h3 id="不是很常用的几个-git-命令"><a href="#不是很常用的几个-git-命令" class="headerlink" title="不是很常用的几个 git 命令"></a>不是很常用的几个 <code>git</code> 命令</h3><ul><li><p><code>git fetch</code> // 有时候不需要合并的时候会用一下，<code>git fetch</code> 和 <code>git pull</code> 的区别就是 <code>git pull = git fetch + git merge</code></p></li><li><p><code>submodule</code> 的命令</p><ul><li><code>git submodule init</code></li><li><code>git submodule foreach git submodule update</code></li><li><code>git submodule update --init</code></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同一个项目切换移动端和PC端布局方案</title>
    <link href="/2020/09/14/check-pc-mobile/"/>
    <url>/2020/09/14/check-pc-mobile/</url>
    
    <content type="html"><![CDATA[<h1 id="部分响应式布局小结"><a href="#部分响应式布局小结" class="headerlink" title="部分响应式布局小结"></a>部分响应式布局小结</h1><p>代码在一个工程中如何做 <code>pc</code> 和 <code>mobile</code> 检测分别使用不同的组件以及样式？【一个目前个人解决的方案，但是项目大的话成本可能会高。更好的做法应该是一套代码根据屏幕大小自适应（类似栅栏布局）】</p><h2 id="判断是哪个端"><a href="#判断是哪个端" class="headerlink" title="判断是哪个端"></a>判断是哪个端</h2><ul><li><code>App.vue</code> 生命周期中通过 <code>isMobile</code> 方法判断是属于哪个端</li><li>为顶级标签设置命名空间（ <code>css</code> 样式用）</li><li><code>v-if</code> 切换不同的 <code>router-view</code> ，这里只需要切到入口路由就可以，其它的在路由跳转的时候钩子函数中判断路由路径包不包含 <code>mobile/pc</code> 的 <code>key</code> ，从而判断在 <code>next</code> 的时候要不要拼上 <code>mobile/pc</code> 的文件路径跳转。</li></ul><p><code>App.vue</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js">methods: &#123;<br>  isMobile() &#123;<br>    <span class="hljs-keyword">let</span> flag = navigator.userAgent.match(<span class="hljs-regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>);<br>    <span class="hljs-keyword">this</span>.isMobileDevice = flag;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>&#125;,<br>mounted() &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isMobile()) &#123;<br>  &lt;!-- 如果是移动端的话需要设置rem --&gt;<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, win</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> docEl = doc.documentElement;<br>      <span class="hljs-keyword">let</span> resizeEvt =<br>        <span class="hljs-string">"orientationchange"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> ? <span class="hljs-string">"orientationchange"</span> : <span class="hljs-string">"resize"</span>;<br>      <span class="hljs-keyword">let</span> recalc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> clientWidth = docEl.clientWidth;<br>        <span class="hljs-keyword">if</span> (!clientWidth) <span class="hljs-keyword">return</span>;<br>        &lt;!-- 按照750尺寸设置 --&gt;<br>        if (clientWidth &gt;= 750) &#123;<br>          &lt;!-- 100作为基准，100px为1rem --&gt;<br>          docEl.style.fontSize = "100px";<br>        &#125; else &#123;<br>          docEl.style.fontSize = 100 * (clientWidth / 750) + "px";<br>        &#125;<br>      &#125;;<br>      if (!doc.addEventListener) return;<br>      win.addEventListener(resizeEvt, recalc, false);<br>      doc.addEventListener("DOMContentLoaded", recalc, false);<br>    &#125;)(document, window);<br>    &lt;!-- 增加顶级命名空间，用于区分不同端的css作用域 --&gt;<br>    this.$nextTick(() =&gt; &#123;<br>      window.document<br>        .getElementsByTagName("body")[0]<br>        .setAttribute("id", "mobile-web-app");<br>    &#125;);<br>  &#125; else &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      window.document<br>        .getElementsByTagName("body")[0]<br>        .setAttribute("id", "pc-web-app");<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pc-和-mobile-两套代码以及样式文件"><a href="#pc-和-mobile-两套代码以及样式文件" class="headerlink" title="pc 和 mobile 两套代码以及样式文件"></a><code>pc</code> 和 <code>mobile</code> 两套代码以及样式文件</h3><ul><li>针对定义命名空间 <code>style</code> 标签应该是</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">#mobile-web-app, #pc-web-app &#123;<br>  width: 100%;<br>  #app &#123;<br>    ....<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactPrompt 切换路由之前弹出拦截提示</title>
    <link href="/2020/09/06/react-prompt/"/>
    <url>/2020/09/06/react-prompt/</url>
    
    <content type="html"><![CDATA[<h3 id="Prompt-组件的逻辑"><a href="#Prompt-组件的逻辑" class="headerlink" title="Prompt 组件的逻辑"></a><code>Prompt</code> 组件的逻辑</h3><ul><li><code>when</code> 为 <code>true</code>，<code>message</code> 方法 <code>return</code> 的变量为 <code>false</code> 的时候就会提示。<code>message</code> 可以接受一个函数也可以接受一个字符串。</li><li>两个关键点，需要弹出提示的话属性即：<ul><li><code>when={true}</code></li><li><code>message={() =&gt; { return false }}</code></li></ul></li></ul><p>至于具体的 <code>message</code> 什么时候 <code>return true</code> 什么时候 <code>return false</code> 是需要按照业务处理。</p><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><ul><li><p>在 <code>JSX</code> 中增加组件，当切换路由的时候，<code>visible</code> 的状态会导致要不要提示，在满足条件需要弹出的时候，<code>visible</code> 要是 <code>true</code>。</p></li><li><p>例如：获取完数据之后，页面有数据的时候，切换路由是需要给出提示信息。先将 <code>visible</code> 属性值设置为 <code>true</code>，这样在有数据的时候，切换路由就会提示，<code>message</code> 方法 <code>return</code> 的 <code>boolean</code> 值为判断是否弹窗的逻辑，这里的 <code>boolean</code> 为 <code>false</code> 就会提示。</p></li><li><p>伪代码：</p></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'umi/router'</span><br><br>&lt;Prompt<br>  when=&#123;visible&#125; <span class="hljs-comment">// 有数据的时候visible一定是true</span><br>  message=&#123;location =&gt; &#123;<br>    Modal.confirm(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">'请注意！'</span>,<br>      <span class="hljs-attr">icon</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ExclamationCircleOutlined</span> /&gt;</span>,<br>      content: '确定要离开当前页面吗？一旦确认离开，当前页面的数据将被作废！',<br>      okText: '确认',<br>      cancelText: '取消',<br>      onOk: () =&gt; &#123;<br>        // 确定按钮的逻辑<br>      &#125;,<br>      onCancel: () =&gt; &#123;&#125;<br>    &#125;);<br>    // false弹窗拦截<br>    return taskList.length &gt; 0 ? false : true<br>  &#125;<br>&#125;<br>/&gt;</span><br></code></pre></td></tr></table></figure><p>防止踩坑的点：<code>message</code> 里的 <code>return</code> 一定要写在 <code>Modal</code> 的外边，这样在判断有数据的时候如果是 <code>return false</code> 就会自动弹出 <code>Modal</code> 拦截，如果是 <code>return true</code> 则不会提示。</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eventLoop</title>
    <link href="/2020/08/27/event-loop/"/>
    <url>/2020/08/27/event-loop/</url>
    
    <content type="html"><![CDATA[<h1 id="主线程-任务队列-事件循环"><a href="#主线程-任务队列-事件循环" class="headerlink" title="主线程-任务队列-事件循环"></a>主线程-任务队列-事件循环</h1><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><ul><li>初始化压栈，执行同步任务、函数执行栈在主线程</li><li>主线程执行的是被压入执行栈的同步任务，不管来源是哪里，负责压入函数执行栈执行逻辑。异步任务的<code>callback</code>的逻辑会被事件循环通知后拿到这里来执行。</li></ul><h2 id="WebAPIs-任务队列-存放异步任务"><a href="#WebAPIs-任务队列-存放异步任务" class="headerlink" title="WebAPIs - 任务队列 存放异步任务"></a><code>WebAPIs</code> - 任务队列 存放异步任务</h2><ul><li><p>【<code>XHR</code>】任务队列中的都是已经完成了<code>http</code>请求，是获取完数据等待执行的回调函数。</p></li><li><p><code>AJAX</code> <code>handleData.fetchData()</code>理解为网络线程先去请求数据，拿到数据之后<code>.then(res =&gt; {})</code>回调函数注册到任务队列，进入异步的都是回调函数中的那部分程序。</p></li></ul><ul><li><p>宏任务</p><ul><li>定时器、<code>I/O</code></li></ul></li><li><p>微任务</p><ul><li><p>在当前的微任务没有执行完成时，是不会执行下一个宏任务的</p></li><li><p><code>Promise.resolve</code>和<code>return new Promise</code>都是同步任务立即执行</p></li><li><p><code>async/await</code>执行完之后，会立即返回，就是<code>await</code>后的程序，可以当作是<code>then</code>的回调函数，原理都是一样，只是异步转为同步的语法糖。</p></li><li><p>经典典型案例<code>Promise</code>练习</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> async2() <span class="hljs-comment">// 执行完立刻返回</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 end'</span>) <span class="hljs-comment">// 相当于.then的callback</span><br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async2 end'</span>)<br>&#125;<br>async1()<br>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise'</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>)<br></code></pre></td></tr></table></figure></li><li><p>同步任务开始 执行 <code>console.log</code> 打印 <code>script start</code></p></li><li><p>遇到 <code>async1()</code> 执行，内部执行await的方法<code>async2</code> ，打印 <code>async2 end</code> ，跳出【因为 <code>await</code> 后的相当于异步回调】</p></li><li><p>将 <code>async1 end</code> 注册到异步任务队列-微任务</p></li><li><p><code>setTimeout</code> 注册到异步任务队列-宏任务</p></li><li><p><code>new Promise</code> 同步执行打印 <code>Promise</code></p></li><li><p>分别注册 <code>promise1</code> 和 <code>promise2</code> 到微任务队列</p></li><li><p>执行 <code>console.log</code> 打印 <code>script end</code></p></li><li><p>主线程变空，事件循环通知主线程去任务队列拿取回调任务执行，按照 <code>FIFO</code> 的接口依次是执行 <code>async1</code> 的 <code>console.log</code> 和 <code>promise</code> 的两个 <code>then</code></p></li><li><p>执行宏任务 <code>setTimeout</code></p></li><li><p>结果 <code>script start、async2 end、Promise、script end、async1 end、promise1、promise2、setTimeout</code></p></li></ul></li></ul><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 <code>Event Loop</code></h2><ul><li><p>负责告诉主线程，执行哪个回调，分发任务，按照<code>FIFO</code>队列顺序执行。监听函数执行栈（主线程）是否为空，空则主线程从任务队列取出任务放进函数执行栈执行。</p></li><li><p>如果遇到主线程阻塞，异步任务队列的<code>callback</code>等待。</p></li><li><p>事件循环通知主线程，主线程从任务队列取出<code>callback</code>执行，是要主线程为空闲的时候才行，主线程如果一直有任务不释放，任务队列的<code>callback</code>一直是等待状态。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>事件循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器运行原理</title>
    <link href="/2020/08/24/how-the-browser-works/"/>
    <url>/2020/08/24/how-the-browser-works/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器运行原理梳理"><a href="#浏览器运行原理梳理" class="headerlink" title="浏览器运行原理梳理"></a>浏览器运行原理梳理</h2><p><img src="../../../../images/web-request.jpg" srcset="/img/loading.gif" alt="浏览器一个tab运行原理粗浅梳理"></p><h2 id="CPU串行"><a href="#CPU串行" class="headerlink" title="CPU串行"></a><code>CPU</code>串行</h2><ul><li>单核</li><li>多核</li></ul><h2 id="GPU图形处理器"><a href="#GPU图形处理器" class="headerlink" title="GPU图形处理器"></a>GPU图形处理器</h2><ul><li>多个核心共同工作，并行能力很强</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li><p>渲染进程内存</p><ul><li><p>问题：因为多进程不会共享内存空间，进程数量多之后内存占用大</p></li><li><p>解决：进程数到达一定界限之后，会将同一个网站的 <code>tab</code> 放在同一个进程中跑</p></li></ul></li><li><p>网站隔离：跨站点的 <code>ifream</code> 拥有一个独立的进程，同源策略</p></li><li><p>浏览器主进程服务化</p><ul><li><p>拆分为不同的服务</p><ul><li>在一些性能好的机器上，运行单独的进程，提高系统的稳定性。</li><li>在一些性能不好的机器上，运行合并为一个进程，节约内存。</li></ul></li><li><p>目的：节省内存</p></li></ul></li></ul><h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><ul><li><h3 id="浏览器主进程，会有很多线程"><a href="#浏览器主进程，会有很多线程" class="headerlink" title="浏览器主进程，会有很多线程"></a>浏览器主进程，会有很多线程</h3><ul><li><p>概览：主进程会得知这些请求以及线程创建通信的信息，主进程得知数据准备完成之后，会通过<code>IPC</code>通知渲染进程，可以提交本次导航，并且继续接受接下来的<code>HTML</code>数据，渲染进程导航结束之后会通知主进程，本次导航结束，开始加载并且渲染和解析<code>HTML</code>文档。这时候，浏览器<code>tab</code>的当前会话会被更新为新导航的地址，以及开始加载<code>tab</code>菊花、生效后退按钮，为了方便打开之前关闭的tab会话，浏览器的历史会话会被保存在磁盘上。</p></li><li><p>负责包括地址栏，书签栏，前进后退按钮等部分的工作；</p></li><li><p>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</p></li><li><p>导航输入-<code>UI</code>线程</p></li><li><p>处理输入</p><ul><li><p>根据用户的输入，<code>UI</code>线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求输入的站点资源。</p></li><li><p>开始处理</p><p>  当用户按下回车键的时候，确定解析类型</p><ul><li><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>浏览器发送请求前，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</p></li><li><p>没有命中强缓存规则，浏览器会发送请求，根据请求头的<code>last-modified</code>和<code>etag</code>判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</p></li><li><p>如果前两步都没有命中，则直接从服务端获取资源。</p></li></ul></li></ul></li><li><p>读取响应</p><ul><li><p>确定响应主体的具体媒体类型<code>（MIME Type）</code>，最直接的方法就是通过<code>HTTP</code>请求头的 <code>Content-Type</code> 来判断是属于哪种媒体类型，网络线程告知<code>UI</code>线程，数据已经准备好可以开始导航到所需要的站点</p></li><li><p>在开始处理的时候，已经知道要导航到哪里的站点，浏览器为了优化，<code>UI</code>线程其实已经在这一步开始提前启动创建了一个渲染进程，如果一切都没问题，响应回来之后就可以直接准备渲染，而不是等数据准备好之后才开始创建。如果网站失效或者重定向之类的话，刚刚为先前的站点创建的渲染进程会被摒弃，从而开始创建一个新的目标渲染进程。</p></li></ul></li><li><p><code>Content-Type: text/html</code></p></li><li><p><code>zip</code> <code>/</code> 静态资源文件</p></li></ul></li><li><p>网络请求-网络线程</p><ul><li><p>发起新的请求：网络线程 初始化一个网络请求来获取站点的内容。网络线程会进行一系列诸如<code>DNS</code>寻址以及为请求建立<code>TLS</code>连接等的操作。网络线程会准备一些操作，如下：</p><ul><li><code>DNS</code>域名解析</li><li>建立<code>TCP</code>连接</li><li><code>SSL/TLS</code></li><li>发起<code>HTTP/HTTPS</code>请求</li></ul></li><li><p><code>DNS</code>解析</p></li><li><p><code>TCP/IP</code>连接</p></li><li><p><code>SSL/TLS</code></p><ul><li><code>TLS</code> 握手协议（非对称加密算法），客户端带着<code>HOST</code>以及随机生成的一个<code>session key1</code>去服务器握手，服务器收到<code>TLS</code>请求，根据客户端<code>HOST</code>寻找主机以及安全证书，服务器生成一个<code>session key2</code>以及将加密套件和证书返回给浏览器，客户端验证证书有效性（有效性，域名，有效机构，吊销状态）必须全部满足，否则会提示警告，验证如果通过，浏览器生成一份<code>session key3</code>通过第二步服务器返回的公钥加密，将结果再次返回给服务器，浏览器将<code>session key1、session key2、session key3</code>组合生成一个新的<code>session key</code>，服务器收到4的数据，利用非对称加密算法解析出<code>session key3</code>，同样也用<code>key123</code>组合生成<code>session key</code></li></ul></li><li><p><code>HTTP/HTTPS</code>响应</p><ul><li><p>响应类型</p><ul><li><p>静态文件 <code>html-&gt;text/html</code></p></li><li><p>静态文件 <code>js-&gt;application/JavaScript</code></p></li><li><p>静态图片 <code>image/png、jpg、jpeg、webp</code></p></li><li><p><code>json</code>数据 <code>application/json</code></p></li><li><p><code>css</code>样式 <code>text/css</code></p></li></ul></li></ul></li></ul></li><li><p>文件读写-存储线程</p></li></ul></li><li><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><ul><li><p>概览：负责一个 <code>tab</code> 内关于网页呈现的所有事情。<br>  导航被确认之后，渲染进程会用相关资源开始渲染页面。渲染完成之后，通过<code>IPC</code>告知浏览器进程，<code>UI</code>线程从而停止<code>loading</code>。<br>  如果在这个时候突然重新输入一个新的站点，旧的进程做收尾工作，新的进程开始新的一轮流程操作。<br>  尽可能的为每个新开的<code>Tab</code>创建一个单独的内存以及进程（安全、沙箱）</p></li><li><p>主线程</p><p>  解析</p><p>  <code>HTML</code>文档转换为<code>DOM</code>对象</p><ul><li><p><code>HTML</code>的解析按照<code>HTML</code>标准来解析</p></li><li><p>解析次级资源 -&gt; 转为网络线程下载</p><ul><li><p>渲染进程解析的过程中，如果遇到网页中的<code>&lt;img&gt;&lt;link&gt;</code>这些标签等，浏览器会渲染进程转而让网络线程去现在这些资源</p><ul><li><p>图片</p></li><li><p><code>css</code>样式</p></li><li><p><code>js</code></p></li></ul></li></ul></li><li><p>JS的下载和执行</p><ul><li><code>JS</code>和<code>DOM</code>解析是互斥的，因为<code>JS</code>操作可能会改变<code>DOM</code>结构，遂需要<code>DOM</code>加载完成之后。在遇到<code>script</code>标签的时候，<code>HTML</code>的加载和解析都会停止。</li></ul></li><li><p>构建<code>CSSOM</code></p><ul><li>根据元素选择器，渲染构建<code>CCSOM</code>，计算生成样式</li></ul></li><li><p>布局</p><ul><li>通过遍历<code>DOM</code>对象，计算样式和布局位置坐标以及盒子大小，生成布局树，布局树和<code>DOM</code>树的区别：视图可见为布局树，例如，<code>display:none</code>在布局树上不显示，但是在<code>DOM</code>树上会有</li></ul></li><li><p>绘制</p><ul><li>计算出了样式和布局左边，按照先后顺序绘制元素</li></ul></li><li><p>合成帧</p><ul><li>主线程通过遍历布局树生成层树，每一层都会被单独的栅格化，最后通过合成线程将层组合为帧。<br>  层树确定，主线程-&gt;合成线程，合成线程栅格化每一层，合成线程将其每一层分割为多个磁贴，每个磁贴会发送到栅格线程，栅格化每个磁贴，并且存储在<code>GPU</code>显存上</li></ul></li></ul></li><li><p>工作线程</p><ul><li>处理<code>web worker</code>或者<code>service worker</code>的一些事情</li></ul></li><li><p>合成线程</p><ul><li>合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程<code>（compositor thread）</code>里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。<br>合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者<code>JS</code>执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。</li></ul></li><li><p>光栅线程</p><ul><li>将需要展示的信息转化为显示器的像素的过程叫做光栅化</li></ul></li></ul></li><li><h3 id="渲染进程-联系-用户事件"><a href="#渲染进程-联系-用户事件" class="headerlink" title="渲染进程 联系  用户事件"></a>渲染进程 联系  用户事件</h3><p>  概览：合成线程会将注册了事件的区域绑定为，非快速滚动区域。当用户事件发生在这些区域时，合成线程会将输入事件发送给主线程来处理。如果输入事件不是发生在非快速滚动区域，合成线程就无须主线程的参与来合成一个新的帧。</p><ul><li><p>事件监听伪代码</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">document.body.addEventListener(<span class="hljs-string">'touchstart'</span>, <span class="hljs-keyword">event</span> =&gt; &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.target === area) &#123;<br><span class="hljs-keyword">event</span>.preventDefault()<br>&#125;<br>&#125;, &#123;passive: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><p>  <code>{passive: true}</code> 这个参数会告诉浏览器您仍要在主线程中侦听事件，合成线程也可以继续合成新的帧。<br>  否则，一些没有用户输入的页面，也会等主线程完成之后合成线程才干活，从而丧失合成线程优势。类似于同步和异步方式。</p></li><li><p>查找事件的目标对象</p><ul><li>当合成线程向主线程发送输入事件时，主线程要做的第一件事是通过命中测试去找到事件的目标对象。具体的命中测试流程是遍历在渲染流水线中生成的绘画记录来找到输入事件出现的<code>x, y</code>坐标上面描绘的对象是哪个</li></ul></li></ul></li><li><h3 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h3><ul><li>负责控制一个网页用到的所有插件</li></ul></li><li><h3 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a><code>GPU</code> 进程</h3><ul><li>负责处理 <code>GPU</code> 相关的任务，独立进程是因为要处理不同<code>tab</code>的渲染请求</li></ul></li><li><h3 id="工具进程"><a href="#工具进程" class="headerlink" title="工具进程"></a>工具进程</h3></li><li><h3 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h3></li></ul><h2 id="浏览器主线程、v8解析多线程解析、执行js"><a href="#浏览器主线程、v8解析多线程解析、执行js" class="headerlink" title="浏览器主线程、v8解析多线程解析、执行js"></a>浏览器主线程、<code>v8</code>解析多线程解析、执行<code>js</code></h2><ul><li><p>概括</p><ul><li><p><code>JavaScirpt</code>引擎可以将JS代码编译为不同<code>CPU</code>对应的汇编代码，这样我们才不要去翻阅每个<code>CPU</code>的指令集手册。当然，<code>JavaScript</code>引擎的工作也不只是编译代码，它还要负责执行代码、分配内存以及垃圾回收。</p></li><li><p><code>V8</code>属于<code>JIT</code>编译器，在运行的时候先编译再执行，这种方式被称为即时编译，直接运行源码<code>js</code></p></li><li><p>图片参考：<a href="https://image.fundebug.com/2019-07-16-ignition-turbofan-pipeline.png" target="_blank" rel="noopener">https://image.fundebug.com/2019-07-16-ignition-turbofan-pipeline.png</a>、<a href="https://pic3.zhimg.com/80/v2-577dc100b5725942708b9ab7e74ac4b0_720w.jpg" target="_blank" rel="noopener">https://pic3.zhimg.com/80/v2-577dc100b5725942708b9ab7e74ac4b0_720w.jpg</a></p></li><li><p>解释器参考：<a href="https://zhuanlan.zhihu.com/p/41496446" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41496446</a></p></li></ul></li><li><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3></li><li><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><ul><li>汇总：词法分析、语法分析 将<code>JavaScript</code>源码转换为<code>AST</code>、<code>AST</code>生成作用域以及执行上下文，对所有的变量和函数定义 预编译<ul><li>词法作用域和动态作用域<ul><li>词法作用域是在定义的时候作用域已经定了,跟着书写的位置查找上一层的代码</li><li>动态作用域是代码运行的时候，当前函数作用域找不到，会出去当前函数的上下文</li></ul></li></ul></li></ul></li><li><h3 id="Ignition解释器构建代码"><a href="#Ignition解释器构建代码" class="headerlink" title="Ignition解释器构建代码"></a><code>Ignition</code>解释器构建代码</h3><p>  一个具有累加的寄存器</p><ul><li><p>根据<code>AST</code>和作用域转生成字节码（内存小于机器码）、执行 </p></li><li><p>此处已经开始执行，只是执行的不是<code>hot</code>的热点代码</p></li><li><p>收集函数运行时的信息</p></li></ul></li><li><h3 id="TurboFan编译器"><a href="#TurboFan编译器" class="headerlink" title="TurboFan编译器"></a><code>TurboFan</code>编译器</h3><ul><li><p>将解释器生成的字节码优化转为机器代码</p></li><li><p>热点代码：在被解释器多次执行的代码。</p></li><li><p>这部分的多次执行的代码，会被编译成二进制，下次执行的时候会直接执行二进制文件<code>（JIT）</code></p></li><li><p>为什么要叫编译器呢？因为会把热点代码编译成为类似c编译完成的那种可以直接执行的机器代码</p></li><li><h3 id="汇总："><a href="#汇总：" class="headerlink" title="汇总："></a>汇总：</h3><ul><li><code>Ignition</code>和<code>TurboFan</code> 从编译的角度上说基本上是一样的，为什么要这样设计?<ul><li>因为<code>TurboFan</code>会拿到热点代码直接编译成为二进制机器语言存在内存中，在<code>Ignition</code>运行的时候，如果是热点代码会直接去<code>TurboFan</code>运行二进制不用再次编译，本质上如果不是热点代码就会在<code>Ignition</code>运行，所以<code>TurboFan</code>是优化提高性能</li></ul></li></ul></li></ul></li><li><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>回收不需要的内存释放空间</li></ul></li><li><h3 id="一些杂话"><a href="#一些杂话" class="headerlink" title="一些杂话"></a>一些杂话</h3><ul><li><code>v8</code>看不懂代码，拿到的东西是字符串、<code>v8</code>对源码做一些处理生成可以认识的<code>AST</code></li><li>移动端暴露出来的问题就是占用内存爆-字节码来调节内存和执行速度</li></ul></li></ul><h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><ul><li><h3 id="编译性"><a href="#编译性" class="headerlink" title="编译性"></a>编译性</h3><ul><li>只需要编译一次就可以把源代码编译成为机器语言，以后执行不需要再编译，直接运行</li><li>不同平台对编译器影响比较大，在编译的时候，位数限制可能会导致<code>int/long</code>等给定的字节不同，导致变量位数不同从而跨平台低</li></ul></li><li><h3 id="解释性"><a href="#解释性" class="headerlink" title="解释性"></a>解释性</h3><ul><li>源代码-中间代码-机器语言</li><li>解释器对中间代码进行解释和运行</li></ul></li><li><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>解释器立即解释和执行代码、编译器为接下来准备运行的代码做好准备</li><li>编译器：生成一个可执行文件，运行的时候已经脱离的源代码、跨平台低<br>解释器：实时需要解释器解释代码、跨平台高（<code>node</code>支持<code>linux/windos</code> ==&gt; 中间代码字节码在<code>v8</code>里被解释为机器码二进制 ==&gt; <code>js</code>运行在各处）</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hook 父组件调用子组件方法</title>
    <link href="/2020/08/22/call-child-component-method/"/>
    <url>/2020/08/22/call-child-component-method/</url>
    
    <content type="html"><![CDATA[<h3 id="父组件引入useRef"><a href="#父组件引入useRef" class="headerlink" title="父组件引入useRef"></a>父组件引入<code>useRef</code></h3><p>在 <code>react</code> 中使用函数组件以及 <code>hooks</code> 之后，有遇到，在父组件需要调用子组件方法的地方，可以通过 <code>ref</code> 的转发，做到在父组件执行子组件的方法，为什么需要转发 <code>refs</code>，是因为默认情况下，函数组件没有实例，无法使用 <code>ref</code> 属性。所以如果需要在函数组件中使用 <code>ref</code>，其是指向 <code>dom</code> 元素。</p><p>其具体流程是：在父组件中创建 <code>ref</code>，并且通过属性的方式传递给子组件，子组件通过 <code>forwardRef</code> 包裹子组件，这样才能在子组件中的第二个参数中获取到 <code>ref</code>，此时获取到 <code>ref</code> 之后，<code>ref</code> 已经转发成功，当 <code>ref</code> 挂载完成之后，<code>ref.curren</code>t 将会指向子组件。</p><p><code>parent.tsx</code><br><img src="../../../../images/parent.png" srcset="/img/loading.gif" alt="parentComponent"></p><h3 id="子组件引入forwardRef和useImperativeHandle"><a href="#子组件引入forwardRef和useImperativeHandle" class="headerlink" title="子组件引入forwardRef和useImperativeHandle"></a>子组件引入<code>forwardRef</code>和<code>useImperativeHandle</code></h3><p><code>child.tsx</code><br><img src="../../../../images/children.jpg" srcset="/img/loading.gif" alt="childrenComponent"></p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记Mac下Hexo+github.io搭建个人静态博客</title>
    <link href="/2019/08/10/category/"/>
    <url>/2019/08/10/category/</url>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>  已经在 <code>GitHub</code> 配置过 <code>ssh</code> 并且已经使用 <code>ssh -T git@github.com</code> 并且测试成功</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ sudo npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>新建目录为<code>myBlog</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> myBlog</span><br><span class="hljs-meta">$</span><span class="bash"> hexo init</span><br></code></pre></td></tr></table></figure><p>初始化，会下载一基础文件，初次运行会自动 <code>npm install</code> 下载其他的包进行安装</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>默认地址为 <code>http://localhost:4000</code><br>此时就可以看到默认的主题博客</p><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><p>创建成功会提示在<code>source</code>目录下</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>下载自己喜欢的主题放置于根目录 <code>themes</code> 下</p><h3 id="关联-GitHub"><a href="#关联-GitHub" class="headerlink" title="关联 GitHub"></a>关联 <code>GitHub</code></h3><p>新建仓库，仓库名称必须为 <code>user.github.io</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开根目录 <code>_config.yml</code>文件，并且针对性修改，配置 <code>deploy</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">repository</span>: git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:user/user.github.io.git<br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 <code>hexo-deployer-git</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="生成静态文件并上传到-github-服务器"><a href="#生成静态文件并上传到-github-服务器" class="headerlink" title="生成静态文件并上传到 github 服务器"></a>生成静态文件并上传到 <code>github</code> 服务器</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p>此后便可以通过 <code>https://user.github.io/</code> 访问博客。</p><br><br><br>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/08/08/hello-world/"/>
    <url>/2019/08/08/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">默认情况下，访问网址为： http://localhost:4000/<br>$ hexo s<br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><br><br><br>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
