<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>探究 webpack 异步加载原理以及热更新流程</title>
    <link href="/2021/01/30/webpackDynamicLoad/"/>
    <url>/2021/01/30/webpackDynamicLoad/</url>
    
    <content type="html"><![CDATA[<p>异步加载应该分为代码模块的异步加载和路由的异步加载，但其原理基本都是一样的，我们先来看一个模块的异步加载。</p><h2 id="模块异步加载"><a href="#模块异步加载" class="headerlink" title="模块异步加载"></a>模块异步加载</h2><h3 id="初始化文件结构"><a href="#初始化文件结构" class="headerlink" title="初始化文件结构"></a>初始化文件结构</h3><p>首先我们一步一步开始，新建一个目录 <code>checkWebpackBundled</code>，安装 <code>webpack、webpack-cli、html-webpack-plugin、clean-webpack-plugin</code> 最终生成的文件结构大概类似于：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">|-- checkWebpackBundled</span><br>    <span class="hljs-string">|-- index.html // 用于html-webpack-plugin用的模板</span><br>    <span class="hljs-string">|-- package.json</span><br>    <span class="hljs-string">|-- webpack.config.js</span><br>    <span class="hljs-string">|-- src</span><br>        <span class="hljs-string">|-- buttonHello.js</span><br>        <span class="hljs-string">|-- buttonHi.js</span><br>        <span class="hljs-string">|-- main.js // webpack打包入口文件</span><br></code></pre></td></tr></table></figure><h3 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h3><p>我们先来写一个 <code>main.js</code> 文件，其中直接引入两个文件一个是 <code>buttonHi.js</code> 另一个是 <code>buttonHello.js</code>，然后我们配置一下 <code>webpack</code>，编写一个 <code>index.html</code> 的模板。</p><p><code>main.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> buttonHi <span class="hljs-keyword">from</span> <span class="hljs-string">"./buttonHi"</span>;<br><span class="hljs-keyword">import</span> buttonHello <span class="hljs-keyword">from</span> <span class="hljs-string">"./buttonHello"</span>;<br><br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".button-hi"</span>).addEventListener(<span class="hljs-string">"click"</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"buttonHi"</span>, buttonHi);<br>&#125;);<br><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".button-hello"</span>).addEventListener(<span class="hljs-string">"click"</span>, () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"buttonHello"</span>, buttonHello);<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>buttonHi.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-string">"button-hi!"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br></code></pre></td></tr></table></figure><p><code>buttonHello.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> a = <span class="hljs-string">"button-hello!!"</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<br></code></pre></td></tr></table></figure><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<br><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"clean-webpack-plugin"</span>);<br><span class="hljs-comment">/**<br> * @type &#123;webpack.Configuration&#125;<br> */</span><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">"./src/main.js"</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">"[name].js"</span>,<br>    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">"dist"</span>)<br>  &#125;,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>, <span class="hljs-comment">// 我们选择了dev模式，到时候打包完成之后的代码就不是压缩之后的，而且还是支持evel的sourceMap</span><br>  plugins: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">template</span>: <span class="hljs-string">"./index.html"</span><br>    &#125;)<br>  ]<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = config;<br></code></pre></td></tr></table></figure><p><code>index.html</code> 模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>webpack异步加载原理<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button-hi"</span>&gt;</span>点我是 hi！<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"button-hello"</span>&gt;</span>点我是 hello!<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接下来我们开始在终端运行 <code>npx webpack</code>，生成了 <code>dist</code> 目录，里面有我们打包成功的 <code>js</code> 文件和 <code>HtmlWebpackPlugin</code> 插件为我们生成的 <code>index.html</code>，我们在浏览器中运行 <code>index.html</code>，依次点击页面的两个按钮发现，分别在浏览器控制台打印出了<code>buttonHi button-hi!</code>和<code>buttonHello button-hello!!</code>。而且我们发现，我们的两个依赖文件全部都被打包到了 <code>main.js</code> 文件中。我们来看一下这种模式打包的产物是什么：</p><p>首先我们打开 <code>main.js</code>，将代码折叠起来，我们发现最终打包成功的文件是一个自执行函数，我们来简单看一下有用的内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// webpackBootstrap</span><br><span class="hljs-meta">  "use strict"</span>;<br>  <span class="hljs-comment">// 我们来看__webpack_modules__这个对象是一个map的映射，key是我们需要加载的模块的名称也就是依赖文件的路径，value是一个函数，这个函数的返回值其实就是将我们的源码的内容转为了webpack的一些方法</span><br>  <span class="hljs-keyword">var</span> __webpack_modules__ = &#123;<br>    <span class="hljs-comment">// 这里有三个模块，我们只看这一个，其他的同理</span><br>    <span class="hljs-string">"./src/buttonHello.js"</span>:<br>      <span class="hljs-comment">/*!****************************!*\<br>  !*** ./src/buttonHello.js ***!<br>  \****************************/</span><br>      <span class="hljs-function">(<span class="hljs-params">__unused_webpack_module, __webpack_exports__, __webpack_require__</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 这里是因为我们的webpack的mode设置的是develpoment模式，开启的eval的sourceMap，eval会将字符串变为可以执行的js</span><br>        <span class="hljs-built_in">eval</span>(<br>          <span class="hljs-string">"__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;\n/* harmony export */   \"default\": () =&gt; __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ &#125;);\nconst a = 'button-hello!!'\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (a);\n\n//# sourceURL=webpack://checkWebpackBundled/./src/buttonHello.js?"</span><br>        );<br><br>        <span class="hljs-comment">/***/</span><br>      &#125;,<br>    <span class="hljs-string">"./src/main.js"</span>: (<br>      __unused_webpack_module,<br>      __webpack_exports__,<br>      __webpack_require__<br>    ) =&gt; &#123;<br>      <span class="hljs-comment">// 战略性省略</span><br>    &#125;,<br>    <span class="hljs-string">"./src/buttonHi.js"</span>: (<br>      __unused_webpack_module,<br>      __webpack_exports__,<br>      __webpack_require__<br>    ) =&gt; &#123;<br>      <span class="hljs-comment">// 战略性省略</span><br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 定义一个缓存模块</span><br>  <span class="hljs-keyword">var</span> __webpack_module_cache__ = &#123;&#125;;<br>  <span class="hljs-comment">// webpack的加载函数，到最终CJS和ESM都是通过这个方法加载文件</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>) </span>&#123;<br>    <span class="hljs-comment">// 跟nodejs的加载模块原理一致，之前读取过的话再次读取会从缓存中拿</span><br>    <span class="hljs-keyword">if</span> (__webpack_module_cache__[moduleId]) &#123;<br>      <span class="hljs-keyword">return</span> __webpack_module_cache__[moduleId].exports;<br>    &#125;<br>    <span class="hljs-comment">// 没有命中的话，将新模块推入缓存中</span><br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">module</span> = (__webpack_module_cache__[moduleId] = &#123;<br>      <span class="hljs-comment">// no module.id needed</span><br>      <span class="hljs-comment">// no module.loaded needed</span><br>      exports: &#123;&#125;<br>    &#125;);<br><br>    <span class="hljs-comment">// 用__webpack_modules__的映射去执行对应的函数，也就是执行相应的moduleId对应的模块内容，将模块的加载挂在exports的对象上</span><br>    __webpack_modules__[moduleId](<span class="hljs-built_in">module</span>, <span class="hljs-built_in">module</span>.exports, __webpack_require__);<br><br>    <span class="hljs-comment">// Return the exports of the module</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports;<br>  &#125;<br><br>  <span class="hljs-comment">/* webpack/runtime/define property getters */</span><br>  (<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// define getter functions for harmony exports</span><br>    __webpack_require__.d = <span class="hljs-function">(<span class="hljs-params">exports, definition</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> definition) &#123;<br>        <span class="hljs-keyword">if</span> (<br>          __webpack_require__.o(definition, key) &amp;&amp;<br>          !__webpack_require__.o(exports, key)<br>        ) &#123;<br>          <span class="hljs-built_in">Object</span>.defineProperty(exports, key, &#123;<br>            <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">get</span>: definition[key]<br>          &#125;);<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;)();<br><br>  <span class="hljs-comment">/* webpack/runtime/hasOwnProperty shorthand */</span><br>  <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> &#123;<br>    __webpack_require__.o = <span class="hljs-function">(<span class="hljs-params">obj, prop</span>) =&gt;</span><br>      <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);<br>  &#125;)();<br><br>  <span class="hljs-comment">/* webpack/runtime/make namespace object */</span><br>  <span class="hljs-function">(<span class="hljs-params">(</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// define __esModule on exports</span><br>    __webpack_require__.r = <span class="hljs-function"><span class="hljs-params">exports</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> !== <span class="hljs-string">"undefined"</span> &amp;&amp; <span class="hljs-built_in">Symbol</span>.toStringTag) &#123;<br>        <span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-built_in">Symbol</span>.toStringTag, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">"Module"</span> &#125;);<br>      &#125;<br>      <span class="hljs-built_in">Object</span>.defineProperty(exports, <span class="hljs-string">"__esModule"</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span> &#125;);<br>    &#125;;<br>  &#125;)();<br><br>  <span class="hljs-comment">// 这里就是初始化加载我们的入口文件</span><br>  __webpack_require__(<span class="hljs-string">"./src/main.js"</span>);<br>&#125;)();<br></code></pre></td></tr></table></figure><p>所以我们结合构建机制看一下，构建开始是： <code>webpack</code> 转换代码并生成单个文件依赖，从入口文件开始递归分析并生成依赖图谱，即 <code>webpack</code> 能够找到入口文件，剩下的模块都是按照流程执行的。所以最后的执行流程是，<code>webpack</code> 最终打包生成的是一个 <code>IIFE</code>，其中有很多自执行函数是为<code>webpack_require</code>扩展增加的方法，而且我们能够发现我们编写的代码模块已经被 <code>webpack</code> 的内部扩展的方法包装过了，在最后我们发现<code>webpack_require(&quot;./src/main.js&quot;)</code>，这是调用了入口文件开始执行，这样打包生成的最后的文件，就会按照生成的依赖分别加载对应的模块文件，从而在浏览器中加载以及加载对应的页面或者方法。</p><p>引申出来的问题：到这里我们应该能够体会到一个缺点，如果项目的依赖太多且有的依赖很大，我们现在这种引入方式是有问题的，所有的引用最终如果都被打包到一个文件中，在初始化请求到时候，就会造成很多浪费以及延长加载时间，所以我们需要将有些依赖拆分出去，只在初始化的时候请求必须的文件，别的文件在执行的时候（动态引入的方法），或者路由切换的时候（路由懒加载）才去加载或者配合 <code>webpack</code> 的 <code>splitchunk</code> 来做分包。</p><h3 id="动态加载的两种方法"><a href="#动态加载的两种方法" class="headerlink" title="动态加载的两种方法"></a>动态加载的两种方法</h3><ul><li><code>ESM</code> 的 <code>import</code></li><li><code>webpack</code> 的 <code>webpack.ensure</code></li></ul><p><code>webpack</code> 已经不推荐使用 <code>webpack.ensure</code> 了，我们直接用 <code>import</code> 来测试。所以我们来使用 <code>import</code> 来异步加载模块，我们修改 <code>main.js</code> 文件</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">- import buttonHi from "./buttonHi";</span><br><span class="hljs-deletion">- import buttonHello from "./buttonHello";</span><br><br>document.querySelector(".button-hi").addEventListener("click", () =&gt; &#123;<br><span class="hljs-deletion">-  console.log("buttonHi", buttonHi);</span><br><span class="hljs-addition">+  import(/* webpackChunkName */`./buttonHi`).then(data =&gt; &#123;</span><br><span class="hljs-addition">+    console.log('data', data.default);</span><br><span class="hljs-addition">+  &#125;)</span><br>&#125;);<br>document.querySelector(".button-hello").addEventListener("click", () =&gt; &#123;<br><span class="hljs-deletion">-  console.log("buttonHello", buttonHello);</span><br><span class="hljs-addition">+  import(/* webpackChunkName */`./buttonHello`).then(data =&gt; &#123;</span><br><span class="hljs-addition">+    console.log('data', data.default);</span><br><span class="hljs-addition">+  &#125;)</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>再次运行 <code>npx webpack</code> 发现我们的 <code>dist</code> 下打包出来三个 <code>js</code> 文件</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">|-- dist</span><br>    <span class="hljs-string">|-- index.html</span><br>    <span class="hljs-string">|-- main.js</span><br>    <span class="hljs-string">|-- src_buttonHello_js.js</span><br>    <span class="hljs-string">|-- src_buttonHi_js.js</span><br></code></pre></td></tr></table></figure><p>我们能清楚的看到打包生成了三个文件，其中被我们 <code>import</code> 引入的文件分别被单独打包了。而且我们查看 <code>index.html</code> 发现只引用了一个入口文件 <code>main.js</code>，另外两个文件是没有被引入的。接下来我们在浏览器中继续刷新页面，发现 <code>network</code> 只请求了 <code>index.html</code> 和 <code>main.js</code> 文件。</p><p>我们开始点击第一个按钮，再观察 <code>network</code> 发现加载了 <code>src_buttonHi_js.js</code> 文件，并且浏览器控制台输出了我们要打印的文字，第二个按钮同理，也是在点击的时候采取主动请求。<br>然后我们看一下浏览器控制台面板的 <code>preview</code> 看看本次的请求的文件内容到底是什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">(self[<span class="hljs-string">"webpackChunkcheckWebpackBundled"</span>] =<br>  self[<span class="hljs-string">"webpackChunkcheckWebpackBundled"</span>] || []).push([<br>  [<span class="hljs-string">"src_buttonHi_js"</span>],<br>  &#123;<br>    <span class="hljs-comment">/***/</span> <span class="hljs-string">"./src/buttonHi.js"</span>:<br>      <span class="hljs-comment">/*!*************************!*\<br>  !*** ./src/buttonHi.js ***!<br>  \*************************/</span><br>      <span class="hljs-comment">/***/</span> (<br>        __unused_webpack_module,<br>        __webpack_exports__,<br>        __webpack_require__<br>      ) =&gt; &#123;<br>        <span class="hljs-string">"use strict"</span>;<br>        <span class="hljs-built_in">eval</span>(<br>          <span class="hljs-string">"__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, &#123;\n/* harmony export */   \"default\": () =&gt; __WEBPACK_DEFAULT_EXPORT__\n/* harmony export */ &#125;);\nconst a = 'button-hi!'\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (a);\n\n//# sourceURL=webpack://checkWebpackBundled/./src/buttonHi.js?"</span><br>        );<br><br>        <span class="hljs-comment">/***/</span><br>      &#125;<br>  &#125;<br>]);<br></code></pre></td></tr></table></figure><p>我们去查看打包后的文件发现这个 <code>webpackChunkcheckWebpackBundled</code> 是定义在一个叫做 <code>webpackJsonpCallback</code> 的方法中，而这个方法就是动态加载的核心。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js">__webpack_require__.l = <span class="hljs-function">(<span class="hljs-params">url, done, key, chunkId</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (inProgress[url]) &#123;<br>    inProgress[url].push(done);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">var</span> script, needAttach;<br>  <span class="hljs-comment">// ......</span><br>  <span class="hljs-comment">// 动态创建script标签的常规操作</span><br>  <span class="hljs-keyword">if</span> (!script) &#123;<br>    needAttach = <span class="hljs-literal">true</span>;<br>    script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"script"</span>);<br><br>    script.charset = <span class="hljs-string">"utf-8"</span>;<br>    script.timeout = <span class="hljs-number">120</span>;<br>    <span class="hljs-keyword">if</span> (__webpack_require__.nc) &#123;<br>      script.setAttribute(<span class="hljs-string">"nonce"</span>, __webpack_require__.nc);<br>    &#125;<br>    script.setAttribute(<span class="hljs-string">"data-webpack"</span>, dataWebpackPrefix + key);<br>    script.src = url;<br>  &#125;<br>  inProgress[url] = [done];<br><br>  <span class="hljs-comment">// 一些错误处理</span><br>  <span class="hljs-keyword">var</span> onScriptComplete = <span class="hljs-function">(<span class="hljs-params">prev, event</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// avoid mem leaks in IE.</span><br>    script.onerror = script.onload = <span class="hljs-literal">null</span>;<br>    clearTimeout(timeout);<br>    <span class="hljs-keyword">var</span> doneFns = inProgress[url];<br>    <span class="hljs-keyword">delete</span> inProgress[url];<br>    script.parentNode &amp;&amp; script.parentNode.removeChild(script);<br>    doneFns &amp;&amp; doneFns.forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn(event));<br>    <span class="hljs-keyword">if</span> (prev) <span class="hljs-keyword">return</span> prev(event);<br>  &#125;;<br>  <span class="hljs-keyword">var</span> timeout = setTimeout(<br>    onScriptComplete.bind(<span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>, &#123; <span class="hljs-attr">type</span>: <span class="hljs-string">"timeout"</span>, <span class="hljs-attr">target</span>: script &#125;),<br>    <span class="hljs-number">120000</span><br>  );<br>  script.onerror = onScriptComplete.bind(<span class="hljs-literal">null</span>, script.onerror);<br>  script.onload = onScriptComplete.bind(<span class="hljs-literal">null</span>, script.onload);<br>  <span class="hljs-comment">// 将生成的标签插入到head中</span><br>  needAttach &amp;&amp; <span class="hljs-built_in">document</span>.head.appendChild(script);<br>&#125;;<br></code></pre></td></tr></table></figure><p>除了这个我们还能发现<code>__webpack_require__.l</code>中有动态创建 <code>script</code> 标签，插入到 <code>head</code> 的操作，但是本次我们只能看到动态请求，并没发现动态创建 <code>script</code> 插入到 <code>head</code> 中的操作，接下来我们来构建一个单页面应用来查看和验证一下是不是只有在路由懒加载的时候才会如此触发。</p><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>路由懒加载我们使用 <code>react-cli</code> 来创建一个项目来验证以及看一下，路由加载的原理。</p><p>我们<code>npx create-react-app lazy-load-components</code>来创建一个 <code>react</code> 的项目，然后初始化之后的 <code>src</code> 文件目录应该是如下这样:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-string">|-- src</span><br>  <span class="hljs-string">|-- App.css</span><br>  <span class="hljs-string">|-- App.js</span><br>  <span class="hljs-string">|-- App.test.js</span><br>  <span class="hljs-string">|-- index.css</span><br>  <span class="hljs-string">|-- index.js</span><br>  <span class="hljs-string">|-- logo.svg</span><br>  <span class="hljs-string">|-- reportWebVitals.js</span><br>  <span class="hljs-string">|-- setupTests.js</span><br></code></pre></td></tr></table></figure><p>因为我们需要路由懒加载，所以需要手动安装一下 <code>react</code> 的路由，终端执行 <code>yarn add react-router-dom</code>，安装成功之后我们开始编写文件，我们在 <code>src</code> 下新建两个文件夹分别是 <code>components</code> 和 <code>utils</code>，在 <code>components</code> 下创建 <code>User.jsx</code> 和 <code>About.jsx</code> 并且在 <code>utils</code> 下创建 <code>index.js</code> 文件。最后的目录应该是:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined">|<span class="hljs-string">-- src<br>  </span>|<span class="hljs-string">-- App.css<br>  </span>|<span class="hljs-string">-- App.js<br>  </span>|<span class="hljs-string">-- App.test.js<br>  </span>|<span class="hljs-string">-- index.css<br>  </span>|<span class="hljs-string">-- index.js<br>  </span>|<span class="hljs-string">-- logo.svg<br>  </span>|<span class="hljs-string">-- reportWebVitals.js<br>  </span>|<span class="hljs-string">-- setupTests.js<br>  </span>|<span class="hljs-string">-- components // 新增<br>  </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- About.jsx<br>  </span>|<span class="hljs-string">   </span>|<span class="hljs-string">-- User.jsx<br>  </span>|<span class="hljs-string">-- utils // 新增<br>      </span>|<span class="hljs-string">-- index.js</span><br></code></pre></td></tr></table></figure><p>接下来编写：<br><code>About.jsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">const</span> About = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>About 今天天气不错！<span class="hljs-tag">&lt;/&gt;</span>;<br>&#125;;<br>export default About;</span><br></code></pre></td></tr></table></figure><p><code>User.jsx</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">const</span> User = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>User 在干嘛？吃了吗？吃的啥？<span class="hljs-tag">&lt;/&gt;</span>;<br>&#125;;<br>export default User;</span><br></code></pre></td></tr></table></figure><p><code>utils -&gt; index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;<br><span class="hljs-keyword">const</span> Loading = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span>loading<span class="hljs-tag">&lt;/&gt;</span>;<br>/**<br> * 实现路由分割<br> * 需要配合React.Suspense<br> * @param &#123;*&#125; components 传递一个方法，这个方法是动态导入的组件<br> */<br>export default function dynamic(components) &#123;<br>  const LazyComponents = React.lazy(components);<br>  return () =&gt; (<br>    <span class="hljs-tag">&lt;<span class="hljs-name">React.Suspense</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">&#123;</span>&lt;<span class="hljs-attr">Loading</span> /&gt;</span>&#125;&gt;<br>      <span class="hljs-tag">&lt;<span class="hljs-name">LazyComponents</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">React.Suspense</span>&gt;</span><br>  );<br>&#125;</span><br></code></pre></td></tr></table></figure><p><code>src -&gt; index.js</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs diff">import React from 'react';<br>import './index.css';<br><span class="hljs-deletion">- import App from './App';</span><br>import reportWebVitals from './reportWebVitals';<br>import ReactDOM from 'react-dom';<br><span class="hljs-addition">+ import &#123; HashRouter, Link, Route &#125; from 'react-router-dom';</span><br><span class="hljs-addition">+ import dynamic from './utils'</span><br><span class="hljs-addition">+ const dynamicAbout = dynamic(() =&gt; import('./components/About'))</span><br><span class="hljs-addition">+ const dynamicUser = dynamic(() =&gt; import('./components/User'))</span><br><br>ReactDOM.render(<br>  &lt;React.StrictMode&gt;<br><span class="hljs-deletion">-    &lt;App /&gt;</span><br><span class="hljs-addition">+    &lt;HashRouter&gt;</span><br><span class="hljs-addition">+      &lt;Link to="/"&gt;User页面&lt;/Link&gt;&lt;br/&gt;</span><br><span class="hljs-addition">+      &lt;Link to="/about"&gt;切换到About页面&lt;/Link&gt;&lt;br/&gt;</span><br><span class="hljs-addition">+      &lt;Route exact=&#123;true&#125; path="/" component=&#123;dynamicUser&#125;/&gt;</span><br><span class="hljs-addition">+      &lt;Route path="/about" component=&#123;dynamicAbout&#125; /&gt;</span><br><span class="hljs-addition">+    &lt;/HashRouter&gt;</span><br>  &lt;/React.StrictMode&gt;,<br>  document.getElementById('root')<br>);<br><br>// If you want to start measuring performance in your app, pass a function<br>// to log results (for example: reportWebVitals(console.log))<br>// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals<br>reportWebVitals();<br></code></pre></td></tr></table></figure><p>修改完成之后保存，我们在终端执行 <code>npm start</code>，自动打开页面，我们发现修改的内容已经生效了，这个时候我们来回忆一下，在开发环境下 <code>webpack</code> 会将打包的文件放在内存中，其实跟手动 <code>build</code> 以文件的方式区别不大，只是在内存中这样读取会很快，所以我们重新刷新一下页面，加载的时候查看一下浏览器的 <code>network</code> 面板，发现加载了很多文件，我们能发现其中 <code>3.chunk.js</code> 就是我们的首页也就是 <code>User.js</code>，里面的逻辑就是一个 <code>webpackJsonp</code> 加载对应的 <code>chunk</code> 文件，再下边是一些热模块更新的内容。然后现在我们切换一下面板到 <code>Elements</code>，到 <code>head</code> 下查看一下，发现此时的 <code>script</code> 只有 <code>3.chunk.js</code> 也就是 <code>User.js</code>。<br><img src="../../../../images/initChunk.png" srcset="/img/loading.gif" alt="初始化加载"></p><p>我们切换路由到 <code>about</code> 页面，再来观察，发现页面 <code>network</code> 加载了我们对应的组件，并且 <code>Elements</code> 的 <code>head</code> 中增加了一个 <code>script</code> 标签，其 <code>src</code> 就是我们刚刚看到的 <code>2.chunk.js</code> 也就说，在我们切换路由的时候浏览器去下载了对用的文件，并将其插入到 <code>head</code> 中，从而实现我们在路由切换完成之后，看到了对应组件或者页面的显示。所以这就验证了我们第一步里的代码分析动态加载 <code>script</code> 的那块。<br><img src="../../../../images/%E5%8A%A0%E8%BD%BDabout%E7%BB%84%E4%BB%B6.jpg" srcset="/img/loading.gif" alt="切换路由的时候network下载的chunk"><br><img src="../../../../images/%E5%8A%A0%E8%BD%BDaboutScript%E5%88%B0head%E4%B8%AD.jpg" srcset="/img/loading.gif" alt="切换路由的时候动态加载的script脚本"></p><p>总结：所以至此我们大概能够清楚浏览器是如何加载我们 <code>webpack</code> 打包后的文件，流程大概应该是：<code>webpack</code> 将文件最终都打包成为<code>webpack_modules</code>的一个互相依赖的 <code>kay:value</code> 的一个映射，最外层是 <code>webpackBootstrap</code> 的一个 <code>IIFE</code>，<code>IIFE</code> 的最下边开始执行<code>webpack_require(&quot;./src/main.js&quot;)</code>也就是执行入口文件，因为已经形成了依赖，所以在执行对应文件的时候会按照我们代码编写的预期执行，至于动态加载的时候，动态加载方法只是在触发对应的事件的时候才会执行逻辑，而路由的懒加载则是，在切换路由之后，浏览器会发起一个对应的 <code>chunk</code> 的请求，将这个请求的文件下载成功之后，通过动态创建 <code>script</code> 的形式插入到 <code>head</code> 标签中，从而实现动态加载。</p><h2 id="HMR-热模块更新机制"><a href="#HMR-热模块更新机制" class="headerlink" title="HMR 热模块更新机制"></a>HMR 热模块更新机制</h2><p>我们能够在刚刚的截图中发现，在初始化的时候有一个 <code>ws://localhost:3000/sockjs-node</code> 的请求，那这个东西是干嘛的呢？其实这就是热模块更新的重要的机制。<br><img src="../../../../images/%E7%83%AD%E6%9B%B4%E6%96%B0%E5%88%9D%E5%A7%8B%E5%8C%96.png" srcset="/img/loading.gif" alt="初始化加载热模块更新的一些资源"></p><p>我们先修改一下 <code>About</code> 组件的内容：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs diff">import React from 'react'<br>const About = () =&gt; &#123;<br>  return &lt;&gt;<br>    关于用户的一些信息哈<br><span class="hljs-addition">+    &lt;h1&gt;这是一个标题&lt;/h1&gt;</span><br>  &lt;/&gt;<br>&#125;<br>export default About<br></code></pre></td></tr></table></figure><p>保存之后，发现页面自动更新了并且 <code>network</code> 自动加载了两个文件一个是 <code>json</code> 文件一个是 <code>js</code> 文件，我们来看看这些东西是什么。<br><img src="../../../../images/%E7%94%9F%E6%88%90json-js%E6%96%87%E4%BB%B6.jpg" srcset="/img/loading.gif" alt="第一次热更新加载的文件"></p><p>我们发现，在我们初始化的 <code>ws</code> 里接受的 <code>data</code> 的是一个 <code>205487be9270982f923b</code> 的 <code>hash</code> 值，在我们修改文件保存之后，热模块自动更新的时候，会生成一个 <code>205487be9270982f923b.hot-update.json</code> 和<code>[chunkId].205487be9270982f923b.hot-update.js</code> 的文件，这个 <code>json</code> 文件返回了一个 <code>e3ab8e66727600303a2d</code> 的 <code>hash</code> 是用于连接下次热更新的于本次类似的加载操作，而 <code>js</code> 文件则是热模块更新重新打包的需要执行的文件内容，同样我们切换到 <code>Elements</code> 能够发现，热模块更新的时候下载的文件也是被直接插入到 <code>head</code> 标签中的从而实现 <code>script</code> 的实时替换和页面自动刷新。<br><img src="../../../../images/hot-load-add-script.jpg" srcset="/img/loading.gif" alt="热模块更新插入脚本"></p><p>总结：热模块更新的机制大致是和懒加载的逻辑相同，只不过其在初始化时候，开启了一个 <code>ws</code> 的请求，当修改文件修改的时候，<code>webpack</code> 会监听文件的变动，<code>ws</code> 接受 <code>hash</code> 作为下一次热更新的文件请求，因为在初始化和每一次修改之后都会生成下一次热更新的一个需求请求文件的 <code>hash</code>，所以在修改文件之后，浏览器会根据上一次的热模块生成的 <code>hash</code> 来下载下一次的更新的 <code>js</code>，浏览器下载完成热更新打包的 <code>js</code> 之后再如同懒加载一样，动态创建 <code>script</code> 脚本插入到 <code>head</code> 标签中，实现自动更新页面。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始手写一个简单的 loader（二）</title>
    <link href="/2021/01/26/markdownToHtmlLoaderOptimization/"/>
    <url>/2021/01/26/markdownToHtmlLoaderOptimization/</url>
    
    <content type="html"><![CDATA[<p>这是关于 <code>webpack</code> 的一些扩展。</p><p><a href="https://tennesseesunshine.github.io/2021/01/25/markdownToHtmlLoader/" target="_blank" rel="noopener">从零开始手写一个简单的 loader（一）</a> 里面已经生成了 <code>html</code> 字符串并且渲染到了页面。但是我们发现其样式无美感，那这一期我们增加一些样式，将生成的 <code>html</code> 渲染的像咱们博客中的那样。</p><p>首先我们需要的 <code>loader</code> 是 <code>css-loader</code> 和 <code>style-loader</code>，我们开始安装这两个依赖。<br><code>css-loader</code> 用于将 <code>css</code> 可以模块化的引入，并将其转换为 <code>js</code> 代码，<code>style-loader</code> 用于将上一步生成的 <code>js</code> 中包含的 <code>css</code>，生成可用的样式并且，通过生成 <code>style</code> 标签插入到 <code>head</code> 标签中。</p><ul><li>安装依赖</li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cnpm install --<span class="hljs-built_in">save</span>-dev css-loader <span class="hljs-built_in">style</span>-loader<br></code></pre></td></tr></table></figure><p>我们接着来配置 <code>webpack.config.js</code> 文件，在 <code>module</code> 的 <code>rules</code> 里再加上一个匹配项:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">rules: [<br>  &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>    <span class="hljs-attr">use</span>: [<br>      <span class="hljs-string">'./loader/md2html-loader.js'</span><br>    ]<br>  &#125;,<br>+  &#123;<br>+    test: <span class="hljs-regexp">/\.css$/</span>,<br>+    use: [<br>+      <span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span><br>+    ]<br>+  &#125;<br>]<br></code></pre></td></tr></table></figure><ul><li>创建 <code>css</code> 文件</li></ul><p>紧接着我们在 <code>src</code> 下创建一个 <code>index.css</code> 文件，添加如下 <code>css</code> 样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pre</span> &#123;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#282c34</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> <span class="hljs-number">24px</span>;<br>  <span class="hljs-attribute">text-align</span>: left;<br>  <span class="hljs-attribute">font-family</span>: Consolas, Monaco, Andale Mono, Ubuntu Mono, monospace;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid transparent;<br>  <span class="hljs-attribute">line-height</span>: <span class="hljs-number">1.4</span>;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">overflow-x</span>: auto;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">13px</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">white-space</span>: pre;<br>  <span class="hljs-attribute">word-spacing</span>: normal;<br>  <span class="hljs-attribute">word-break</span>: normal;<br>  <span class="hljs-attribute">word-wrap</span>: normal;<br>&#125;<br><br><span class="hljs-selector-tag">pre</span> <span class="hljs-selector-tag">code</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: inherit;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-selector-tag">code</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0.2em</span> <span class="hljs-number">0.4em</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">85%</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(27, 31, 35, 0.05);<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">3px</span>;<br>  <span class="hljs-attribute">color</span>: palevioletred;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>引入样式文件</li></ul><p>然后我们回到 <code>main.js</code> 里将 <code>index.css</code> 引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">"./index.css"</span>;<br></code></pre></td></tr></table></figure><p>现在我们再去终端运行 <code>npx webpack</code>，再刷新页面，发现生成的 <code>html</code> 已经被我们加上了样式。</p><p><img src="../../../../images/rander-html.png" srcset="/img/loading.gif" alt="最终渲染的页面"></p><p>截至目前我们已经完成了一个可以生成 <code>html</code> 的 <code>loader</code>，并且已经为其加上了样式。</p><p>我们目前用的是 <code>style-loader</code> 是将生成的 <code>css</code> 通过 <code>style</code> 的方式插入到 <code>head</code> 标签中。其实我们还有一种办法，将 <code>css</code> 提取出来，作为单个文件通过 <code>link</code> 标签加载。话不多说，我们继续。</p><ul><li>提取 <code>css</code></li></ul><p>要提取 <code>css</code> 样式文件，<code>webpack4.0</code> 之后用的插件叫: <code>mini-css-extract-plugin</code><br>我们来安装这个插件:</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cnpm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> mini-css-extract-plugin<br></code></pre></td></tr></table></figure><p>因为 <code>style-loader</code> 和 <code>mini-css-extract-plugin</code> 插件不能共存，所以我们需要删除 <code>webpack</code> 中之前配置的 <code>style-loader</code>，添加 <code>mini-css-extract-plugin</code>，具体修改如下：</p><p><code>webpack.config.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">+ <span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);<br><br><span class="hljs-built_in">module</span>: &#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>        <span class="hljs-string">'./loader/md2html-loader.js'</span><br>      ]<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,<br>      <span class="hljs-attr">use</span>: [<br>+        MiniCssExtractPlugin.loader, <span class="hljs-string">'css-loader'</span><br>      ]<br>    &#125;<br>  ]<br>&#125;,<br><span class="hljs-attr">plugins</span>: [<br>  <span class="hljs-keyword">new</span> CleanWebpackPlugin(),<br>  <span class="hljs-keyword">new</span> HtmlWebpackPlugin(),<br>+  <span class="hljs-keyword">new</span> MiniCssExtractPlugin()<br>]<br></code></pre></td></tr></table></figure><p>我们再去终端运行 <code>npx webpack</code>，刷新页面发现样式没改变再去看开发人员选项，发现样式文件目前是通过 <code>link</code> 标签引入的，证明我们的提取 <code>css</code> 配置是生效的。</p><p><img src="../../../../images/link-element.jpg" srcset="/img/loading.gif" alt="控制台标签元素"></p><p>至此，我们一个简单的 <code>loader</code> 就全部完成了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始手写一个简单的 loader（一）</title>
    <link href="/2021/01/25/markdownToHtmlLoader/"/>
    <url>/2021/01/25/markdownToHtmlLoader/</url>
    
    <content type="html"><![CDATA[<p>重学 <code>webpack</code> 之后，对 <code>webpack</code> 的理解又上了一个层次，<code>webpack</code> 的 <code>loader</code> 作为其一个非常重要的链路，能用自定义的 <code>loader</code> 来处理日常工作中遇到的问题俨然已经成为了一个前端工程师的基本素养，所以最基本的要求就是能够手写自定义的 <code>loader</code>。</p><p><code>webpack</code> 自身只能够处理 <code>JS</code> 和 <code>JSON</code> 文件，而作为非此二者的其他文件，<code>webpack</code> 也是支持其作为模块通过 <code>import、export、export.default</code> 等，所以在对这些文件处理的时候，就需要对应的一些 <code>loader</code> 来解析，例如在项目中使用 <code>sass</code>，那肯定是不能缺少解析 <code>sass</code> 的 <code>loader</code>。使用 <code>ts</code> 少不了 <code>ts-loader</code> 等等。</p><p>而且 <code>loader</code> 在 <code>webpack</code> 中是可以进行串联调用，从其从后往前或者从右往左的顺序可以知道，<code>webpack</code> 采用的是 <code>compose</code> 的方式来在下一个 <code>loader</code> 中结合上一个 <code>loader</code> 处理完的结果。其实在这种串联组合中的 <code>loader</code> 并不一定要返回 <code>JS</code> 代码。只要下游的 <code>loader</code> 能有效处理上游 <code>loader</code> 的输出，那么上游的 <code>loader</code> 可以返回任意类型的模块。</p><p>今天的任务是写一个，将 <code>markdown</code> 转为 <code>html</code> 的 <code>loader</code>。</p><h2 id="依赖分析"><a href="#依赖分析" class="headerlink" title="依赖分析"></a>依赖分析</h2><p>先分析一下构建这些， <code>webpack</code> 工具需要哪些东西，首先肯定需要 <code>webpack</code> 和 <code>webpack-cli</code> 作为最基础的依赖，然后需要 <code>marked</code> 将 <code>md</code> 文件转为 <code>html</code>，而且即便很简单的 <code>loader</code>，我们仍然需要一个 <code>CleanWebpackPlugin</code> 和 <code>HtmlWebpackPlugin</code> 作为在打包之前和成功之后最底层的支持，一个用于清除打包结果，一个用于生成打包后的 <code>html</code> 文件。所以我们汇总一下需要安装的几个依赖，分别是：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-bullet">- </span>webpack<br><span class="hljs-bullet">- </span>webpack-cli<br><span class="hljs-bullet">- </span>marked<br><span class="hljs-bullet">- </span>CleanWebpackPlugin<br><span class="hljs-bullet">- </span>HtmlWebpackPlugin<br></code></pre></td></tr></table></figure><h2 id="创建对应的文件夹、文件"><a href="#创建对应的文件夹、文件" class="headerlink" title="创建对应的文件夹、文件"></a>创建对应的文件夹、文件</h2><p>首先我们需要利用 <code>npm</code> 自动生成一个 <code>package.json</code> 文件：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">npm</span> init -y<br></code></pre></td></tr></table></figure><p>紧接着，我们在根目录下创建一个 <code>src</code> 文件夹、<code>loader</code> 文件夹以及其子文件 <code>md2html-loader.js</code> 和 <code>webpack.config.js</code> 文件，并且在 <code>src</code> 下创建 <code>index.md、main.js</code>，成功之后我们的文件夹目录应该是：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">+ src<br>  - index<span class="hljs-selector-class">.md</span><br>  - main<span class="hljs-selector-class">.js</span><br>+ loader<br>  - md2html-loader<span class="hljs-selector-class">.js</span><br>- package<span class="hljs-selector-class">.json</span><br>- webpack<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><p>我们利用 <code>cnpm</code> 一次性将所需要的依赖全部安装完成。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">cnpm install --<span class="hljs-keyword">save</span>-dev html-webpack-<span class="hljs-keyword">plugin</span> webpack webpack-<span class="hljs-keyword">cli</span> marked clean-webpack-<span class="hljs-keyword">plugin</span><br></code></pre></td></tr></table></figure><p>我们看看下载成功之后的依赖分别都是什么版本。发现 <code>clean-webpack-plugin</code> 是 <code>3.0.0</code>，在使用的时候我们需要解构出构造函数从而实例化，否则 <code>webpack</code> 会抛出<code>TypeError: CleanWebpackPlugin is not a constructor</code>的错误。</p><ul><li><code>package.json</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">"devDependencies": &#123;<br>  "clean-webpack-plugin": "^3.0.0",<br>  "html-webpack-plugin": "^4.5.1",<br>  "marked": "^1.2.7",<br>  "webpack": "^5.17.0",<br>  "webpack-cli": "^4.4.0"<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编写文件内容"><a href="#编写文件内容" class="headerlink" title="编写文件内容"></a>编写文件内容</h2><ul><li><code>index.md</code></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment"># 今天是 2021 年，开始认真工作的一天</span><br><br>这是一个段落<br><br>- 这是第一项<br>- 这是第二项<br><br>这是一段落`code`<br><br>const <span class="hljs-keyword">a</span> = <span class="hljs-string">'webpack-demo'</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'a'</span>, <span class="hljs-keyword">a</span>)<br></code></pre></td></tr></table></figure><ul><li><code>main.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> md <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.md"</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"md"</span>, md);<br></code></pre></td></tr></table></figure><ul><li><code>md2html-loader.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"source"</span>, source);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">"source"</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>webpack.config.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">"webpack"</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<br><span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"clean-webpack-plugin"</span>);<br><br><span class="hljs-comment">// 增加Configuration是为了配置的key提示</span><br><span class="hljs-comment">/**<br> * @type &#123;webpack.Configuration&#125;<br> */</span><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">"./src/main.js"</span>,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">"bundle.js"</span>,<br>    <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">"dist"</span>)<br>  &#125;,<br>  <span class="hljs-attr">mode</span>: <span class="hljs-string">"development"</span>,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.md$/</span>,<br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">"./loader/md2html-loader.js"</span>]<br>      &#125;<br>    ]<br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> CleanWebpackPlugin(), <span class="hljs-keyword">new</span> HtmlWebpackPlugin()]<br>&#125;;<br><br><span class="hljs-built_in">module</span>.exports = config;<br></code></pre></td></tr></table></figure><p>在终端输入 <code>npx webpack</code> 之后运行，我们能够发现，打印出了我们 <code>loader</code>文件里打印的 <code>source</code> 的内容，如下：</p><hr><p>source # 今天是 2021 年，开始认真工作的一天</p><p>这是一个段落</p><ul><li>这是第一项</li><li>这是第二项</li></ul><p>这是一段落<code>code</code></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">const <span class="hljs-keyword">a</span> = <span class="hljs-string">'webpack-demo'</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'a'</span>, <span class="hljs-keyword">a</span>)<br></code></pre></td></tr></table></figure><hr><p>从这里我们能发现，其实 <code>loader</code> 接受的参数就是我们 <code>md</code> 文件的内容，所以我们需要将 <code>md</code> 文件转换为 <code>html</code>，就需要使用 <code>marked</code> 方法，继续编写 <code>loader</code> 文件，引入 <code>marked</code>，处理完成 <code>md</code> 文件之后，我们再将处理的文件组成文件内容导出。</p><ul><li><code>md2html-loader.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> marked = <span class="hljs-built_in">require</span>(<span class="hljs-string">"marked"</span>);<br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-params">source</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> html = marked(source);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"html"</span>, html);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`module.exports = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(html)&#125;</span>`</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们再去执行，<code>npx webpack</code> 发现终端打印的输出为一段 <code>html</code> 字符串，这就是 <code>md</code> 文件被转换为 <code>html</code>：</p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">html <span class="hljs-variable">&lt;h1 id="今天是-2021-年，开始认真工作的一天"&gt;</span>今天是 2021 年，开始认真工作的一天<span class="hljs-variable">&lt;/h1&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一个段落<span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;ul&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第一项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第二项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;/ul&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一段落<span class="hljs-variable">&lt;code&gt;</span>code<span class="hljs-variable">&lt;/code&gt;</span><span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;pre&gt;</span><span class="hljs-variable">&lt;code&gt;</span>const a = &amp;<span class="hljs-comment">#39;webpack-demo&amp;#39;</span><br>console.log(&amp;<span class="hljs-comment">#39;a&amp;#39;, a)&lt;/code&gt;&lt;/pre&gt;</span><br></code></pre></td></tr></table></figure><hr><p>然后我们再打开 <code>dist</code> 目录下的 <code>index.html</code> 查看页面，<code>F12</code> 打开控制台发现浏览器控制台打印出了以下内容：</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs undefined">md <span class="hljs-variable">&lt;h1 id="今天是-2021-年，开始认真工作的一天"&gt;</span>今天是 2021 年，开始认真工作的一天<span class="hljs-variable">&lt;/h1&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一个段落<span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;ul&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第一项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;li&gt;</span>这是第二项<span class="hljs-variable">&lt;/li&gt;</span><br><span class="hljs-variable">&lt;/ul&gt;</span><br><span class="hljs-variable">&lt;p&gt;</span>这是一段落<span class="hljs-variable">&lt;code&gt;</span>code<span class="hljs-variable">&lt;/code&gt;</span><span class="hljs-variable">&lt;/p&gt;</span><br><span class="hljs-variable">&lt;pre&gt;</span><span class="hljs-variable">&lt;code&gt;</span>const a = &amp;<span class="hljs-comment">#39;webpack-demo&amp;#39;</span><br>console.log(&amp;<span class="hljs-comment">#39;a&amp;#39;, a)&lt;/code&gt;&lt;/pre&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器控制台的内容就是我们 <code>main.js</code> 里打印的内容，至此，说明我们的模块已经生效，<code>md</code> 转为 <code>html</code> 也已经生效，并且当我们看到这个字符串的时候其实就已经明白怎么显示到页面上了。</p><p>于是我们继续编写 <code>main.js</code>将 html 字符串渲染到页面上：</p><ul><li><code>main.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> md <span class="hljs-keyword">from</span> <span class="hljs-string">"./index.md"</span>;<br><span class="hljs-comment">// console.log("md", md);</span><br><span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"div"</span>);<br>ele.innerHTML = md;<br><span class="hljs-built_in">document</span>.body.appendChild(ele);<br></code></pre></td></tr></table></figure><p>继续运行，<code>npx webpack</code>，然后我们刷新刚刚的页面，发现生成的 <code>html</code> 字符串已经被我们渲染到页面上了。</p><p>至此一个 <code>md</code> 转换为 <code>html</code> 并且显示在页面的简单 <code>loader</code> 已经完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pipe 和 compose 在 javascript 中的应用</title>
    <link href="/2021/01/17/pipeAndCompose/"/>
    <url>/2021/01/17/pipeAndCompose/</url>
    
    <content type="html"><![CDATA[<p>函数式编程的中从左往右的 <code>pipe</code> 函数和从右往左的 <code>compose</code> 函数，在 <code>js</code> 中的一些应用场景。</p><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><p>也称为管道函数，它接受 <code>n</code> 多个函数，依次从左往右执行，用最后一个函数作为最终的输出。用于改善函数嵌套调用，一个简单的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`我是第一个函数，我获取我的参数「<span class="hljs-subst">$&#123;params&#125;</span>」并且返回`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`我接受了第一个函数的返回值「<span class="hljs-subst">$&#123;params&#125;</span>」，作为我的参数，然后和我的数据拼接再返回`</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">end</span> (<span class="hljs-params">params</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`我是最后的数据的拼接处理，结合了first函数和second的返回值「<span class="hljs-subst">$&#123;params&#125;</span>」`</span><br>&#125;<br><br>end(second(first(<span class="hljs-string">`hi～我来了！💐`</span>)))<br></code></pre></td></tr></table></figure><p>最终返回： “我是最后的数据的拼接处理，结合了 <code>first</code> 函数和 <code>second</code> 的返回值「我接受了第一个函数的返回值「我是第一个函数，我获取我的参数「<code>hi</code> ～我来了！💐」并且返回」，作为我的参数，然后和我的数据拼接再返回」”</p><p>能看到的是，函数之间形成一种关系，即后一个函数接受上一个函数的返回值作为参数，本例中也就是 <code>end</code> 函数接受 <code>second</code> 的返回值作为参数，而 <code>second</code> 的返回值又是接受 <code>first</code> 的返回值作为参数。</p><p>其实能看到 <code>end(second(first()))</code>这么调用嵌套不直观，我们用<code>reduce</code>实现管道 <code>pipe</code> 依次调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> pipe = <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> arg.reduce(<span class="hljs-function">(<span class="hljs-params">res, callback</span>) =&gt;</span> callback(res), result)<br></code></pre></td></tr></table></figure><p>调用 <code>pipe(first, second, end)(&#39;hi ～我来了！💐&#39;)</code>，会将参数先传递给 <code>first</code>，然后处理成功之后，再将结果作为 <code>second</code> 的参数，传递，<code>second</code> 处理完成之后，将结果作为 <code>end</code> 函数的参数，在 <code>end</code> 函数处理完成之后，将所有结果返回。最终 <code>pipe</code> 函数调用的结果，将会上边函数嵌套执行的结果一致。</p><h2 id="compose"><a href="#compose" class="headerlink" title="compose"></a>compose</h2><p>组合函数和 <code>pipe</code> 原理都是一样的，只不过是其调用顺序是从右往左。</p><p>组合函数在 <code>webpack</code> 的 <code>loader</code> 中也有应用，本例中的 <code>pipe</code> 是从左往右依次执行，<code>webpack</code> 的 <code>loader</code> 是从右向左执行（<code>compose）</code>，其实可以利用 <code>reduceRight</code> 实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> compose = <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> <span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> arg.reduceRight(<span class="hljs-function">(<span class="hljs-params">res, callback</span>) =&gt;</span> callback(res), result)<br></code></pre></td></tr></table></figure><p>这里的话，如果上述的例子是通过 <code>compose</code> 函数来实现的话，应该是 <code>compose(first, second, end)(&#39;hi ～我来了！💐&#39;)</code>，最外边的参数应该先是给 <code>end</code> 函数，处理完成之后再给 <code>second</code>，最终给 <code>first</code>，由 <code>first</code> 处理，最终返回结果。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果一个数据最终结果，是需要经过很多函数的处理，并且那些函数，需要用上一个函数的返回值作为下一个函数的参数，这种场景下可以考虑使用 <code>pipe</code> 或者 <code>compose</code> 函数来处理，其实使用 <code>pipe</code> 或者 <code>compose</code> 都是可以的，只需要保证传入的函数的顺序是按照数据正确执行的函数顺序即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reduce高级函数的一些应用</title>
    <link href="/2021/01/15/jsReduceFunction/"/>
    <url>/2021/01/15/jsReduceFunction/</url>
    
    <content type="html"><![CDATA[<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>在最近的工作中，<code>reduce</code> 成为了出境率和使用率非常高的一个高阶函数，所以总结一下工作中以及 <code>reduce</code> 可能会实现的一些功能。</p><p>先简单说一下 <code>reduce</code> 函数，它的语法为 <code>Array.reduce(callback, [initialValue])</code>，接受的参数是：</p><ul><li>第一个参数为一个回调函数，其回调函数接受四个参数分别为初始值（或者上次的回调函数的返回值）、当前元素、当前索引、原数组。</li><li>第二个参数 <code>initialValue</code> 为可选，如果传递，则 <code>initialValue</code> 作为第一次回调函数的第一个参数。</li></ul><p>需要记住的点是：如果为 <code>reduce</code> 提供 <code>initialValue</code> 参数，则回调函数会从索引为 <code>0</code> 的地方开始执行 <code>callback</code>，否则会从索引为 <code>1</code> 的地方开始执行。</p><p>我们可以用个 <code>demo</code> 验证一下</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="xml"><span class="hljs-comment">&lt;!-- 无初始化参数 --&gt;</span><br><br>let arr = [9, 19, 20]<br>arr.reduce((pre, cur, idx) =&gt; </span><span class="hljs-template-variable">&#123;<br>  console.log(pre, cur, '看索引开始:', idx)<br>  return pre + cur<br>&#125;</span><span class="xml">)<br><br>// 9 19 "看索引开始:" 1<br>// 28 20 "看索引开始:" 2<br>// 48<br><br><span class="hljs-comment">&lt;!-- 有初始化参数 --&gt;</span><br><br>let arr = [9, 19, 20]<br>arr.reduce((pre, cur, idx) =&gt; </span><span class="hljs-template-variable">&#123;<br>  console.log(pre, cur, '看索引开始:', idx)<br>  return pre + cur<br>&#125;</span><span class="xml">, 0)<br><br>// 0 9 "看索引开始:" 0<br>// 9 19 "看索引开始:" 1<br>// 28 20 "看索引开始:" 2<br>// 48</span><br></code></pre></td></tr></table></figure><h3 id="数组求和"><a href="#数组求和" class="headerlink" title="数组求和"></a>数组求和</h3><ul><li>简单数组求和</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br>arr.reduce((pre, cur) =&gt; pre + cur, <span class="hljs-number">0</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><ul><li>复杂一点的，数组对象中的数据</li></ul><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let <span class="hljs-built_in">list</span> = [<br>  &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">'苹果'</span>,<br>    <span class="hljs-built_in">count</span>: <span class="hljs-number">20</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">'香蕉'</span>,<br>    <span class="hljs-built_in">count</span>: <span class="hljs-number">40</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-built_in">name</span>: <span class="hljs-string">'猕猴桃'</span>,<br>    <span class="hljs-built_in">count</span>: <span class="hljs-number">90</span>,<br>  &#125;<br>]<br><span class="hljs-built_in">list</span>.reduce((pre, cur) =&gt; pre + cur.<span class="hljs-built_in">count</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 150</span><br></code></pre></td></tr></table></figure><h3 id="统计字符串出现的次数"><a href="#统计字符串出现的次数" class="headerlink" title="统计字符串出现的次数"></a>统计字符串出现的次数</h3><p>利用 <code>{}</code> 对象来判断是否能取到当前值，获取不到则表示当前元素没有，设置次数为 <code>1</code>，有则次数递增。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var str = <span class="hljs-string">'aabcddeffghhijklllm'</span><br>str.<span class="hljs-keyword">split</span>(<span class="hljs-string">''</span>).reduce((<span class="hljs-keyword">pre</span>, cur) =&gt; &#123;<br>  <span class="hljs-keyword">pre</span>[cur] ? <span class="hljs-keyword">pre</span>[cur]++ : <span class="hljs-keyword">pre</span>[cur] = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">pre</span><br>&#125;, &#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>利用 <code>includes</code> 判断上次累加的数组中是否具有当前值，没有的话就将当前值和上次的返回值连接起来返回，有的话直接返回上一次的结果。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var arr = <span class="hljs-comment">[1, 2, 2, 2, 3, 3, 4, 5, 5]</span><br>arr.reduce((pre, cur) =&gt; !pre.includes(cur) ? <span class="hljs-comment">[...pre, ...<span class="hljs-comment">[cur]</span>]</span> : pre, <span class="hljs-comment">[]</span>)<br></code></pre></td></tr></table></figure><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><ul><li>二维简单数组</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var arr = <span class="hljs-comment">[<span class="hljs-comment">[1, 2]</span>, <span class="hljs-comment">[3, 4]</span>, <span class="hljs-comment">[5]</span>]</span><br>arr.reduce((pre, cur) =&gt; <span class="hljs-comment">[...pre, ...cur]</span>, <span class="hljs-comment">[]</span>)<br>// <span class="hljs-comment">[1, 2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure><ul><li>复杂的高纬度数组</li></ul><p>利用递归扁平深层嵌套的数组。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">var arr = <span class="hljs-comment">[<span class="hljs-comment">[1, 2, <span class="hljs-comment">[<span class="hljs-comment">[3, 4]</span>, <span class="hljs-comment">[5, 6]</span>]</span>]</span>, <span class="hljs-comment">[3, <span class="hljs-comment">[<span class="hljs-comment">[7, 8]</span>, <span class="hljs-comment">[8, 1]</span>]</span>]</span>, <span class="hljs-comment">[5, <span class="hljs-comment">[<span class="hljs-comment">[5, 4]</span>, <span class="hljs-comment">[9, 10]</span>]</span>]</span>]</span><br>var flat = (arr) =&gt; arr.reduce((pre, cur) =&gt; <span class="hljs-comment">[...pre, ...(Array.isArray(cur) ? flat(cur) : <span class="hljs-comment">[cur]</span>)]</span>, <span class="hljs-comment">[]</span>)<br>flat(arr)<br>// <span class="hljs-comment">[1, 2, 3, 4, 5, 6, 3, 7, 8, 8, 1, 5, 5, 4, 9, 10]</span><br></code></pre></td></tr></table></figure><p><code>ES6</code> 的解决办法：<br>使用数组的 <code>flat</code> 方法，语法 <code>arr.flat([depth])</code>，<code>depth</code> 参数为深度，不传参数默认扁平 <code>1</code> 级嵌套，可以输入关键字 <code>Infinity</code> 实现任何层数嵌套的扁平。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现一个简单的 vue 中的 EventBus</title>
    <link href="/2021/01/14/concisEventBus/"/>
    <url>/2021/01/14/concisEventBus/</url>
    
    <content type="html"><![CDATA[<p>先分析一下 <code>vue</code> 中的一些用法</p><h3 id="on-注册"><a href="#on-注册" class="headerlink" title="on 注册"></a><code>on</code> 注册</h3><ul><li><code>this.$on(&#39;eventName&#39;, (...params) =&gt; {})</code><br>其实我们在使用的过程中可以发现，<code>$on</code>的事件可以注册多次，也就是说可以在很多组件里进行一个事件的注册，在<code>$emit</code> 触发相应的事件的时候，对应注册的所有事件都会执行回调函数，所以我们能想到它的实现一定是，如果在一个对象中，注册了相同的事件，会一直往当前的这个事件数组的集合中追加回调函数。</li></ul><h3 id="emit触发"><a href="#emit触发" class="headerlink" title="emit触发"></a><code>emit</code>触发</h3><ul><li><code>this.$emit(&#39;eventName&#39;, params)</code><br>上一步提到，<code>$emit</code> 的时候，相应注册的事件都会执行回调函数，而且 <code>on</code> 注册的是一个数组，所以其实现应该是遍历 <code>emit</code> 事件所对应的数组，依次执行 <code>callback</code> 并且将参数传递出去。</li></ul><h3 id="once-一次触发"><a href="#once-一次触发" class="headerlink" title="once 一次触发"></a><code>once</code> 一次触发</h3><ul><li><code>this.$once(&#39;eventName&#39;, (...params) =&gt; {})</code><br>触发一次，它的实现应该是无需判断之前事件有没有注册，要是注册直接放进去，也就是说，注册相同的事件后者会覆盖掉前者，注册新的会增加。</li></ul><h3 id="off移除"><a href="#off移除" class="headerlink" title="off移除"></a><code>off</code>移除</h3><ul><li><code>this.$off(&#39;eventName)</code><br><code>off</code> 也很简单，就是直接用对象上删掉当前的事件。</li></ul><p>在 <code>vue2.0</code> 的 <code>SFC</code> 中，<code>this</code> 指向是 <code>new Vue()</code>的实例 <code>vm</code>，因为其上实例上已经具有 <code>eventBus</code> 的方法，所以可以使用。</p><p>伪代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs undefined">let EventBus = &#123;<br>  taskMap: &#123;&#125;,<br>  $on(eventName, fn) &#123;<br>    <span class="hljs-comment">&lt;!-- 如果map中无注册事件，则将事件推入，如果有注册的事件，继续往里追加 --&gt;</span><br>    if (!this.taskMap[eventName]) &#123;<br>      this.taskMap[eventName] = [fn]<br>    &#125; else &#123;<br>      this.taskMap[eventName].push(fn)<br>    &#125;<br>  &#125;,<br>  $emit(eventName, ...msg) &#123;<br>    if (!this.taskMap[eventName]) &#123;<br>      return<br>    &#125; else &#123;<br>      <span class="hljs-comment">&lt;!-- 遍历注册过的事件，依次执行 --&gt;</span><br>      this.taskMap[eventName].forEach(callback =&gt; callback(...msg))<br>    &#125;<br>  &#125;,<br>  $once(eventName, fn) &#123;<br>    <span class="hljs-comment">&lt;!-- 不需要判断，后来的覆盖前边的 --&gt;</span><br>    this.taskMap[eventName] = [fn]<br>  &#125;,<br>  $off(eventName) &#123;<br>    if (!this.taskMap[eventName]) &#123;<br>      return<br>    &#125; else &#123;<br>      <span class="hljs-comment">&lt;!-- 删掉注册的事件 --&gt;</span><br>      Reflect.deleteProperty(this.taskMap, [eventName])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-regexp">//</span> 注册<br>EventBus.$<span class="hljs-literal">on</span>(<span class="hljs-string">'begin'</span>, <span class="hljs-function"><span class="hljs-params">(...x)</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(...x)&#125;)<br>EventBus.$<span class="hljs-literal">off</span>(<span class="hljs-string">'begin'</span>)<br>EventBus.$emit(<span class="hljs-string">'begin'</span>, <span class="hljs-string">'参数1000000'</span>, <span class="hljs-string">'参数2'</span>) <span class="hljs-regexp">//</span> 不会触发<br>EventBus.$once(<span class="hljs-string">'begin'</span>, <span class="hljs-function"><span class="hljs-params">(...x)</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(x)&#125;)<br>EventBus.$emit(<span class="hljs-string">'begin'</span>, <span class="hljs-string">'🍅'</span>, <span class="hljs-string">'🍉'</span>) <span class="hljs-regexp">//</span> 触发一次once [<span class="hljs-string">"🍅"</span>, <span class="hljs-string">"🍉"</span>]<br>EventBus.$<span class="hljs-literal">off</span>(<span class="hljs-string">'begin'</span>)<br><br>EventBus.$<span class="hljs-literal">on</span>(<span class="hljs-string">'begin'</span>, <span class="hljs-function"><span class="hljs-params">(...x)</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(...x, <span class="hljs-string">'1'</span>)&#125;)<br>EventBus.$<span class="hljs-literal">on</span>(<span class="hljs-string">'begin'</span>, <span class="hljs-function"><span class="hljs-params">(...x)</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(...x, <span class="hljs-string">'2'</span>)&#125;)<br>EventBus.$emit(<span class="hljs-string">'begin'</span>, <span class="hljs-string">'🏃‍♀️'</span>, <span class="hljs-string">'🚢'</span>) <span class="hljs-regexp">//</span> 触发<span class="hljs-number">2</span>次<span class="hljs-literal">on</span> 🏃‍♀️，🚢，<span class="hljs-number">1</span>  🏃‍♀️，🚢，<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨深组件传递数据和调用方法</title>
    <link href="/2021/01/03/useContext/"/>
    <url>/2021/01/03/useContext/</url>
    
    <content type="html"><![CDATA[<p>在父子组件传递数据的时候，<code>react</code> 最常用的</p><h4 id="传统简单的组件通信方式"><a href="#传统简单的组件通信方式" class="headerlink" title="传统简单的组件通信方式"></a>传统简单的组件通信方式</h4><ul><li>父组件 —&gt; 子组件 <code>props</code></li><li>子组件 —&gt; 父组件 <code>callback</code><br>但是有一些特殊的情况，比如是嵌套比较深的组件，<code>A—&gt;B—&gt;C—&gt;D</code> 嵌套，一旦这种结果使用 <code>props</code> 传递数据，就会显得组件非常臃肿，而 <code>react</code> 有提供方式来解决，即 <code>useContext</code></li></ul><h4 id="嵌套深的组件的通信"><a href="#嵌套深的组件的通信" class="headerlink" title="嵌套深的组件的通信"></a>嵌套深的组件的通信</h4><ul><li><code>React.createContext</code></li><li><code>useContext</code></li></ul><p>假如现在有依赖关系的，组件 <code>A-&gt;B-&gt;C</code>，<code>useContext</code> 使用小结:</p><p>可以全局维护一个 <code>context.ts</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// 利用 React.CreateContext api 创建一个带有默认值的context</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> CreateContextData = React.createContext(<span class="hljs-string">''</span>)<br></code></pre></td></tr></table></figure><p><code>A.jsx</code><br>必须要使用 <code>Provider</code> 并且将数据以 <code>value</code> 的形式传递下去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> A = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">'react'</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CreateContextData.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;text&#125;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">B</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">CreateContextData.Provider</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>B.jsx</code><br>中间组件不用在意 <code>A</code> 往下传递的参数和数据是什么，其只需要保证 <code>B</code> 和 <code>C</code> 的接口稳定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> B = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>大纲<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">C</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  )<br>&#125;<br></code></pre></td></tr></table></figure><p><code>C.jsx</code><br>通过获取全局创建的 <code>context</code> 对象来获取 <code>A</code> 组件的通信数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> &#123; CreateContextData &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./context.js'</span><br><br><span class="hljs-keyword">const</span> C = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 通过useContext获取context的数据 一定要传入创建的上下文实例 否则获取不到数据</span><br>  <span class="hljs-keyword">const</span> initText = useContext(CreateContextData)<br>  <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;&gt;</span>我正在学习&#123;initText&#125;<span class="hljs-tag">&lt;/&gt;</span>)<br>&#125;</span><br></code></pre></td></tr></table></figure><p>如果嵌套的组件，子组件中也有 <code>provider</code> 提供，则按照最近的取值，一般正常的使用方式就是最顶层组件增加 <code>provider</code></p><p>每次创建的的上下文实例，都需要导出，所以可以用统一的文件管理这种创建的上下文，最后 <code>export</code> 以及在需要的地方 <code>import</code></p><p>透传不仅仅可以是 <code>state</code>，还可以是父组件的方法，在深层组件获取之后，可以直接修改父组件数据</p><p>调用了 <code>useContext</code> 的组件总会在 <code>context</code> 值变化时重新渲染，如果组件渲染开销太大，可以使用 <code>useMome</code> 包装一下</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记住一次关于node中间层处理的文件上传</title>
    <link href="/2021/01/01/uploadFile/"/>
    <url>/2021/01/01/uploadFile/</url>
    
    <content type="html"><![CDATA[<p>公司项目的架构是 <code>umi</code> —&gt;  <code>nodejs</code> —&gt; <code>api</code></p><p>在最近一次的需求中，有一个批量上传的功能，大体的交互是：在 <code>excel</code> 里先填写好数据，<code>web</code> 通过上传文件来在页面表格里预览，然后再将 <code>excel</code> 文件绑定一些表单的数据一起打包发送给后台，有点类似于表单中嵌套了文件上传，最后再提交表单。</p><h4 id="一些想法和对交互的调整"><a href="#一些想法和对交互的调整" class="headerlink" title="一些想法和对交互的调整"></a>一些想法和对交互的调整</h4><p>最初的页面设计是放在步骤条里一共分为三步。上传在步骤条的第一步，表单在第二步，<code>ant-design</code> 的步骤条在切换上下步骤之后，上一个组件的 <code>dom</code> 会销毁，导致第二步无法获取到第一步在上传的时候生成的文件对象，也就无法上传文件。于是后来调整页面，将表单和上传文件放在一个页面，这样在解析文件成功之后，在当前这一步里就能一直获取到文件的对象，拿到文件对象就可以向接口发起请求。</p><h4 id="未使用-ant-design-上传组件的原因"><a href="#未使用-ant-design-上传组件的原因" class="headerlink" title="未使用 ant-design 上传组件的原因"></a>未使用 <code>ant-design</code> 上传组件的原因</h4><p><code>ant-design</code> 的 <code>Upload</code> 组件上传之后的文件对象会立马返回，但是前端无法将这个对象一直拿着在提交的时候再给接口，因为文件对象的一些 <code>key</code> 不能拷贝过去【也是这次才发现只有 <code>uid</code> 一个字段可以遍历】，而且在通过 <code>document.getElementById(&#39;file&#39;).files</code> 获取上传的文件对，其 <code>FileList</code> 是 <code>{length: 0}</code>，所以后来选择利用原生 <code>input</code> 来解决问题，通过创建 <code>ref</code> 将 <code>input</code> 的 <code>dom</code> 属性存起来，然后将 <code>ref</code> 获取的属性返回到父组件，在父组件里提交的时候，获取 <code>ref</code> 中的文件对象，传递给接口。</p><h4 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h4><ul><li>创建 <code>ref</code> 对象来存储 <code>input</code> <code>dom</code> 属性</li><li>初始化利用 <code>addEventListener</code> 来监听原生 <code>input</code> 的 <code>change</code> 事件</li><li>利用 <code>button</code> 覆盖默认的上传样式，点击 <code>button</code> 的时候模拟触发点击 <code>input</code> 上传</li><li>捕获到事件之后，成功获取到文件对象，依次将文件对象传递给 <code>xlsx</code> 来解析为 <code>json</code> 数据，再将 <code>json</code> 数据传递给 <code>and-table</code> 来显示预览、将 <code>input</code> 的 <code>ref</code> 属性值回传到父组件（<code>handleFileInputRefs</code> 方法是父组件传递的 <code>props</code> 来获取自组件的 <code>input ref</code>）</li><li>父组件中也已经接受了表单的数据，并且接受了 <code>input</code> 的属性，通过 <code>FormData</code> 将数据和文件混传给 <code>node</code> 的 <code>controller</code></li><li><code>controller</code> 获取到文件对象和额外的表单参数，再向真正的接口发起请求</li></ul><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><h5 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h5><p>子组件 <code>paresExcel.tsx</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> ONE_M_TO_BYTES: number = <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">const</span> MAX_FILE_SIZE: number = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">// 初始化定义ref来存储input dom对象，这个对象里的files对象可以一直获取到</span><br><span class="hljs-keyword">const</span> uploadInput = useRef(<span class="hljs-keyword">null</span>);<br><br><span class="hljs-comment"><span class="markdown">/**<br><span class="hljs-bullet"> * </span>获取column的对象key，数组转对象<br><span class="hljs-bullet"> * </span>tableColumnKey 是父组件传递回来的table的json，类似<br><span class="hljs-bullet"> *<br> </span>* [&#123;<br><span class="hljs-bullet"> *    </span>title: '关键词',<br><span class="hljs-bullet"> *    </span>dataIndex: 'word',<br><span class="hljs-bullet"> *    </span>key: 'word',<br><span class="hljs-bullet"> *  </span>&#125;,<br><span class="hljs-bullet"> *  </span>&#123;<br><span class="hljs-bullet"> *    </span>title: '豁免词',<br><span class="hljs-bullet"> *    </span>dataIndex: 'exWord',<br><span class="hljs-bullet"> *    </span>key: 'exWord',<br><span class="hljs-bullet"> *  </span>&#125;]<br> */</span></span><br><span class="hljs-keyword">const</span> formatTitleOrFileld = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> entozh = tableColumnKey.map((item, index) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      index,<br>      key: item.key,<br>    &#125;;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> entozh;<br>&#125;;<br><br><span class="hljs-comment"><span class="markdown">/**<br><span class="hljs-bullet"> * </span>这个方法其实就是将数据转为表格可以用的json<br> */</span></span><br><span class="hljs-keyword">const</span> handleImpotedJson = () =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [header, ...tableBody] = jsonArr;<br>  <span class="hljs-keyword">const</span> keysArr = formatTitleOrFileld();<br>  <span class="hljs-keyword">const</span> len = header.length;<br><br>  <span class="hljs-comment">// 稀疏数组补全empty项，因为excel中有的数据是空，解析出来的数据是索引不连续的，这一步的目的就是补全index</span><br>  tableBody.forEach((item: any) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt;= len - <span class="hljs-number">1</span>; i++) &#123;<br>      item[i] = item[i] || <span class="hljs-string">''</span>;<br>    &#125;<br>  &#125;);<br><br>  <span class="hljs-comment"><span class="markdown">/**<br><span class="hljs-bullet">   * </span>将解析的excel数据转换为ant-table支持渲染的数据格式<br>   */</span></span><br>  <span class="hljs-keyword">const</span> parsedExcelData = tableBody.map((ele: any) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> newitem = &#123;&#125;;<br>    ele.forEach((im: any, i: number) =&gt; &#123;<br>      <span class="hljs-keyword">const</span> newKey = keysArr[i].key;<br>      newitem[newKey] = im;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> newitem;<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment"><span class="markdown">/**<br><span class="hljs-bullet"> * </span>上传文件的方法，主要做一些文件大小的判断、文件的读取将excel的数据转换为json<br><span class="hljs-bullet"> * </span>这里有一个比较重要的方法是，解析完成的json数据，实际上是没有key的<br><span class="hljs-bullet"> * </span>表格在展示的时候需要key对应上，value才会在表格里显示，所以需要调方法处理一下<br> */</span></span><br><span class="hljs-keyword">const</span> beforeUpload = (file: any) =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (file.size / ONE_M_TO_BYTES &gt; MAX_FILE_SIZE) &#123;<br><br>    message.warning(<span class="hljs-string">'请上传小于10M的文件！'</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span><br><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br><br>    <span class="hljs-keyword">const</span> f = file;<br>    <span class="hljs-keyword">const</span> reader = <span class="hljs-keyword">new</span> FileReader();<br><br>    reader.onload = function(e) &#123;<br>      <span class="hljs-keyword">const</span> datas = e?.target?.result;<br>      <span class="hljs-comment">// 解析datas</span><br>      <span class="hljs-keyword">const</span> workbook = XLSX.read(datas, &#123;<br>        type: <span class="hljs-string">'binary'</span>,<br>      &#125;);<br><br>      <span class="hljs-comment">// 是工作簿中的工作表的有序列表</span><br>      <span class="hljs-keyword">const</span> first_worksheet = workbook.Sheets[workbook.SheetNames[<span class="hljs-number">0</span>]];<br>      <span class="hljs-comment">// 将工作簿对象转换为JSON对象数组</span><br>      <span class="hljs-keyword">const</span> jsonArr = XLSX.utils.sheet_to_json(first_worksheet, &#123; header: <span class="hljs-number">1</span> &#125;);<br><br>      handleImpotedJson(jsonArr);<br>    &#125;;<br><br>    reader.readAsBinaryString(f);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在事件监听文件的change的回调函数中，获取到文件对象之后调用方法来将excel数据解析为json</span><br><span class="hljs-keyword">const</span> handleUpload = () =&gt; &#123;<br>  beforeUpload(uploadInput?.current?.files[<span class="hljs-number">0</span>]);<br>&#125;;<br><br><span class="hljs-comment">// 点击按钮的时候，触发input的上传click事件</span><br><span class="hljs-keyword">const</span> handleFakeUpload = () =&gt; &#123;<br>  uploadInput?.current?.click();<br>&#125;;<br><br>useEffect(() =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>) &#123;<br>    <span class="hljs-comment"><span class="markdown">/**<br><span class="hljs-bullet">      * </span>监听input上传事件 在得到文件流之后 把input的ref回传到父组件<br><span class="hljs-bullet">      * </span>并且解析文件转为json来在表格里显示<br><span class="hljs-code">      */</span></span></span><br>    <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(`[name=uploadExcel]`)!.addEventListener(<span class="hljs-string">'change'</span>, function(event) &#123;<br>      <span class="hljs-keyword">if</span> (event?.target &amp;&amp; event?.target?.files) &#123;<br>        handleFileInputRefs &amp;&amp; handleFileInputRefs(uploadInput);<br>        handleUpload();<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;, []);<br><br><span class="hljs-keyword">return</span> (<br>  &lt;div className=<span class="hljs-string">"fix-input-button"</span>&gt;<br>    &lt;input type=<span class="hljs-string">"file"</span> name=<span class="hljs-string">"uploadExcel"</span> ref=&#123;uploadInput&#125; /&gt;<br>    &lt;Button icon=&#123;&lt;Iconfont name=<span class="hljs-string">"iconshangchuan"</span> /&gt;&#125; onClick=&#123;handleFakeUpload&#125;&gt;<br>      上传<br>    &lt;/Button&gt;<br>  &lt;/div&gt;<br>)<br></code></pre></td></tr></table></figure><p>父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// uploadRefs 是useState定义的保存ref的变量</span><br><br><span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> FormData();<br><br>formData.append(<span class="hljs-string">'fileStream'</span>, uploadRefs?.current?.files[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 接口还需要一些别的参数</span><br>formData.append(<span class="hljs-string">'connectBusiness'</span>, <span class="hljs-built_in">JSON</span>.stringify(connectBusiness));<br><span class="hljs-comment">/**<br>  * 这里不能设置请求头<br>  * 浏览器检测到后自己加上 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXXXx 这样<br>  */</span><br>setIsLoading(<span class="hljs-literal">true</span>)<br>fetch(<span class="hljs-string">'/api/appName/parseExcelUpload'</span>, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">'post'</span>,<br>  <span class="hljs-attr">body</span>: formData,<br>&#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>  .then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'err'</span>, err);<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    setIsLoading(<span class="hljs-literal">false</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure><h5 id="node-层"><a href="#node-层" class="headerlink" title="node 层"></a><code>node</code> 层</h5><p><code>node</code> 用的是 <code>thinkjs</code>，<code>controller</code> 其实很简单，包装一下然后请求真正的接口避免直接调接口跨域</p><p>伪代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">const</span> Base = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../base'</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">'request'</span>);<br><br><span class="hljs-keyword">const</span> UPLOAD_SERVICE = <span class="hljs-string">'http://xxx'</span>;<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span> </span>&#123;<br><br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-keyword">super</span>(props)<br>  &#125;<br><br>  <span class="hljs-keyword">async</span> parseExcelUploadAction() &#123;<br><br>    <span class="hljs-comment">// 获取文件信息</span><br>    <span class="hljs-keyword">const</span> files = <span class="hljs-keyword">this</span>.file(<span class="hljs-string">'fileStream'</span>);<br><br>    <span class="hljs-comment">// 利用request发起请求</span><br>    <span class="hljs-keyword">var</span> req = request.post(UPLOAD_SERVICE, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, resp, body</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-keyword">this</span>.json(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-string">'failed'</span>,<br>          <span class="hljs-attr">msg</span>: <span class="hljs-string">`上传失败，url:<span class="hljs-subst">$&#123;UPLOAD_SERVICE&#125;</span>`</span><br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">this</span>.json(&#123;<br>          <span class="hljs-attr">status</span>: <span class="hljs-string">'success'</span>,<br>          <span class="hljs-attr">data</span>: body<br>        &#125;)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'返回请求'</span> + body);<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-keyword">var</span> form = req.form();<br><br>    <span class="hljs-comment">// request上传文件的时候需要append一些stream和string</span><br>    <span class="hljs-comment">// node也会自己获取前端上传发起请求的头 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryXXXx</span><br>    form.append(<span class="hljs-string">'file'</span>, fs.createReadStream(files.path), &#123;<br>      <span class="hljs-attr">filename</span>: files.name,<br>      <span class="hljs-attr">contentType</span>: <span class="hljs-string">'application/vnd.ms-excel'</span><br>    &#125;);<br><br>    form.append(<span class="hljs-string">'connectBusiness'</span>, <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.post(<span class="hljs-string">'connectBusiness'</span>)));<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>至此通过 <code>node</code> 中间层来上传的一个功能实现了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>umi 中使用 iconfont</title>
    <link href="/2020/12/21/umiUseIconfont/"/>
    <url>/2020/12/21/umiUseIconfont/</url>
    
    <content type="html"><![CDATA[<p><code>ant-design</code> 自带的 <code>icon</code> 种类太少，遂找替代方案 <code>iconfont</code>。</p><p>首先需要创建一个函数组件，使其接受一个名为 <code>name</code> 或者 <code>type</code> 的参数，用来指定当前渲染的 <code>icon</code> 名称。</p><p><code>Iconfont.tsx</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">'./index.less'</span>;<br><br>interface IconfontProps &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  className?: string;<br>&#125;<br><br><span class="hljs-keyword">const</span> Iconfont: React.FC&lt;IconfontProps&gt; = <span class="hljs-function">(<span class="hljs-params">&#123; name, className = <span class="hljs-string">''</span> &#125;</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">icon</span> $&#123;<span class="hljs-attr">className</span>&#125;`&#125; <span class="hljs-attr">aria-hidden</span>=<span class="hljs-string">"true"</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">xlinkHref</span>=<span class="hljs-string">&#123;</span>`#$&#123;<span class="hljs-attr">name</span>&#125;`&#125;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></span><br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Iconfont;<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;!<span class="hljs-selector-tag">--</span> 这其中的样式根据项目调整 <span class="hljs-selector-tag">--</span>&gt;<br><span class="hljs-selector-class">.icon</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">22px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">22px</span>;<br>  <span class="hljs-attribute">vertical-align</span>: -<span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">fill</span>: currentColor;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Umi.rc</code>中配置在 <code>iconfont</code> 中生成的静态资源地址。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">plugins:</span> [<br><span class="hljs-symbol">  scripts:</span> [<br>    &#123;<br><span class="hljs-symbol">      src:</span> `<span class="hljs-comment">//at.alicdn.com/t/font_xxx_jxx.js`,</span><br>    &#125;<br>  ]<br>]<br></code></pre></td></tr></table></figure><p><code>tsx</code> 中使用。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> Iconfont <span class="hljs-keyword">from</span> <span class="hljs-string">'Iconfont'</span><br><br>&lt;Iconfont name=<span class="hljs-string">"xxx"</span>/&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>momentjs 一键切换为 dayjs</title>
    <link href="/2020/12/21/replaceMomentTodayjs/"/>
    <url>/2020/12/21/replaceMomentTodayjs/</url>
    
    <content type="html"><![CDATA[<p>公司 <code>umi</code> 创建的项目中，时间的处理使用的是 <code>momentjs</code>，组件用的 <code>ant-design</code>，而且 <code>ant-design</code> 的日期底层的时间处理也是用的 <code>moment</code>。项目一次打包成功之后发现 <code>moment</code> 占的体积比较大，于是考虑下将 <code>moment</code> 切换为比较小的 <code>dayjs</code>。</p><p><code>.umirc.ts</code> 的默认配置中是支持不将 <code>locale</code> 文件打包进去的，但是需要配置 <code>ignoreMomentLocale:true</code> 来开启，但是虽然开启之后仍然还是有 <code>54kb</code> 左右的大小，于是考虑将其换做 <code>dayjs</code>，具体的是利用 <code>antd-dayjs-webpack-plugin</code> 插件，此插件是已经将 <code>moment</code> 替换为 <code>dayjs</code>，之前项目里写的 <code>import moment from &#39;moment&#39;</code>，可以继续使用，虽然引入的是 <code>moment</code>，但其实引用的是 <code>dayjs</code>，这是因为这个插件的底层 <code>alias</code> 了名称。所以在 <code>dayjs</code> 不支持的一些地方，需要利用 <code>dayjs</code> 的扩展方法来增加，例如我的项目中使用了 <code>utc</code>，所以需要在 <code>global.ts</code> 里先<br><code>var utc = require(&#39;dayjs/plugin/utc&#39;)</code> 引入 <code>dayjs</code> 的 <code>utc</code> 插件，再<code>dayjs.extend(utc)</code> 拓展，使用就可以了。</p><p>而 <code>.umirc.ts</code> 具体的配置，如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> AntdDayjsWebpackPlugin from <span class="hljs-string">'antd-dayjs-webpack-plugin'</span>;<br><br>chainWebpack(<span class="hljs-built_in">config</span>) &#123;<br>  <span class="hljs-built_in">config</span>.plugin(<span class="hljs-string">'dayjs'</span>).use(AntdDayjsWebpackPlugin);<br>&#125;<br></code></pre></td></tr></table></figure><p>至于 <code>ignoreMomentLocale:true</code> 的原理应该是使用的 <code>webpack</code> 的 <code>ContextReplacementPlugin</code></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">chainWebpack(config) &#123;<br><br>  <span class="hljs-regexp">//</span>过滤掉 momnet 的那些不使用的国际化文件 只选择zh-cn<br>  <br>  config<br>    .plugin(<span class="hljs-string">'replace'</span>)<br>    .use(<span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack'</span>).ContextReplacementPlugin)<br>    .tap(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-regexp">/moment[\/\\]locale$/</span>, <span class="hljs-regexp">/zh-cn/</span>];<br>  &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 工具类型使用总结</title>
    <link href="/2020/11/22/TypeScriptUse/"/>
    <url>/2020/11/22/TypeScriptUse/</url>
    
    <content type="html"><![CDATA[<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">interface</span> IMyInfo = &#123;<br>  name: <span class="hljs-built_in">string</span><br>  age: <span class="hljs-built_in">number</span><br>  address: <span class="hljs-built_in">string</span><br>  money: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> BasicSelect = <span class="hljs-string">'name'</span> | <span class="hljs-string">'age'</span><br></code></pre></td></tr></table></figure><h3 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a><code>keyof</code></h3><ul><li>该操作符可以用于获取某种类型的所有键，其返回类型是联合类型。</li><li>例如：<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> <span class="hljs-type">koT </span>= keyof IMyInfo<br><br>// <span class="hljs-keyword">type</span> <span class="hljs-type">koT </span>= <span class="hljs-string">"name"</span> | <span class="hljs-string">"age"</span> | <span class="hljs-string">"address"</span> | <span class="hljs-string">"money"</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h3><ul><li><code>typeof</code> 操作符可以用来获取一个变量声明或对象的类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">naBasicT</span></span> = <span class="hljs-symbol">'name</span>' | <span class="hljs-symbol">'age</span>'<br><br><span class="hljs-comment">// 从T中选择出K的类型作为当前变量的类型</span><br><span class="hljs-keyword">const</span> naData: Pick&lt;IMyInfo, naBasicT&gt;  = &#123;<br>  name: <span class="hljs-symbol">'sss</span>',<br>  age: <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">naT</span></span> = <span class="hljs-keyword">typeof</span> naData<br><br><span class="hljs-comment">// 等价于 </span><br><span class="hljs-comment">// type naT = &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h3><ul><li>遍历枚举类型或判断在不在某一个类型中<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">type</span> Keys = <span class="hljs-string">"a"</span> | <span class="hljs-string">"b"</span> | <span class="hljs-string">"c"</span><br><br><span class="hljs-built_in">type</span> Obj =  &#123;<br>  [<span class="hljs-keyword">P</span> in Keys]: <span class="hljs-built_in">string</span><br>&#125;<br><br>// &#123; <span class="hljs-variable">a:</span> <span class="hljs-built_in">string</span>, <span class="hljs-variable">b:</span> <span class="hljs-built_in">string</span>, <span class="hljs-keyword">c</span>: <span class="hljs-built_in">string</span> &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a><code>extends</code></h3><ul><li>理解为约束比较好<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">type</span> Len = &#123;<br>  <span class="hljs-built_in">length</span>: number<br>&#125;<br><br><span class="hljs-comment">// 利用Len类型来约束T使其具有length的类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLen</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Len</span>&gt; <span class="hljs-params">(arg: T)</span> &#123;</span><br>  <span class="hljs-keyword">return</span> arg.<span class="hljs-built_in">length</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Pick"><a href="#Pick" class="headerlink" title="Pick"></a><code>Pick</code></h3><ul><li><code>Pick&lt;T, K&gt;</code> <code>K</code>可以是一个联合类型 从泛型<code>T</code>中过滤出<code>K</code>联合的类型，第一个参数是基准，第二个参数是需要选择出来的类型的联合，或者单个类型<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">pickT</span> </span>= Pick&lt;IMyInfo, BasicSelect&gt;<br><br><span class="hljs-comment">// 等价于 type nameT = &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a><code>Partial</code></h3><ul><li><code>Partial&lt;T&gt;</code> 将<code>T</code>都变为可选类型<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> <span class="hljs-type">partialT </span>= Partial&lt;IMyInfo&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Required"><a href="#Required" class="headerlink" title="Required"></a><code>Required</code></h3><ul><li><code>Required&lt;T&gt;</code> 将传入的泛型变为必选项<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> <span class="hljs-type">requiredT </span>= Required&lt;partialT&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a><code>Readonly</code></h3><ul><li><code>Readonly&lt;T&gt;</code> 将泛型变为 <code>readonly</code><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> <span class="hljs-type">readonlyT </span>= Readonly&lt;IMyInfo&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Record"><a href="#Record" class="headerlink" title="Record"></a><code>Record</code></h3><ul><li><code>Record&lt;K, T&gt;</code> 将<code>T</code>的类型赋给每一个<code>K</code><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> recodeT = <span class="hljs-keyword">Record</span>&lt;BasicSelect, IMyInfo&gt;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-comment">// type recodeT = &#123;</span><br><span class="hljs-comment">//   name: IMyInfo;</span><br><span class="hljs-comment">//   age: IMyInfo;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Exclude、Extract"><a href="#Exclude、Extract" class="headerlink" title="Exclude、Extract"></a><code>Exclude</code>、<code>Extract</code></h3><ul><li><code>Exclude&lt;T, U&gt;</code> 其中 <code>T</code>，<code>U</code> 比较，排除<code>U</code>和<code>T</code>中共有，返回<code>T</code>中剩下的 返回的是第一个泛型 第一个作为基准<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">type</span> <span class="hljs-type">T1 </span>= <span class="hljs-string">'a'</span> | <span class="hljs-string">'b'</span> | <span class="hljs-string">'c'</span> | <span class="hljs-string">'m'</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">T2 </span>= <span class="hljs-string">'b'</span> | <span class="hljs-string">'c'</span> | <span class="hljs-string">'d'</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-type">excludeT </span>= Exclude&lt;T1, T2&gt;<br>// 等价于 <span class="hljs-keyword">type</span> <span class="hljs-type">excludeT </span>= <span class="hljs-string">"a"</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-type">extractT </span>= Extract&lt;T1, T2&gt;<br>// 等价于 <span class="hljs-keyword">type</span> <span class="hljs-type">extractT </span>= <span class="hljs-string">"b"</span> | <span class="hljs-string">"c"</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Omit"><a href="#Omit" class="headerlink" title="Omit"></a><code>Omit</code></h3><ul><li><code>Omit&lt;T, K&gt;</code> 跟<code>Pick</code>类似，但是功能相反 从<code>T</code>中排除掉<code>K</code>的类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">omitT</span></span> = Omit&lt;IMyInfo, <span class="hljs-symbol">'age</span>'&gt;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-comment">// type omitT = &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   address: string;</span><br><span class="hljs-comment">//   money: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a><code>ReturnType</code></h3><ul><li>从函数的返回值中提取类型<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">userinfo</span> <span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    age: <span class="hljs-number">25</span>,<br>    name: <span class="hljs-string">'jack'</span><br>  &#125;<br>&#125;<br><br>type ObjT = ReturnType&lt;<span class="hljs-keyword">typeof</span> userinfo&gt;<br><br><span class="hljs-comment">// 等同于 type ObjT = &#123;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a><code>Parameters</code></h3><ul><li>从函数的参数中提取出需要的类型<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs undefined">// 定义的参数类型是 <span class="hljs-built_in">string</span>, <span class="hljs-keyword">number</span><br><span class="hljs-built_in">type</span> fnT = &#123;<br>  (name: <span class="hljs-built_in">string</span>, age: <span class="hljs-keyword">number</span>): &#123;<br>    breif: <span class="hljs-built_in">string</span><br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">type</span> TParams = Parameters<span class="hljs-symbol">&lt;fnT&gt;</span><br>// <span class="hljs-built_in">type</span> TParams = [<span class="hljs-built_in">string</span>, <span class="hljs-keyword">number</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInfo</span> <span class="hljs-params">(name: TParams[0], age: TParams[1])</span> &#123;&#125;</span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 2.X 两个不同的运行版本</title>
    <link href="/2020/11/08/vueVersion/"/>
    <url>/2020/11/08/vueVersion/</url>
    
    <content type="html"><![CDATA[<h2 id="Runtime-Only"><a href="#Runtime-Only" class="headerlink" title="Runtime Only"></a><code>Runtime Only</code></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Vue</span>(&#123;<br>  <span class="hljs-attribute">el</span>: <span class="hljs-string">'#app'</span>,<br>  router,<br>  render: h =&gt; <span class="hljs-built_in">h</span>(App)<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>说明：<code>vue-loader+webpack</code>，会在构建的时候将<code>*.vue</code>打包为静态资源文件，最终的文件是已经被预编译之后的静态浏览器可以识别的资源，也是不需要编译器的可以直接运行的，即只有运行时。</li></ul><h2 id="Runtime-Compiler"><a href="#Runtime-Compiler" class="headerlink" title="Runtime + Compiler"></a><code>Runtime + Compiler</code></h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Vue</span>(&#123;<br>  <span class="hljs-attribute">el</span>: <span class="hljs-string">'#app'</span>,<br>  router,<br>  <span class="hljs-attribute">template</span>: <span class="hljs-string">'&lt;App/&gt;'</span>,<br>  <span class="hljs-attribute">components</span>: &#123; App &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>运行时+编译器，在<code>vue-loader+webpack</code>构建的时候，是不会进行编译的，在浏览器运行的时候进行编译。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两种常见的设置锚点的方法</title>
    <link href="/2020/11/06/anchorSetting/"/>
    <url>/2020/11/06/anchorSetting/</url>
    
    <content type="html"><![CDATA[<p>概述：在潜意识里使用最多的应该就是<code>a</code>标签配合其他标签的<code>id</code>属性去做页面锚点跳转，然而在有<code>prompt</code>并且路由在变化的时候会导致一些问题。因为在设置了<code>prompt</code>有数据的话会做离开页面数据不保存或者结束任务的提示逻辑，但是这个<code>prompt</code>又是基于路由的变化来确定有没有触发，所以在使用传统的方法增加锚点的时候<code>url</code>后会追加哈希值导致触发了<code>url</code>变动，<code>prompt</code>没法简单判断出来目前是因为什么事件触发，从而导致在点击锚点的时候触发了<code>prompt</code>提示。正好最近学习了<code>scrollIntoView</code>就正好想着尝试解决一下。</p><ul><li><h2 id="传统的方法利用a标签和id"><a href="#传统的方法利用a标签和id" class="headerlink" title="传统的方法利用a标签和id"></a>传统的方法利用<code>a</code>标签和<code>id</code></h2></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// 设置，用户点击并跳转</span><br>&lt;<span class="hljs-selector-tag">a</span> href=<span class="hljs-string">"#anchorId"</span>&gt;锚点<span class="hljs-number">1</span>&lt;/a&gt;<br><br><span class="hljs-comment">// 待跳转标识的位置，使用id</span><br>&lt;<span class="hljs-selector-tag">div</span> id=<span class="hljs-string">"anchorId"</span>&gt;跳转到锚点<span class="hljs-number">1</span>&lt;/div&gt;<br><br>在点击 “跳转到锚点<span class="hljs-number">1</span>” 的时候就会在url中加入哈希从而实现锚点跳转<br></code></pre></td></tr></table></figure><ul><li><h2 id="利用浏览器h5的新api-scrollIntoView来解决"><a href="#利用浏览器h5的新api-scrollIntoView来解决" class="headerlink" title="利用浏览器h5的新api scrollIntoView来解决"></a>利用浏览器<code>h5</code>的新<code>api scrollIntoView</code>来解决</h2><ul><li>语法说明</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">element.scrollIntoView(); <span class="hljs-comment">// 等同于element.scrollIntoView(true)</span><br>element.scrollIntoView(alignToTop); <span class="hljs-comment">// Boolean型参数</span><br>element.scrollIntoView(scrollIntoViewOptions); <span class="hljs-comment">// Object型参数</span><br></code></pre></td></tr></table></figure><ul><li><p>参数说明</p><ul><li><p><code>alignToTop</code>可选，一个<code>Boolean</code>值：</p><ul><li>如果为<code>true</code>，元素的顶端将和其所在滚动区的可视区域的顶端对齐。相应的 <code>scrollIntoViewOptions: {block: &quot;start&quot;, inline: &quot;nearest&quot;}</code>。这是这个参数的默认值。</li><li>如果为<code>false</code>，元素的底端将和其所在滚动区的可视区域的底端对齐。相应的<code>scrollIntoViewOptions: {block: &quot;end&quot;, inline: &quot;nearest”}</code>。</li></ul></li><li><p><code>scrollIntoViewOptions</code> 可选 一个包含下列属性的对象：</p><ul><li><code>behavior</code> 可选 定义动画过渡效果， <code>auto</code>或 <code>smooth</code> 之一。默认为 <code>auto</code>。</li><li><code>block</code> 可选 定义垂直方向的对齐， <code>start</code>, <code>center</code>, <code>end</code>, 或 <code>nearest</code>之一。默认为 <code>start</code>。</li><li><code>inline</code> 可选 定义水平方向的对齐， <code>start</code>, <code>center</code>, <code>end</code>, 或 <code>nearest</code>之一。默认为 <code>nearest</code>。</li></ul></li></ul></li><li><p>伪代码</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 因为有兼容问题，所以需要用第三方包来处理一下兼容</span><br><span class="hljs-keyword">import</span> smoothscroll <span class="hljs-keyword">from</span> <span class="hljs-string">'smoothscroll-polyfill'</span>;<br>smoothscroll.polyfill();<br><br><span class="hljs-comment">// 在render之前为需要锚点的元素增加data-xxx属性，在触发对应的事件，需要锚点到对应的位置的时候利用api跳转，如果是数组循环下来的结构的话可以将对应的id传递给函数，点击的时候获取对应的元素并且再去执行操作</span><br><br><span class="hljs-keyword">const</span> scrollToAnchor = <span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 利用属性选择器 + querySelector</span><br>  <span class="hljs-keyword">const</span> ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`[data-imageId=<span class="hljs-subst">$&#123;id&#125;</span>]`</span>)<br>  <span class="hljs-keyword">if</span> (ele) &#123;<br>    ele.scrollIntoView(&#123;<span class="hljs-attr">block</span>: <span class="hljs-string">'start'</span>, <span class="hljs-attr">behavior</span>: <span class="hljs-string">'smooth'</span>&#125;)<br>  &#125;<br>&#125;<br><br>&lt;img data-imageId=<span class="hljs-string">"img1"</span> /&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> scrollToAnchor('img1')&#125;&gt;跳转<span class="hljs-tag">&lt;<span class="hljs-name">div</span>/&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>h5-api</tag>
      
      <tag>scrollIntoView</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生实现浏览器支持的图片懒加载方案</title>
    <link href="/2020/11/05/lazyLoad/"/>
    <url>/2020/11/05/lazyLoad/</url>
    
    <content type="html"><![CDATA[<p>概述：因为内部项目运营工具中有遇到处理大量图片在一瞬间请求的场景，在开发阶段遇到了如果不处理图片，不用懒加载的话，浏览器会在一瞬间造成卡顿，用户体验和效果非常差。</p><p>解决方案</p><ul><li><h3 id="未调研的React三方懒加载库"><a href="#未调研的React三方懒加载库" class="headerlink" title="未调研的React三方懒加载库"></a>未调研的<code>React</code>三方懒加载库</h3></li><li><h3 id="img图片的属性loading"><a href="#img图片的属性loading" class="headerlink" title="img图片的属性loading"></a><code>img</code>图片的属性<code>loading</code></h3><p>因为项目采用的是<code>umi+ts</code>，而<code>img</code>属性的<code>loading</code>并未标准化，还处在实验阶段，但是<code>Chrome 76+</code>已经支持。代码中直接在<code>jsx</code>中为<code>img</code>标签加上<code>loading=&quot;lazy&quot;</code>属性之后会报错，是因为<code>ts</code>的类型中<code>img</code>不存在<code>loading</code>的属性，解决办法是声明一个类型文件，将需要设置的标签属性继承到<code>HTML</code>属性就好了，别的标签也类似。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// react-unstable-attributes.d.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">"react"</span>;<br><br>declare module <span class="hljs-string">"react"</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImgHTMLAttributes</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLAttributes</span>&lt;<span class="hljs-title">T</span>&gt; &#123;</span><br>    loading?: <span class="hljs-string">"auto"</span> | <span class="hljs-string">"eager"</span> | <span class="hljs-string">"lazy"</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 参数</span><br>lazy：延迟加载。<br>eager：立即加载。<br>auto：由浏览器来决定是否延迟加载。<br></code></pre></td></tr></table></figure><p>但是在直接为图片加了<code>loading</code>属性之后并没有实现懒加载，后来在调试的时候意外为图片加了<code>width</code>尺寸之后发现竟然生效了，或许在真实场景之下还需要微调。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">&lt;<span class="hljs-selector-tag">img</span> loading=<span class="hljs-string">"lazy"</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">"90px"</span> /&gt;<br></code></pre></td></tr></table></figure><p><code>loading=&quot;lazy&quot;</code>的属性对于别的浏览器的兼容一般，可以利用<code>js</code>判断，不支持<code>loading</code>的话使用<code>IntersectionObserver</code>优雅降级。<a href="https://juejin.im/post/6844903830581149710" target="_blank" rel="noopener">可参考</a></p></li><li><h3 id="h5-IntersectionObserver-api"><a href="#h5-IntersectionObserver-api" class="headerlink" title="h5 IntersectionObserver api"></a><code>h5 IntersectionObserver api</code></h3><p><code>IntersectionObserver</code> 提供了一种异步检测目标元素与祖先元素或 <code>viewport</code> 相交情况变化的方法。它会注册一个回调函数，每当被监视的元素进入或者退出另外一个元素时(或者 视口 )，或者两个元素的相交部分大小发生变化时，该回调方法会被触发执行。这样，我们网站的主线程不需要再为了监听元素相交而辛苦劳作，浏览器会自行优化元素相交管理。<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Intersection_Observer_API" target="_blank" rel="noopener">摘自 MDN</a></p><p>兼容的<code>folyfill intersection-observer</code></p><p>伪代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// 注册一个回调函数 满足条件的时候自动执行为图片src赋值</span><br><span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> IntersectionObserver(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">changes</span>) </span>&#123;<br>  changes.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element, index</span>) </span>&#123;<br><br>    <span class="hljs-comment">// 当这个值大于0，说明满足我们的加载条件了，这个值可通过rootMargin手动设置</span><br>    <span class="hljs-keyword">if</span> (element.intersectionRatio &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 设置图片src属性来加载</span><br>      element.target.src = element.target.dataset.src;<br><br>      <span class="hljs-comment">// 放弃监听，防止性能浪费。</span><br>      observer.unobserve(element.target);<br>    &#125;<br>  &#125;);<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initObserver</span>(<span class="hljs-params"></span>) </span>&#123;<br>  [...document.querySelectorAll(<span class="hljs-string">'.list-item-img'</span>)].forEach(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 对每个list元素进行监听</span><br>    observer.observe(item);<br>  &#125;);<br>&#125;<br><br>useEffect(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  initObserver()<br>&#125;, [])<br><br><span class="hljs-comment">// jsx</span><br>&lt;img <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"list-item-img"</span> data-src=<span class="hljs-string">"1.png"</span>/&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"list-item-img"</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">"2.png"</span>/&gt;</span></span><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>h5-api</tag>
      
      <tag>IntersectionObserver</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlab-ci.yml文件的一些总结</title>
    <link href="/2020/10/24/gitlab-ci/"/>
    <url>/2020/10/24/gitlab-ci/</url>
    
    <content type="html"><![CDATA[<h2 id="基础抽象概念"><a href="#基础抽象概念" class="headerlink" title="基础抽象概念"></a>基础抽象概念</h2><ul><li><h3 id="runner"><a href="#runner" class="headerlink" title="runner"></a><code>runner</code></h3>用来执行软件集成脚本的东西，<code>runner</code> 的机器是需要能够通过网络访问 <code>GitLab</code> 服务器<ul><li><code>Shared Runner</code> 场景：所有的工程都有可能需要在公司的服务器上进行编译、测试、部署等工作，这个时候注册一个<code>Shared Runner</code>供所有工程使用就很合适</li><li><code>Specific Runner</code> 场景：个人的电脑或者服务器上自动构建我参与的某个工程，这个时候注册一个 <code>Specific Runner</code> 就很合适</li></ul></li><li><h3 id="pipleline"><a href="#pipleline" class="headerlink" title="pipleline"></a><code>pipleline</code></h3>一整个工作流</li><li><h3 id="stage"><a href="#stage" class="headerlink" title="stage"></a><code>stage</code></h3>一整个工作流是由于多个 <code>stage</code> 组成<ul><li>如果两个任务对应的 <code>stage</code> 名相同，则这两个任务会并行运行</li><li>下一个 <code>stage</code> 关联的任务会等待上一个 <code>stage</code> 执行成功后才继续运行，失败则不运行</li></ul></li><li><h3 id="job"><a href="#job" class="headerlink" title="job"></a><code>job</code></h3>每一个 <code>stage</code> 由至少一个 <code>Job</code> 组成</li><li><h3 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h3>镜像 指定一个任务 <code>（job）</code> 所使用的 <code>docker</code> 镜像</li><li><h3 id="only-except"><a href="#only-except" class="headerlink" title="only / except"></a><code>only / except</code></h3>当符合定义的策略时才会触发 <code>Pipelines</code> 的执行，<code>except</code> 则相反。</li><li><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a><code>variables</code></h3>定义变量</li></ul><h2 id="gitlab-ci-yml-示例说明"><a href="#gitlab-ci-yml-示例说明" class="headerlink" title=".gitlab-ci.yml 示例说明"></a><code>.gitlab-ci.yml</code> 示例说明</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-symbol">stages:</span><br>  <span class="hljs-meta">#- 先定义几个阶段 在yml加载完成之后就会在pipeline里出现三个stages stage的名称是下边开始的最前边的名称【name1、name2、name3】</span><br>  - assemble<br>  - deploy<br>  - success<br><br>  <span class="hljs-meta">#- stage的名称</span><br><span class="hljs-symbol">name1:</span><br>  <span class="hljs-meta">#- 对应第一个需要处理的阶段</span><br><span class="hljs-symbol">  stage:</span> assemble<br>  <span class="hljs-meta">#- 需要在assemble的时候运行的脚本 `linux` 的命令</span><br><span class="hljs-symbol">  script:</span><br>    - ls -la<br>    - rm -rf node_module<br>    - pwd<br><span class="hljs-symbol">name2:</span><br><span class="hljs-symbol">  stage:</span> deploy<br>  <span class="hljs-meta">#- 依赖项目</span><br><span class="hljs-symbol">  dependencies:</span><br>    - name1<br>  <span class="hljs-meta">#- 需要在deploy的时候运行的脚本</span><br><span class="hljs-symbol">  script:</span><br><span class="hljs-symbol"><br>name3:</span><br><span class="hljs-symbol">  stage:</span> success<br>  <span class="hljs-meta">#- 依赖项目</span><br><span class="hljs-symbol">  dependencies:</span><br>    - name2<br>  <span class="hljs-meta">#- 需要在success的时候运行的脚本</span><br><span class="hljs-symbol">  script:</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>gitlab-ci</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中下载的一些总结</title>
    <link href="/2020/10/21/browserDownload/"/>
    <url>/2020/10/21/browserDownload/</url>
    
    <content type="html"><![CDATA[<h1 id="通过-http-请求返回的-json-数据，如何下载到本地作为调试的-mock-数据？"><a href="#通过-http-请求返回的-json-数据，如何下载到本地作为调试的-mock-数据？" class="headerlink" title="通过 http 请求返回的 json 数据，如何下载到本地作为调试的 mock 数据？"></a>通过 <code>http</code> 请求返回的 <code>json</code> 数据，如何下载到本地作为调试的 <code>mock</code> 数据？</h1><h2 id="二进制文件等部分涉及"><a href="#二进制文件等部分涉及" class="headerlink" title="二进制文件等部分涉及"></a>二进制文件等部分涉及</h2><h3 id="浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多Blob，DataURL，Base64-，ObjectURL"><a href="#浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多Blob，DataURL，Base64-，ObjectURL" class="headerlink" title="浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多Blob，DataURL，Base64 ，ObjectURL"></a>浏览器中的下载一般都会涉及到二进制，浏览器中常见的二进制以及特殊的数据相关的用的最多<code>Blob，DataURL，Base64 ，ObjectURL</code></h3><ul><li><p><code>Blob</code> 是浏览器端的类文件对象，存储着二进制的数据，其接受两个参数，第一个参数，<code>array</code> 是一个由 <code>ArrayBuffer</code> , <code>ArrayBufferView</code> , <code>Blob</code> , <code>DOMString</code> 等对象构成的 <code>Array</code> ，或者其他类似对象的混合体，它将会被放进 <code>Blob</code> 。<code>DOMStrings</code> 会被编码为 <code>UTF-8</code> 。第二个参数是文件的 <code>MIME</code> 类型</p></li><li><p><code>Data URL</code> 格式</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-comment">// 格式</span><br>data:<span class="hljs-meta">[&lt;mediatype&gt;]</span>[;base64],&lt;data&gt;<br><br><span class="hljs-comment">// 浏览器地址栏可以直接访问</span><br>data:text/html,&lt;h1&gt;Hello%<span class="hljs-number">2</span>C%<span class="hljs-number">20</span>World!&lt;/h1&gt;<br></code></pre></td></tr></table></figure></li><li><p><code>Base64</code> 最常用的场景一般是将图片压缩处理，但是编码之后存储较大</p></li><li><p><code>ObjectURL</code> 浏览器的 <code>URL</code> 对象生成一个地址来表示 <code>Blob</code> 数据</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">URL</span>.createObjectURL(<span class="hljs-built_in">new</span> Blob(<span class="hljs-string">'hello, world'</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">''</span>)))<br></code></pre></td></tr></table></figure></li></ul><h2 id="具体下载思路"><a href="#具体下载思路" class="headerlink" title="具体下载思路"></a>具体下载思路</h2><h3 id="一般接口返回值都是-json-结构，所以可以先将其-JSON-stringify-序列化为-JSON-字符串，想要将接口返回的数据下载，有两种思路"><a href="#一般接口返回值都是-json-结构，所以可以先将其-JSON-stringify-序列化为-JSON-字符串，想要将接口返回的数据下载，有两种思路" class="headerlink" title="一般接口返回值都是 json 结构，所以可以先将其 JSON.stringify 序列化为 JSON 字符串，想要将接口返回的数据下载，有两种思路"></a>一般接口返回值都是 <code>json</code> 结构，所以可以先将其 <code>JSON.stringify</code> 序列化为 <code>JSON</code> 字符串，想要将接口返回的数据下载，有两种思路</h3><ul><li>将 <code>JSON</code> 字符串文本转换为 <code>Data URL</code></li><li>将 <code>JSON</code> 字符串文本转换为 <code>Blob</code> ，再由 <code>Blob</code> 创建 <code>ObjectURL</code></li><li>最终都通过 <code>a</code> 标签的模拟点击来下载</li></ul><p>具体伪代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> download = <span class="hljs-function">(<span class="hljs-params">url: string, name: string</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> aTag = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"a"</span>);<br>  aTag.download = name;<br>  aTag.rel = <span class="hljs-string">"noopener"</span>;<br>  aTag.href = url;<br>  <span class="hljs-comment">// 触发模拟点击</span><br>  aTag.dispatchEvent(<span class="hljs-keyword">new</span> MouseEvent(<span class="hljs-string">"click"</span>));<br>&#125;;<br><br><span class="hljs-comment">// 方案1:</span><br><span class="hljs-keyword">const</span> downloadStr = <span class="hljs-built_in">JSON</span>.stringify(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 第三个参数用来将数据格式化一下</span><br><span class="hljs-keyword">const</span> dataUrl = <span class="hljs-string">`data:,<span class="hljs-subst">$&#123;downloadStr&#125;</span>`</span>;<br>download(dataUrl, <span class="hljs-string">"data.json"</span>);<br><br><span class="hljs-comment">// 方案2:</span><br><span class="hljs-keyword">const</span> downloadUrl = URL.createObjectURL(<span class="hljs-keyword">new</span> Blob(downloadStr.split(<span class="hljs-string">""</span>)));<br>download(downloadUrl, <span class="hljs-string">"data.json"</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日常工作git命令总结</title>
    <link href="/2020/09/15/gitSummary/"/>
    <url>/2020/09/15/gitSummary/</url>
    
    <content type="html"><![CDATA[<p>结合vscode会很强大</p><h2 id="生成sshkey"><a href="#生成sshkey" class="headerlink" title="生成sshkey"></a>生成sshkey</h2><ul><li><code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code></li><li><code>cd ~/.ssh</code> 复制 <code>id_rsa.pub</code> 内容复制到 <code>git</code> 库中</li></ul><h2 id="配置信息以及查看"><a href="#配置信息以及查看" class="headerlink" title="配置信息以及查看"></a>配置信息以及查看</h2><ul><li><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><ul><li><code>git config --list</code></li></ul></li><li><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><ul><li><p><code>git config --global user.name &quot;yourname&quot;</code></p></li><li><p><code>git config --global user.email &quot;your_email&quot;</code></p></li></ul></li><li><h3 id="在不同-git-文件下-config-中设置不同的局部变量"><a href="#在不同-git-文件下-config-中设置不同的局部变量" class="headerlink" title="在不同 .git 文件下 config 中设置不同的局部变量"></a>在不同 <code>.git</code> 文件下 <code>config</code> 中设置不同的局部变量</h3><ul><li><code>git config  user.name &quot;name&quot;</code></li><li><code>git config  user.email &quot;email&quot;</code></li></ul></li></ul><h2 id="常用的基本操作"><a href="#常用的基本操作" class="headerlink" title="常用的基本操作"></a>常用的基本操作</h2><ul><li><h3 id="初始化创建-git"><a href="#初始化创建-git" class="headerlink" title="初始化创建 .git"></a>初始化创建 <code>.git</code></h3><ul><li><code>git init -y</code> // 加参数可以跳过填写信息</li></ul></li><li><h3 id="添加本地已有文件到-git-远程仓库"><a href="#添加本地已有文件到-git-远程仓库" class="headerlink" title="添加本地已有文件到 git 远程仓库"></a>添加本地已有文件到 <code>git</code> 远程仓库</h3><ul><li><code>git remote add origin xxxx.git</code></li></ul></li><li><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><ul><li><code>git branch</code> // 当前本地分支</li><li><code>git branch -a</code> // 查看所有分支【本地+远程】</li></ul></li><li><h3 id="更新远程分支到本地分支"><a href="#更新远程分支到本地分支" class="headerlink" title="更新远程分支到本地分支"></a>更新远程分支到本地分支</h3><ul><li><code>git checkout -b &lt;localBranch&gt; origin/&lt;remoteBranch&gt;</code> // 更新远程分支 <code>remoteBranch</code> 在本地的 <code>localBranch</code> 分支上</li></ul></li><li><h3 id="临时存储"><a href="#临时存储" class="headerlink" title="临时存储"></a>临时存储</h3><p>开发了一半还没完成突然线上出现了紧急问题，这个时候工作区未清空的状态下 <code>git</code> 不允许签出和签入，此时不想 <code>commit</code> 的话，就要用到以下命令</p><ul><li><code>git stash</code> // 将目前的改动存储起来</li><li><code>git stash list</code> // 查看 <code>stash</code> 了哪些</li><li><code>git stash apply</code> // 如果要使用其他个，<code>git stash apply stash@{$num}</code> <code>num</code> 从 <code>0</code> 开始 结合 <code>vocode</code> 可以点击对应的就可以应用</li><li><code>git stash clear</code> // 清除掉 <code>stash</code></li></ul></li><li><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><ul><li><code>git checkout &lt;branch&gt;</code></li></ul></li><li><h3 id="若想基于当前分支拉出来一个新的分支"><a href="#若想基于当前分支拉出来一个新的分支" class="headerlink" title="若想基于当前分支拉出来一个新的分支"></a>若想基于当前分支拉出来一个新的分支</h3><ul><li><code>git checkout -b &lt;newBranch&gt;</code></li><li>推送到远程仓库 <code>git push origin &lt;newBranch&gt;</code></li></ul></li><li><h3 id="删除本地和远程分支"><a href="#删除本地和远程分支" class="headerlink" title="删除本地和远程分支"></a>删除本地和远程分支</h3><ul><li><code>git branch -d &lt;branch&gt;</code> // 有时候不生效可能需要换成 <code>-D</code></li><li><code>git push origin --delete &lt;branch&gt;</code></li></ul></li><li><h3 id="查看状态、将文件添加到缓冲区、提交到本地仓库"><a href="#查看状态、将文件添加到缓冲区、提交到本地仓库" class="headerlink" title="查看状态、将文件添加到缓冲区、提交到本地仓库"></a>查看状态、将文件添加到缓冲区、提交到本地仓库</h3><ul><li><code>git status</code></li><li><code>git log</code></li><li><code>git reflog</code> // 相比 <code>git log</code> 它每一步操作都能看到（ <code>.git</code> 下的 <code>refs</code> 目录存储指向数据（分支、远程仓库和标签等）的提交对象的指针，所以猜测 <code>git reflog</code> 基本上跟 <code>refs</code> 有关）</li><li><code>git add . | git add fileName</code></li><li><code>git commit -m &quot;msg&quot;</code> // <code>-m</code> 参数表示可以直接输入后面的 <code>message</code></li><li><code>git commit -a -m &quot;msg&quot;</code> // 相当于执行了 <code>git add . + git commit -m &quot;msg&quot;</code></li></ul></li><li><h3 id="重置提交信息"><a href="#重置提交信息" class="headerlink" title="重置提交信息"></a>重置提交信息</h3><ul><li><code>git commit --amend</code> // <code>git push</code> 的时候需要校验 <code>message</code> 格式，如果第一次写错的话就无法 <code>push</code> 到远程仓库，可以用这个修改提交的 <code>message</code> 重新 <code>push</code></li></ul></li><li><h3 id="pull-不下代码的情况"><a href="#pull-不下代码的情况" class="headerlink" title="pull 不下代码的情况"></a><code>pull</code> 不下代码的情况</h3><ul><li><code>git pull origin &lt;branch&gt;</code> // 偶尔会遇到服务器上的代码一直 <code>pull</code> 不下来，可以加上 <code>origin &lt;branch&gt;</code></li></ul></li><li><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><ul><li>个人习惯和原则：所有本地改动均已经推送到远程分支的前提</li><li><code>git merge &lt;branch&gt;</code> // 将 <code>branch</code> 分支合并到当前分支</li><li>简单的合并出现冲突，用 <code>vscode</code> 解决掉冲突，重新<code>add 、commit、push</code> 就可以，但是一些有时候出现一些比较复杂的冲突导致合并失败，再次操作的时候会提示当前正在处于合并之中（分支名后带着｜<code>MERGING</code>），需要 <code>git merge --abort</code> 选项会尝试恢复到你运行合并前的状态<br>如果已经合并发现合并错分支（所以合并的东西是不需要保留在工作空间的），可以使用 <code>git reset --hard HEAD~</code> 来还原到未合并之前，并且工作区是干净的状态</li><li>合并中出现 <code>Swap file .MERGE_MSG.swp already exists</code> 的情况需要打开当前项目 <code>.git</code> 文件删除 <code>.MERGE_MSG.sw*</code> 文件，再继续操作</li></ul></li><li><h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><ul><li><code>git reset --(soft | mixed | hard ) &lt; HEAD ~(num) &gt; |</code></li><li>用的比较多的是 <code>soft</code> 和 <code>hard</code></li><li>跟时间旅行一个道理，<code>git reset HEAD</code> 跟着  <code>HEAD@{1}(HEAD~) HEAD@{2}...</code> 或者分支的 <code>hash</code> 值可以将本地存储库切换到任意的版本</li><li>一种场景如果需要回退到某一次版本，并且不要那些版本的改动文件，可以使用 <code>git reset --hard HEAD</code>【硬回退】这个命名回回退到指定的版本并且删掉之前的改动文件，不会出现在暂存区。如果想回退到某次版本，并且需要暂存区看到改动的文件可以使用 <code>git reset --soft HEAD</code>【软回退】</li><li>回退到某个之前的版本的话， 需要 <code>git push origin &lt;branch&gt; --force</code> 推送到远程分支</li></ul></li><li><h3 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h3><ul><li><code>master</code> 分支推送可以直接使用 <code>git push</code></li><li>非 <code>master</code> 分支需要加上 <code>origin &lt;remoteBranch&gt;</code> 即：<code>git push origin remoteBranch</code></li></ul></li><li><h3 id="不是很常用的几个-git-命令"><a href="#不是很常用的几个-git-命令" class="headerlink" title="不是很常用的几个 git 命令"></a>不是很常用的几个 <code>git</code> 命令</h3><ul><li><p><code>git fetch</code> // 有时候不需要合并的时候会用一下，<code>git fetch</code> 和 <code>git pull</code> 的区别就是 <code>git pull = git fetch + git merge</code></p></li><li><p><code>submodule</code> 的命令</p><ul><li><code>git submodule init</code></li><li><code>git submodule foreach git submodule update</code></li><li><code>git submodule update --init</code></li></ul></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同一个项目切换移动端和PC端布局方案</title>
    <link href="/2020/09/14/checkPCMobile/"/>
    <url>/2020/09/14/checkPCMobile/</url>
    
    <content type="html"><![CDATA[<h1 id="部分响应式布局小结"><a href="#部分响应式布局小结" class="headerlink" title="部分响应式布局小结"></a>部分响应式布局小结</h1><p>代码在一个工程中如何做 <code>pc</code> 和 <code>mobile</code> 检测分别使用不同的组件以及样式？【一个目前个人解决的方案，但是项目大的话成本可能会高。更好的做法应该是一套代码根据屏幕大小自适应（类似栅栏布局）】</p><h3 id="判断是哪个端"><a href="#判断是哪个端" class="headerlink" title="判断是哪个端"></a>判断是哪个端</h3><ul><li><code>App.vue</code> 生命周期中通过 <code>isMobile</code> 方法判断是属于哪个端</li><li>为顶级标签设置命名空间（ <code>css</code> 样式用）</li><li><code>v-if</code> 切换不同的 <code>router-view</code> ，这里只需要切到入口路由就可以，其它的在路由跳转的时候钩子函数中判断路由路径包不包含 <code>mobile/pc</code> 的 <code>key</code> ，从而判断在 <code>next</code> 的时候要不要拼上 <code>mobile/pc</code> 的文件路径跳转。</li></ul><p><code>App.vue</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs undefined">methods: &#123;<br>  isMobile() &#123;<br>    <span class="hljs-keyword">let</span> flag = navigator.userAgent.match(<span class="hljs-regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>);<br>    <span class="hljs-keyword">this</span>.isMobileDevice = flag;<br>    <span class="hljs-keyword">return</span> flag;<br>  &#125;<br>&#125;,<br>mounted() &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isMobile()) &#123;<br>  &lt;!-- 如果是移动端的话需要设置rem --&gt;<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">doc, win</span>) </span>&#123;<br>      <span class="hljs-keyword">let</span> docEl = doc.documentElement;<br>      <span class="hljs-keyword">let</span> resizeEvt =<br>        <span class="hljs-string">"orientationchange"</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> ? <span class="hljs-string">"orientationchange"</span> : <span class="hljs-string">"resize"</span>;<br>      <span class="hljs-keyword">let</span> recalc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> clientWidth = docEl.clientWidth;<br>        <span class="hljs-keyword">if</span> (!clientWidth) <span class="hljs-keyword">return</span>;<br>        <span class="xml"><span class="hljs-comment">&lt;!-- 按照750尺寸设置 --&gt;</span><br>        if (clientWidth &gt;= 750) &#123;<br>          <span class="hljs-comment">&lt;!-- 100作为基准，100px为1rem --&gt;</span><br>          docEl.style.fontSize = "100px";<br>        &#125; else &#123;<br>          docEl.style.fontSize = 100 * (clientWidth / 750) + "px";<br>        &#125;<br>      &#125;;<br>      if (!doc.addEventListener) return;<br>      win.addEventListener(resizeEvt, recalc, false);<br>      doc.addEventListener("DOMContentLoaded", recalc, false);<br>    &#125;)(document, window);<br>    <span class="hljs-comment">&lt;!-- 增加顶级命名空间，用于区分不同端的css作用域 --&gt;</span><br>    this.$nextTick(() =&gt; &#123;<br>      window.document<br>        .getElementsByTagName("body")[0]<br>        .setAttribute("id", "mobile-web-app");<br>    &#125;);<br>  &#125; else &#123;<br>    this.$nextTick(() =&gt; &#123;<br>      window.document<br>        .getElementsByTagName("body")[0]<br>        .setAttribute("id", "pc-web-app");<br>    &#125;);<br>  &#125;<br>&#125;</span><br></code></pre></td></tr></table></figure><h3 id="pc-和-mobile-两套代码以及样式文件"><a href="#pc-和-mobile-两套代码以及样式文件" class="headerlink" title="pc 和 mobile 两套代码以及样式文件"></a><code>pc</code> 和 <code>mobile</code> 两套代码以及样式文件</h3><ul><li>针对定义命名空间 <code>style</code> 标签应该是<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-selector-id">#mobile-web-app</span>, <span class="hljs-selector-id">#pc-web-app</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-selector-id">#app</span> &#123;<br>    ....<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactPrompt 切换路由之前弹出拦截提示</title>
    <link href="/2020/09/06/reactPrompt/"/>
    <url>/2020/09/06/reactPrompt/</url>
    
    <content type="html"><![CDATA[<h3 id="Prompt-组件的逻辑"><a href="#Prompt-组件的逻辑" class="headerlink" title="Prompt 组件的逻辑"></a><code>Prompt</code> 组件的逻辑</h3><ul><li><code>when</code> 为 <code>true</code>，<code>message</code> 方法 <code>return</code> 的变量为 <code>false</code> 的时候就会提示。<code>message</code> 可以接受一个函数也可以接受一个字符串。</li><li>两个关键点，需要弹出提示的话属性即：<ul><li><code>when={true}</code></li><li><code>message={() =&gt; { return false }}</code></li></ul></li></ul><p>至于具体的 <code>message</code> 什么时候 <code>return true</code> 什么时候 <code>return false</code> 是需要按照业务处理。</p><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><ul><li><p>在 <code>JSX</code> 中增加组件，当切换路由的时候，<code>visible</code> 的状态会导致要不要提示，在满足条件需要弹出的时候，<code>visible</code> 要是 <code>true</code>。</p></li><li><p>例如：获取完数据之后，页面有数据的时候，切换路由是需要给出提示信息。先将 <code>visible</code> 属性值设置为 <code>true</code>，这样在有数据的时候，切换路由就会提示，<code>message</code> 方法 <code>return</code> 的 <code>boolean</code> 值为判断是否弹窗的逻辑，这里的 <code>boolean</code> 为 <code>false</code> 就会提示。</p></li><li><p>伪代码：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'umi/router'</span><br><br>&lt;Prompt<br>  <span class="hljs-keyword">when</span>=&#123;visible&#125; <span class="hljs-regexp">//</span> 有数据的时候visible一定是<span class="hljs-literal">true</span><br>  message=&#123;location =&gt; &#123;<br>    Modal.confirm(&#123;<br>      title: <span class="hljs-string">'请注意！'</span>,<br>      icon: &lt;ExclamationCircleOutlined /&gt;,<br>      content: <span class="hljs-string">'确定要离开当前页面吗？一旦确认离开，当前页面的数据将被作废！'</span>,<br>      okText: <span class="hljs-string">'确认'</span>,<br>      cancelText: <span class="hljs-string">'取消'</span>,<br>      onOk: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 确定按钮的逻辑<br>      &#125;,<br>      onCancel: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    &#125;);<br>    <span class="hljs-regexp">//</span> <span class="hljs-literal">false</span>弹窗拦截<br>    <span class="hljs-keyword">return</span> taskList.length &gt; <span class="hljs-number">0</span> ? <span class="hljs-literal">false</span> : <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br>/&gt;<br></code></pre></td></tr></table></figure></li></ul><p>防止踩坑的点：<code>message</code> 里的 <code>return</code> 一定要写在 <code>Modal</code> 的外边，这样在判断有数据的时候如果是 <code>return false</code> 就会自动弹出 <code>Modal</code> 拦截，如果是 <code>return true</code> 则不会提示。</p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eventLoop</title>
    <link href="/2020/08/27/eventLoop/"/>
    <url>/2020/08/27/eventLoop/</url>
    
    <content type="html"><![CDATA[<h1 id="主线程-任务队列-事件循环"><a href="#主线程-任务队列-事件循环" class="headerlink" title="主线程-任务队列-事件循环"></a>主线程-任务队列-事件循环</h1><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><ul><li>初始化压栈，执行同步任务、函数执行栈在主线程</li><li>主线程执行的是被压入执行栈的同步任务，不管来源是哪里，负责压入函数执行栈执行逻辑。异步任务的<code>callback</code>的逻辑会被事件循环通知后拿到这里来执行。</li></ul><h2 id="WebAPIs-任务队列-存放异步任务"><a href="#WebAPIs-任务队列-存放异步任务" class="headerlink" title="WebAPIs - 任务队列 存放异步任务"></a><code>WebAPIs</code> - 任务队列 存放异步任务</h2><ul><li><p>【<code>XHR</code>】任务队列中的都是已经完成了<code>http</code>请求，是获取完数据等待执行的回调函数。</p></li><li><p><code>AJAX</code> <code>handleData.fetchData()</code>理解为网络线程先去请求数据，拿到数据之后<code>.then(res =&gt; {})</code>回调函数注册到任务队列，进入异步的都是回调函数中的那部分程序。</p></li></ul><ul><li><p>宏任务</p><ul><li>定时器、<code>I/O</code></li></ul></li><li><p>微任务</p><ul><li><p>在当前的微任务没有执行完成时，是不会执行下一个宏任务的</p></li><li><p><code>Promise.resolve</code>和<code>return new Promise</code>都是同步任务立即执行</p></li><li><p><code>async/await</code>执行完之后，会立即返回，就是<code>await</code>后的程序，可以当作是<code>then</code>的回调函数，原理都是一样，只是异步转为同步的语法糖。</p></li><li><p>经典典型案例<code>Promise</code>练习</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script start'</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">await</span> async2() <span class="hljs-comment">// 执行完立刻返回</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async1 end'</span>) <span class="hljs-comment">// 相当于.then的callback</span><br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'async2 end'</span>)<br>&#125;<br>async1()<br>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'setTimeout'</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Promise'</span>)<br>  resolve()<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise1'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'promise2'</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'script end'</span>)<br></code></pre></td></tr></table></figure></li><li><p>同步任务开始 执行 <code>console.log</code> 打印 <code>script start</code></p></li><li><p>遇到 <code>async1()</code> 执行，内部执行await的方法<code>async2</code> ，打印 <code>async2 end</code> ，跳出【因为 <code>await</code> 后的相当于异步回调】</p></li><li><p>将 <code>async1 end</code> 注册到异步任务队列-微任务</p></li><li><p><code>setTimeout</code> 注册到异步任务队列-宏任务</p></li><li><p><code>new Promise</code> 同步执行打印 <code>Promise</code></p></li><li><p>分别注册 <code>promise1</code> 和 <code>promise2</code> 到微任务队列</p></li><li><p>执行 <code>console.log</code> 打印 <code>script end</code></p></li><li><p>主线程变空，事件循环通知主线程去任务队列拿取回调任务执行，按照 <code>FIFO</code> 的接口依次是执行 <code>async1</code> 的 <code>console.log</code> 和 <code>promise</code> 的两个 <code>then</code></p></li><li><p>执行宏任务 <code>setTimeout</code></p></li><li><p>结果 <code>script start、async2 end、Promise、script end、async1 end、promise1、promise2、setTimeout</code></p></li></ul></li></ul><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 <code>Event Loop</code></h2><ul><li><p>负责告诉主线程，执行哪个回调，分发任务，按照<code>FIFO</code>队列顺序执行。监听函数执行栈（主线程）是否为空，空则主线程从任务队列取出任务放进函数执行栈执行。</p></li><li><p>如果遇到主线程阻塞，异步任务队列的<code>callback</code>等待。</p></li><li><p>事件循环通知主线程，主线程从任务队列取出<code>callback</code>执行，是要主线程为空闲的时候才行，主线程如果一直有任务不释放，任务队列的<code>callback</code>一直是等待状态。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>事件循环</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器运行原理</title>
    <link href="/2020/08/24/howTheBrowserWorks/"/>
    <url>/2020/08/24/howTheBrowserWorks/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器运行原理梳理"><a href="#浏览器运行原理梳理" class="headerlink" title="浏览器运行原理梳理"></a>浏览器运行原理梳理</h2><p><img src="../../../../images/web-request.jpg" srcset="/img/loading.gif" alt="浏览器一个tab运行原理粗浅梳理"></p><h2 id="CPU串行"><a href="#CPU串行" class="headerlink" title="CPU串行"></a><code>CPU</code>串行</h2><ul><li>单核</li><li>多核</li></ul><h2 id="GPU图形处理器"><a href="#GPU图形处理器" class="headerlink" title="GPU图形处理器"></a>GPU图形处理器</h2><ul><li>多个核心共同工作，并行能力很强</li></ul><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><ul><li><p>渲染进程内存</p><ul><li><p>问题：因为多进程不会共享内存空间，进程数量多之后内存占用大</p></li><li><p>解决：进程数到达一定界限之后，会将同一个网站的 <code>tab</code> 放在同一个进程中跑</p></li></ul></li><li><p>网站隔离：跨站点的 <code>ifream</code> 拥有一个独立的进程，同源策略</p></li><li><p>浏览器主进程服务化</p><ul><li><p>拆分为不同的服务</p><ul><li>在一些性能好的机器上，运行单独的进程，提高系统的稳定性。</li><li>在一些性能不好的机器上，运行合并为一个进程，节约内存。</li></ul></li><li><p>目的：节省内存</p></li></ul></li></ul><h2 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h2><ul><li><h3 id="浏览器主进程，会有很多线程"><a href="#浏览器主进程，会有很多线程" class="headerlink" title="浏览器主进程，会有很多线程"></a>浏览器主进程，会有很多线程</h3><ul><li><p>概览：主进程会得知这些请求以及线程创建通信的信息，主进程得知数据准备完成之后，会通过<code>IPC</code>通知渲染进程，可以提交本次导航，并且继续接受接下来的<code>HTML</code>数据，渲染进程导航结束之后会通知主进程，本次导航结束，开始加载并且渲染和解析<code>HTML</code>文档。这时候，浏览器<code>tab</code>的当前会话会被更新为新导航的地址，以及开始加载<code>tab</code>菊花、生效后退按钮，为了方便打开之前关闭的tab会话，浏览器的历史会话会被保存在磁盘上。</p></li><li><p>负责包括地址栏，书签栏，前进后退按钮等部分的工作；</p></li><li><p>负责处理浏览器的一些不可见的底层操作，比如网络请求和文件访问；</p></li><li><p>导航输入-<code>UI</code>线程</p></li><li><p>处理输入</p><ul><li><p>根据用户的输入，<code>UI</code>线程要进行一系列的解析来判定是将用户输入发送给搜索引擎还是直接请求输入的站点资源。</p></li><li><p>开始处理</p><p>  当用户按下回车键的时候，确定解析类型</p><ul><li><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><p>浏览器发送请求前，根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。</p></li><li><p>没有命中强缓存规则，浏览器会发送请求，根据请求头的<code>last-modified</code>和<code>etag</code>判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。</p></li><li><p>如果前两步都没有命中，则直接从服务端获取资源。</p></li></ul></li></ul></li><li><p>读取响应</p><ul><li><p>确定响应主体的具体媒体类型<code>（MIME Type）</code>，最直接的方法就是通过<code>HTTP</code>请求头的 <code>Content-Type</code> 来判断是属于哪种媒体类型，网络线程告知<code>UI</code>线程，数据已经准备好可以开始导航到所需要的站点</p></li><li><p>在开始处理的时候，已经知道要导航到哪里的站点，浏览器为了优化，<code>UI</code>线程其实已经在这一步开始提前启动创建了一个渲染进程，如果一切都没问题，响应回来之后就可以直接准备渲染，而不是等数据准备好之后才开始创建。如果网站失效或者重定向之类的话，刚刚为先前的站点创建的渲染进程会被摒弃，从而开始创建一个新的目标渲染进程。</p></li></ul></li><li><p><code>Content-Type: text/html</code></p></li><li><p><code>zip</code> <code>/</code> 静态资源文件</p></li></ul></li><li><p>网络请求-网络线程</p><ul><li><p>发起新的请求：网络线程 初始化一个网络请求来获取站点的内容。网络线程会进行一系列诸如<code>DNS</code>寻址以及为请求建立<code>TLS</code>连接等的操作。网络线程会准备一些操作，如下：</p><ul><li><code>DNS</code>域名解析</li><li>建立<code>TCP</code>连接</li><li><code>SSL/TLS</code></li><li>发起<code>HTTP/HTTPS</code>请求</li></ul></li><li><p><code>DNS</code>解析</p></li><li><p><code>TCP/IP</code>连接</p></li><li><p><code>SSL/TLS</code></p><ul><li><code>TLS</code> 握手协议（非对称加密算法），客户端带着<code>HOST</code>以及随机生成的一个<code>session key1</code>去服务器握手，服务器收到<code>TLS</code>请求，根据客户端<code>HOST</code>寻找主机以及安全证书，服务器生成一个<code>session key2</code>以及将加密套件和证书返回给浏览器，客户端验证证书有效性（有效性，域名，有效机构，吊销状态）必须全部满足，否则会提示警告，验证如果通过，浏览器生成一份<code>session key3</code>通过第二步服务器返回的公钥加密，将结果再次返回给服务器，浏览器将<code>session key1、session key2、session key3</code>组合生成一个新的<code>session key</code>，服务器收到4的数据，利用非对称加密算法解析出<code>session key3</code>，同样也用<code>key123</code>组合生成<code>session key</code></li></ul></li><li><p><code>HTTP/HTTPS</code>响应</p><ul><li><p>响应类型</p><ul><li><p>静态文件 <code>html-&gt;text/html</code></p></li><li><p>静态文件 <code>js-&gt;application/javascript</code></p></li><li><p>静态图片 <code>image/png、jpg、jpeg、webp</code></p></li><li><p><code>json</code>数据 <code>application/json</code></p></li><li><p><code>css</code>样式 <code>text/css</code></p></li></ul></li></ul></li></ul></li><li><p>文件读写-存储线程</p></li></ul></li><li><h3 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h3><ul><li><p>概览：负责一个 <code>tab</code> 内关于网页呈现的所有事情。<br>  导航被确认之后，渲染进程会用相关资源开始渲染页面。渲染完成之后，通过<code>IPC</code>告知浏览器进程，<code>UI</code>线程从而停止<code>loading</code>。<br>  如果在这个时候突然重新输入一个新的站点，旧的进程做收尾工作，新的进程开始新的一轮流程操作。<br>  尽可能的为每个新开的<code>Tab</code>创建一个单独的内存以及进程（安全、沙箱）</p></li><li><p>主线程</p><p>  解析</p><p>  <code>HTML</code>文档转换为<code>DOM</code>对象</p><ul><li><p><code>HTML</code>的解析按照<code>HTML</code>标准来解析</p></li><li><p>解析次级资源 -&gt; 转为网络线程下载</p><ul><li><p>渲染进程解析的过程中，如果遇到网页中的<code>&lt;img&gt;&lt;link&gt;</code>这些标签等，浏览器会渲染进程转而让网络线程去现在这些资源</p><ul><li><p>图片</p></li><li><p><code>css</code>样式</p></li><li><p><code>js</code></p></li></ul></li></ul></li><li><p>JS的下载和执行</p><ul><li><code>JS</code>和<code>DOM</code>解析是互斥的，因为<code>JS</code>操作可能会改变<code>DOM</code>结构，遂需要<code>DOM</code>加载完成之后。在遇到<code>script</code>标签的时候，<code>HTML</code>的加载和解析都会停止。</li></ul></li><li><p>构建<code>CSSOM</code></p><ul><li>根据元素选择器，渲染构建<code>CCSOM</code>，计算生成样式</li></ul></li><li><p>布局</p><ul><li>通过遍历<code>DOM</code>对象，计算样式和布局位置坐标以及盒子大小，生成布局树，布局树和<code>DOM</code>树的区别：视图可见为布局树，例如，<code>display:none</code>在布局树上不显示，但是在<code>DOM</code>树上会有</li></ul></li><li><p>绘制</p><ul><li>计算出了样式和布局左边，按照先后顺序绘制元素</li></ul></li><li><p>合成帧</p><ul><li>主线程通过遍历布局树生成层树，每一层都会被单独的栅格化，最后通过合成线程将层组合为帧。<br>  层树确定，主线程-&gt;合成线程，合成线程栅格化每一层，合成线程将其每一层分割为多个磁贴，每个磁贴会发送到栅格线程，栅格化每个磁贴，并且存储在<code>GPU</code>显存上</li></ul></li></ul></li><li><p>工作线程</p><ul><li>处理<code>web worker</code>或者<code>service worker</code>的一些事情</li></ul></li><li><p>合成线程</p><ul><li>合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程<code>（compositor thread）</code>里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。<br>合成器的优点在于，其工作无关主线程，合成器线程不需要等待样式计算或者<code>JS</code>执行，这就是为什么合成器相关的动画 最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。</li></ul></li><li><p>光栅线程</p><ul><li>将需要展示的信息转化为显示器的像素的过程叫做光栅化</li></ul></li></ul></li><li><h3 id="渲染进程-联系-用户事件"><a href="#渲染进程-联系-用户事件" class="headerlink" title="渲染进程 联系  用户事件"></a>渲染进程 联系  用户事件</h3><p>  概览：合成线程会将注册了事件的区域绑定为，非快速滚动区域。当用户事件发生在这些区域时，合成线程会将输入事件发送给主线程来处理。如果输入事件不是发生在非快速滚动区域，合成线程就无须主线程的参与来合成一个新的帧。</p><ul><li><p>事件监听伪代码</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">document.body.addEventListener(<span class="hljs-string">'touchstart'</span>, <span class="hljs-keyword">event</span> =&gt; &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>.target === area) &#123;<br><span class="hljs-keyword">event</span>.preventDefault()<br>&#125;<br>&#125;, &#123;passive: <span class="hljs-literal">true</span>&#125;);<br></code></pre></td></tr></table></figure><p>  <code>{passive: true}</code> 这个参数会告诉浏览器您仍要在主线程中侦听事件，合成线程也可以继续合成新的帧。<br>  否则，一些没有用户输入的页面，也会等主线程完成之后合成线程才干活，从而丧失合成线程优势。类似于同步和异步方式。</p></li><li><p>查找事件的目标对象</p><ul><li>当合成线程向主线程发送输入事件时，主线程要做的第一件事是通过命中测试去找到事件的目标对象。具体的命中测试流程是遍历在渲染流水线中生成的绘画记录来找到输入事件出现的<code>x, y</code>坐标上面描绘的对象是哪个</li></ul></li></ul></li><li><h3 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h3><ul><li>负责控制一个网页用到的所有插件</li></ul></li><li><h3 id="GPU-进程"><a href="#GPU-进程" class="headerlink" title="GPU 进程"></a><code>GPU</code> 进程</h3><ul><li>负责处理 <code>GPU</code> 相关的任务，独立进程是因为要处理不同<code>tab</code>的渲染请求</li></ul></li><li><h3 id="工具进程"><a href="#工具进程" class="headerlink" title="工具进程"></a>工具进程</h3></li><li><h3 id="下载管理器"><a href="#下载管理器" class="headerlink" title="下载管理器"></a>下载管理器</h3></li></ul><h2 id="浏览器主线程、v8解析多线程解析、执行js"><a href="#浏览器主线程、v8解析多线程解析、执行js" class="headerlink" title="浏览器主线程、v8解析多线程解析、执行js"></a>浏览器主线程、<code>v8</code>解析多线程解析、执行<code>js</code></h2><ul><li><p>概括</p><ul><li><p><code>JavaScirpt</code>引擎可以将JS代码编译为不同<code>CPU</code>对应的汇编代码，这样我们才不要去翻阅每个<code>CPU</code>的指令集手册。当然，<code>JavaScript</code>引擎的工作也不只是编译代码，它还要负责执行代码、分配内存以及垃圾回收。</p></li><li><p><code>V8</code>属于<code>JIT</code>编译器，在运行的时候先编译再执行，这种方式被称为即时编译，直接运行源码<code>js</code></p></li><li><p>图片参考：<a href="https://image.fundebug.com/2019-07-16-ignition-turbofan-pipeline.png" target="_blank" rel="noopener">https://image.fundebug.com/2019-07-16-ignition-turbofan-pipeline.png</a>、<a href="https://pic3.zhimg.com/80/v2-577dc100b5725942708b9ab7e74ac4b0_720w.jpg" target="_blank" rel="noopener">https://pic3.zhimg.com/80/v2-577dc100b5725942708b9ab7e74ac4b0_720w.jpg</a></p></li><li><p>解释器参考：<a href="https://zhuanlan.zhihu.com/p/41496446" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41496446</a></p></li></ul></li><li><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3></li><li><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><ul><li>汇总：词法分析、语法分析 将<code>JavaScript</code>源码转换为<code>AST</code>、<code>AST</code>生成作用域以及执行上下文，对所有的变量和函数定义 预编译<ul><li>词法作用域和动态作用域<ul><li>词法作用域是在定义的时候作用域已经定了,跟着书写的位置查找上一层的代码</li><li>动态作用域是代码运行的时候，当前函数作用域找不到，会出去当前函数的上下文</li></ul></li></ul></li></ul></li><li><h3 id="Ignition解释器构建代码"><a href="#Ignition解释器构建代码" class="headerlink" title="Ignition解释器构建代码"></a><code>Ignition</code>解释器构建代码</h3><p>  一个具有累加的寄存器</p><ul><li><p>根据<code>AST</code>和作用域转生成字节码（内存小于机器码）、执行 </p></li><li><p>此处已经开始执行，只是执行的不是<code>hot</code>的热点代码</p></li><li><p>收集函数运行时的信息</p></li></ul></li><li><h3 id="TurboFan编译器"><a href="#TurboFan编译器" class="headerlink" title="TurboFan编译器"></a><code>TurboFan</code>编译器</h3><ul><li><p>将解释器生成的字节码优化转为机器代码</p></li><li><p>热点代码：在被解释器多次执行的代码。</p></li><li><p>这部分的多次执行的代码，会被编译成二进制，下次执行的时候会直接执行二进制文件<code>（JIT）</code></p></li><li><p>为什么要叫编译器呢？因为会把热点代码编译成为类似c编译完成的那种可以直接执行的机器代码</p></li><li><h3 id="汇总："><a href="#汇总：" class="headerlink" title="汇总："></a>汇总：</h3><ul><li><code>Ignition</code>和<code>TurboFan</code> 从编译的角度上说基本上是一样的，为什么要这样设计?<ul><li>因为<code>TurboFan</code>会拿到热点代码直接编译成为二进制机器语言存在内存中，在<code>Ignition</code>运行的时候，如果是热点代码会直接去<code>TurboFan</code>运行二进制不用再次编译，本质上如果不是热点代码就会在<code>Ignition</code>运行，所以<code>TurboFan</code>是优化提高性能</li></ul></li></ul></li></ul></li><li><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>回收不需要的内存释放空间</li></ul></li><li><h3 id="一些杂话"><a href="#一些杂话" class="headerlink" title="一些杂话"></a>一些杂话</h3><ul><li><code>v8</code>看不懂代码，拿到的东西是字符串、<code>v8</code>对源码做一些处理生成可以认识的<code>AST</code></li><li>移动端暴露出来的问题就是占用内存爆-字节码来调节内存和执行速度</li></ul></li></ul><h2 id="语言分类"><a href="#语言分类" class="headerlink" title="语言分类"></a>语言分类</h2><ul><li><h3 id="编译性"><a href="#编译性" class="headerlink" title="编译性"></a>编译性</h3><ul><li>只需要编译一次就可以把源代码编译成为机器语言，以后执行不需要再编译，直接运行</li><li>不同平台对编译器影响比较大，在编译的时候，位数限制可能会导致<code>int/long</code>等给定的字节不同，导致变量位数不同从而跨平台低</li></ul></li><li><h3 id="解释性"><a href="#解释性" class="headerlink" title="解释性"></a>解释性</h3><ul><li>源代码-中间代码-机器语言</li><li>解释器对中间代码进行解释和运行</li></ul></li><li><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>解释器立即解释和执行代码、编译器为接下来准备运行的代码做好准备</li><li>编译器：生成一个可执行文件，运行的时候已经脱离的源代码、跨平台低<br>解释器：实时需要解释器解释代码、跨平台高（<code>node</code>支持<code>linux/windos</code> ==&gt; 中间代码字节码在<code>v8</code>里被解释为机器码二进制 ==&gt; <code>js</code>运行在各处）</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Hook 父组件调用子组件方法</title>
    <link href="/2020/08/22/callChildComponentMethod/"/>
    <url>/2020/08/22/callChildComponentMethod/</url>
    
    <content type="html"><![CDATA[<h3 id="父组件引入useRef"><a href="#父组件引入useRef" class="headerlink" title="父组件引入useRef"></a>父组件引入<code>useRef</code></h3><p>在 <code>react</code> 中使用函数组件以及 <code>hooks</code> 之后，有遇到，在父组件需要调用子组件方法的地方，可以通过 <code>ref</code> 的转发，做到在父组件执行子组件的方法，为什么需要转发 <code>refs</code>，是因为默认情况下，函数组件没有实例，无法使用 <code>ref</code> 属性。所以如果需要在函数组件中使用 <code>ref</code>，其是指向 <code>dom</code> 元素。</p><p>其具体流程是：在父组件中创建 <code>ref</code>，并且通过属性的方式传递给子组件，子组件通过 <code>forwardRef</code> 包裹子组件，这样才能在子组件中的第二个参数中获取到 <code>ref</code>，此时获取到 <code>ref</code> 之后，<code>ref</code> 已经转发成功，当 <code>ref</code> 挂载完成之后，<code>ref.curren</code>t 将会指向子组件。</p><p><code>parent.tsx</code><br><img src="../../../../images/parent.png" srcset="/img/loading.gif" alt="parentComponent"></p><h3 id="子组件引入forwardRef和useImperativeHandle"><a href="#子组件引入forwardRef和useImperativeHandle" class="headerlink" title="子组件引入forwardRef和useImperativeHandle"></a>子组件引入<code>forwardRef</code>和<code>useImperativeHandle</code></h3><p><code>child.tsx</code><br><img src="../../../../images/children.jpg" srcset="/img/loading.gif" alt="childrenComponent"></p>]]></content>
    
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>umi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记Mac下Hexo+github.io搭建个人静态博客</title>
    <link href="/2019/08/10/category/"/>
    <url>/2019/08/10/category/</url>
    
    <content type="html"><![CDATA[<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>  已经在 <code>GitHub</code> 配置过 <code>ssh</code> 并且已经使用 <code>ssh -T git@github.com</code> 并且测试成功</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 <code>Hexo</code></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ sudo npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><p>新建目录为<code>myBlog</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">cd</span> myBlog</span><br><span class="hljs-meta">$</span><span class="bash"> hexo init</span><br></code></pre></td></tr></table></figure><p>初始化，会下载一基础文件，初次运行会自动 <code>npm install</code> 下载其他的包进行安装</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>默认地址为 <code>http://localhost:4000</code><br>此时就可以看到默认的主题博客</p><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><p>创建成功会提示在<code>source</code>目录下</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>下载自己喜欢的主题放置于根目录 <code>themes</code> 下</p><h3 id="关联-GitHub"><a href="#关联-GitHub" class="headerlink" title="关联 GitHub"></a>关联 <code>GitHub</code></h3><p>新建仓库，仓库名称必须为 <code>user.github.io</code></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>打开根目录 <code>_config.yml</code>文件，并且针对性修改，配置 <code>deploy</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">repository</span>: git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:user/user.github.io.git<br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><h3 id="安装-hexo-deployer-git"><a href="#安装-hexo-deployer-git" class="headerlink" title="安装 hexo-deployer-git"></a>安装 <code>hexo-deployer-git</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">$ npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="生成静态文件并上传到-github-服务器"><a href="#生成静态文件并上传到-github-服务器" class="headerlink" title="生成静态文件并上传到 github 服务器"></a>生成静态文件并上传到 <code>github</code> 服务器</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined"><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p>此后便可以通过 <code>https://user.github.io/</code> 访问博客。</p><br><br><br>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/08/08/hello-world/"/>
    <url>/2019/08/08/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="创建一篇新文章"><a href="#创建一篇新文章" class="headerlink" title="创建一篇新文章"></a>创建一篇新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span><br></code></pre></td></tr></table></figure><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">默认情况下，访问网址为： http://localhost:4000/<br>$ hexo s<br></code></pre></td></tr></table></figure><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><br><br><br>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
